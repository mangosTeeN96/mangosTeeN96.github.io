<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java_网络编程]]></title>
    <url>%2F2019%2F09%2F11%2FJava_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第一章 网络编程入门1.1软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 特点:数据被限制在64kb以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址.参数:String host:服务器主机的名称/服务器的IP地址int port:服务器的端口号 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket("127.0.0.1", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 12345678910111213141516171819202122public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端启动 , 等待连接 .... "); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); //5.关闭资源. is.close(); server.close(); &#125;&#125; 客户端实现： 1234567891011121314public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println("客户端 发送数据"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket("localhost", 6666); // 2.获取流对象 . 输出流 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write("你好么? tcp ,我来了".getBytes()); // 4. 关闭资源 . os.close(); client.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 12345678910111213141516171819202122232425262728public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端启动 , 等待连接 .... "); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); // =================回写数据======================= // 5. 通过 socket 获取输出流 OutputStream out = server.getOutputStream(); // 6. 回写数据 out.write("我很好,谢谢你".getBytes()); // 7.关闭资源. out.close(); is.close(); server.close(); &#125;&#125; 客户端实现： 12345678910111213141516171819202122public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println("客户端 发送数据"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket("localhost", 6666); // 2.通过Scoket,获取输出流对象 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write("你好么? tcp ,我来了".getBytes()); // ==============解析回写========================= // 4. 通过Scoket,获取 输入流对象 InputStream in = client.getInputStream(); // 5. 读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6. 关闭资源 . in.close(); os.close(); client.close(); &#125;&#125; 第三章 综合案例3.1 文件上传案例文件上传分析图解 文件上传案例的客户端:读取本地文件,上传到服务器,读取服务器回写的数据 明确:数据源:c:\\1.jpg目的地:服务器 实现步骤: 创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源 创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号 使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象 使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器 使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象 使用网络字节输入流InputStream对象中的方法read读取服务回写的数据 释放资源(FileInputStream,Socket) 123456789101112131415161718192021222324252627282930public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream("c:\\1.jpg"); //2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号 Socket socket = new Socket("127.0.0.1",8888); //3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 int len = 0; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; //5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器 os.write(bytes,0,len); &#125; //6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据 while((len = is.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //8.释放资源(FileInputStream,Socket) fis.close(); socket.close(); &#125;&#125; 文件上传案例服务器端:读取客户端上传的文件,保存到服务器的硬盘,给客户端回写”上传成功” 明确:数据源:客户端上传的文件目的地:服务器的硬盘 d:\\upload\\1.jpg 实现步骤: 创建一个服务器ServerSocket对象,和系统要指定的端口号 使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象 使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 判断d:\\upload文件夹是否存在,不存在则创建 创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地 使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件 使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上 使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象 使用网络字节输出流OutputStream对象中的方法write,给客户端回写”上传成功” 释放资源(FileOutputStream,Socket,ServerSocket) 1234567891011121314151617181920212223242526272829303132333435public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个服务器ServerSocket对象,和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); //2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象 Socket socket = server.accept(); //3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //4.判断d:\\upload文件夹是否存在,不存在则创建 File file = new File("d:\\upload"); if(!file.exists())&#123; file.mkdirs(); &#125; //5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(file+"\\1.jpg"); //6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件 int len =0; byte[] bytes = new byte[1024]; while((len = is.read(bytes))!=-1)&#123; //7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上 fos.write(bytes,0,len); &#125; //8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象 //9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功" socket.getOutputStream().write("上传成功".getBytes()); //10.释放资源(FileOutputStream,Socket,ServerSocket) fos.close(); socket.close(); server.close(); &#125;&#125; 文件上传阻塞问题上述代码开始运行后不会停止，是因为遇到了阻塞问题。 解决:上传完文件,给服务器写一个结束标记 void shutdownOutput() 禁用此套接字的输出流。 对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 在客户端5步骤之后加入下列代码： 1socket.shutdownOutput(); 文件上传优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下（用了缓冲流）： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+".jpg") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345678// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ...... socket.close();&#125;//服务器就不用关闭//server.close(); 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 由于多线程重写的Runnable接口中的run方法中，没有声明抛出异常，所以子类重写方法时，也不能把异常声明抛出，只能try…catch 优化实现服务器端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个服务器ServerSocket对象,和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); //2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象 /* 让服务器一直处于监听状态(死循环accept方法) 有一个客户端上传文件,就保存一个文件 */ while(true)&#123; Socket socket = server.accept(); /* 使用多线程技术,提高程序的效率 有一个客户端上传文件,就开启一个线程,完成文件的上传 */ new Thread(new Runnable() &#123; //完成文件的上传 @Override public void run() &#123; try &#123; //3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //4.判断d:\\upload文件夹是否存在,不存在则创建 File file = new File("d:\\upload"); if(!file.exists())&#123; file.mkdirs(); &#125; /* 自定义一个文件的命名规则:防止同名的文件被覆盖 规则:域名+毫秒值+随机数 */ String fileName = "itcast"+System.currentTimeMillis()+new Random().nextInt(999999)+".jpg"; //5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地 //FileOutputStream fos = new FileOutputStream(file+"\\1.jpg"); FileOutputStream fos = new FileOutputStream(file+"\\"+fileName); //6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件 int len =0; byte[] bytes = new byte[1024]; while((len = is.read(bytes))!=-1)&#123; //7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上 fos.write(bytes,0,len); &#125; //8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象 //9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功" socket.getOutputStream().write("上传成功".getBytes()); //10.释放资源(FileOutputStream,Socket,ServerSocket) fos.close(); socket.close(); &#125;catch (IOException e)&#123; System.out.println(e); &#125; &#125; &#125;).start(); &#125; //服务器就不用关闭 //server.close(); &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream("c:\\1.jpg"); //2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号 Socket socket = new Socket("127.0.0.1",8888); //3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 int len = 0; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; //5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器 os.write(bytes,0,len); &#125; /* 解决:上传完文件,给服务器写一个结束标记 void shutdownOutput() 禁用此套接字的输出流。 对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 */ socket.shutdownOutput(); //6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据 while((len = is.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //8.释放资源(FileInputStream,Socket) fis.close(); socket.close(); &#125;&#125; 3.2 模拟B\S服务器(扩展知识点)(没整理)模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 复制到我们Module中，比如复制到day08中 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 12345678//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(" ");//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端实现： 1234567891011121314151617181920212223242526272829303132333435public class SerDemo &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端 启动 , 等待连接 .... "); // 创建ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(" "); // 去掉web前面的/ String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 out.write("HTTP/1.1 200 OK\r\n".getBytes()); out.write("Content-Type:text/html\r\n".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write("\r\n".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); server.close(); &#125;&#125; 访问效果 火狐 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); while(true)&#123; Socket socket = server.accept(); new Thread(new Web(socket)).start(); &#125; &#125; static class Web implements Runnable&#123; private Socket socket; public Web(Socket socket)&#123; this.socket=socket; &#125; public void run() &#123; try&#123; //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(" "); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write("HTTP/1.1 200 OK\r\n".getBytes()); out.write("Content-Type:text/html\r\n".getBytes()); out.write("\r\n".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); &#125;catch(Exception ex)&#123; &#125; &#125; &#125;&#125; 访问效果： 图解：]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java_File类与IO流]]></title>
    <url>%2F2019%2F09%2F05%2FJava_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[第一章 File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 1.1 静态成员变量static String pathSeparator 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。static char pathSeparatorChar 与系统有关的路径分隔符。 static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。static char separatorChar 与系统有关的默认名称分隔符。 操作路径:路径不能写死了 C:\develop\a\a.txt windowsC:/develop/a/a.txt linux &quot;C:&quot;+File.separator+&quot;develop&quot;+File.separator+&quot;a&quot;+File.separator+&quot;a.txt&quot; 1234567891011public class Demo01File &#123; public static void main(String[] args) &#123; String pathSeparator = File.pathSeparator; System.out.println(pathSeparator);//路径分隔符 windows:分号; linux:冒号: String separator = File.separator; System.out.println(separator);// 文件名称分隔符 windows:反斜杠\ linux:正斜杠/ &#125;&#125; 1.2 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。参数:String pathname:字符串的路径名称路径可以是以文件结尾,也可以是以文件夹结尾路径可以是相对路径,也可以是绝对路径路径可以是存在,也可以是不存在创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。参数:把路径分成了两部分String parent:父路径String child:子路径好处:父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。参数:把路径分成了两部分File parent:父路径String child:子路径好处:父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化父路径是File类型,可以使用File的方法对路径进行一些操作,再使用路径创建对象 构造举例，代码如下： 123456789101112131415161718// 文件路径名String pathname = "D:\\aaa.txt";File file1 = new File(pathname); // 文件路径名File file2 = new File("D:\\aaa\\bbb.txt"); // 通过父路径和子路径字符串 String parent = "d:\\aaa"; String child = "bbb.txt"; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File("d:\\aaa");File file4 = new File(parentDir, "bbb.txt");//mac系统文件根目录有所不同，比如本篇博客目录为"/Users/tiansaijun/blog/source/_posts/Java_File类与IO流.md") 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 1.3 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径 public String getPath() ：将此File转换为路径名字符串。获取的构造方法中传递的路径toString方法调用的就是getPath方法源码: public String toString() { return getPath();} public String getName() ：返回由此File表示的文件或目录的名称。获取的就是构造方法传递路径的结尾部分(文件/文件夹) public long length() ：返回由此File表示的文件的长度。获取的是构造方法指定的文件的大小,以字节为单位注意:文件夹是没有大小概念的,不能获取文件夹的大小如果构造方法中给出的路径不存在,那么length方法返回0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Demo03File &#123; public static void main(String[] args) &#123; show04(); &#125; private static void show04() &#123; File f1 = new File("C:\\develop\\a\\1.jpg"); long l1 = f1.length(); System.out.println(l1);//780831字节 File f2 = new File("C:\\develop\\a\\2.jpg"); System.out.println(f2.length());//0 File f3 = new File("C:\\develop\\a"); System.out.println(f3.length());//0 文件夹没有大小概念的 &#125; private static void show03() &#123; File f1 = new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"); String name1 = f1.getName(); System.out.println(name1);//a.txt File f2 = new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan"); String name2 = f2.getName(); System.out.println(name2);//shungyuan &#125; private static void show02() &#123; File f1 = new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"); File f2 = new File("a.txt"); String path1 = f1.getPath(); System.out.println(path1);//C:\Users\itcast\IdeaProjects\shungyuan\a.txt String path2 = f2.getPath(); System.out.println(path2);//a.txt System.out.println(f1);//C:\Users\itcast\IdeaProjects\shungyuan\a.txt System.out.println(f1.toString());//C:\Users\itcast\IdeaProjects\shungyuan\a.txt &#125; private static void show01() &#123; File f1 = new File("C:\\Users\\itcast\\IdeaProjects\\shungyuan\\a.txt"); String absolutePath1 = f1.getAbsolutePath(); System.out.println(absolutePath1);//C:\Users\itcast\IdeaProjects\shungyuan\a.txt File f2 = new File("a.txt"); String absolutePath2 = f2.getAbsolutePath(); System.out.println(absolutePath2);//C:\Users\itcast\IdeaProjects\shungyuan\a.txt &#125;&#125; API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 注意: 路径是不区分大小写 路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File("D:\\bbb.java"); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File("bbb.java"); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\bbb.javaD:\idea_project_test4\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 1234567891011121314151617public class FileIs &#123; public static void main(String[] args) &#123; File f = new File("d:\\aaa\\bbb.java"); File f2 = new File("d:\\aaa"); // 判断是否存在 System.out.println("d:\\aaa\\bbb.java 是否存在:"+f.exists()); System.out.println("d:\\aaa 是否存在:"+f2.exists()); // 判断是文件还是目录 System.out.println("d:\\aaa 文件?:"+f2.isFile()); System.out.println("d:\\aaa 目录?:"+f2.isDirectory()); &#125;&#125;输出结果：d:\aaa\bbb.java 是否存在:trued:\aaa 是否存在:trued:\aaa 文件?:falsed:\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。返回值:布尔值true:文件/文件夹删除成功,返回truefalse:文件夹中有内容,不会删除返回false;构造方法中路径不存在false注意:delete方法是直接在硬盘删除文件/文件夹,不走回收站,删除要谨慎 public boolean mkdir() ：创建由此File表示的单级空文件夹 public boolean mkdirs() ：创建由此File表示的单级空文件夹,也可以创建多级文件夹 12345678910111213141516171819202122232425262728public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 File f = new File("aaa.txt"); System.out.println("是否存在:"+f.exists()); // false System.out.println("是否创建:"+f.createNewFile()); // true System.out.println("是否存在:"+f.exists()); // true // 目录的创建 File f2= new File("newDir"); System.out.println("是否存在:"+f2.exists());// false System.out.println("是否创建:"+f2.mkdir()); // true System.out.println("是否存在:"+f2.exists());// true // 创建多级目录 File f3= new File("newDira\\newDirb"); System.out.println(f3.mkdir());// false File f4= new File("newDira\\newDirb"); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false &#125;&#125; delete方法，如果此File表示目录，则目录必须为空才能删除。 1.4 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 注意: list方法和listFiles方法遍历的是构造方法中给出的目录 如果构造方法中给出的目录的路径不存在,会抛出空指针异常 如果构造方法中给出的路径不是一个目录,也会抛出空指针异常 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File("d:\\java_code"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 第二章 递归2.1 概述 递归：指在当前方法内调用自己的这种现象。 递归的分类: 递归分为两种，直接递归和间接递归。 直接递归称为方法自身调用自己。 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 构造方法,禁止递归 1234567891011121314151617181920212223242526272829303132333435363738public class Demo01DiGui &#123; public static void main(String[] args) &#123; // a(); b(1); &#125; /* * 3.构造方法,禁止递归 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去 */ public Demo01DiGui() &#123; //Demo01DiGui(); &#125; /* * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 * 4993 * Exception in thread "main" java.lang.StackOverflowError */ private static void b(int i) &#123; System.out.println(i); //添加一个递归结束的条件,i==5000的时候结束 if(i==5000)&#123; return;//结束方法 &#125; b(++i); &#125; /* * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread "main" * java.lang.StackOverflowError */ private static void a() &#123; System.out.println("a方法"); a(); &#125;&#125; 2.2 递归累加求和计算1 ~ n的和分析：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。 实现代码： 123456789101112131415161718192021222324252627282930public class DiGuiDemo &#123; public static void main(String[] args) &#123; //计算1~num的和，使用递归完成 int num = 5; // 调用求和的方法 int sum = getSum(num); // 输出结果 System.out.println(sum); &#125; /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public static int getSum(int num) &#123; /* num为1时,方法返回1, 相当于是方法的出口,num总有是1的情况 */ if(num == 1)&#123; return 1; &#125; /* num不为1时,方法返回 num +(num-1)的累和 递归调用getSum方法 */ return num + getSum(num-1); &#125;&#125; 代码执行图解 tips：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。 2.3 递归求阶乘 阶乘：所有小于及等于该数的正整数的积。 1n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 分析：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。 1推理得出：n! = n * (n-1)! 代码实现： 1234567891011121314151617181920212223242526public class DiGuiDemo &#123; //计算n的阶乘，使用递归完成 public static void main(String[] args) &#123; int n = 3; // 调用求阶乘的方法 int value = getValue(n); // 输出结果 System.out.println("阶乘为:"+ value); &#125; /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public static int getValue(int n) &#123; // 1的阶乘为1 if (n == 1) &#123; return 1; &#125; /* n不为1时,方法返回 n! = n*(n-1)! 递归调用getValue方法 */ return n * getValue(n - 1); &#125;&#125; 2.4 递归打印多级目录分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940/* 需求: 遍历c:\\abc文件夹,及abc文件夹的子文件夹 c:\\abc c:\\abc\\abc.txt c:\\abc\\abc.java c:\\abc\\a c:\\abc\\a\\a.jpg c:\\abc\\a\\a.java c:\\abc\\b c:\\abc\\b\\b.java c:\\abc\\b\\b.txt*/public class Demo04Recurison &#123; public static void main(String[] args) &#123; File file = new File("c:\\abc"); getAllFile(file); &#125; /* 定义一个方法,参数传递File类型的目录 方法中对目录进行遍历 */ public static void getAllFile(File dir)&#123; System.out.println(dir);//打印被遍历的目录名称 File[] files = dir.listFiles(); for (File f : files) &#123; //对遍历得到的File对象f进行判断,判断是否是文件夹 if(f.isDirectory())&#123; //f是一个文件夹,则继续遍历这个文件夹 //我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法 //所以直接调用getAllFile方法即可:递归(自己调用自己) getAllFile(f); &#125;else&#123; //f是一个文件,直接打印即可 System.out.println(f); &#125; &#125; &#125;&#125; 第三章 File综合案例3.1 文件搜索搜索D:\aaa 目录中的.java 文件。 分析： 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 需求: 遍历c:\\abc文件夹,及abc文件夹的子文件夹 只要.java结尾的文件 */public class Demo05Recurison &#123; public static void main(String[] args) &#123; File file = new File("c:\\abc"); getAllFile(file); &#125; /* 定义一个方法,参数传递File类型的目录 方法中对目录进行遍历 */ public static void getAllFile(File dir)&#123; //System.out.println(dir);//打印被遍历的目录名称 File[] files = dir.listFiles(); for (File f : files) &#123; //对遍历得到的File对象f进行判断,判断是否是文件夹 if(f.isDirectory())&#123; //f是一个文件夹,则继续遍历这个文件夹 //我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法 //所以直接调用getAllFile方法即可:递归(自己调用自己) getAllFile(f); &#125;else&#123; //f是一个文件,直接打印即可 /* c:\\abc\\abc.java 只要.java结尾的文件 1.把File对象f,转为字符串对象 */ //String name = f.getName();//abc.java //String path = f.getPath();//c:\\abc\\abc.java //String s = f.toString();//c:\\abc\\abc.java //把字符串,转换为小写 //s = s.toLowerCase(); //2.调用String类中的方法endsWith判断字符串是否是以.java结尾 //boolean b = s.endsWith(".java"); //3.如果是以.java结尾的文件,则输出 /*if(b)&#123; System.out.println(f); &#125;*/ if(f.getName().toLowerCase().endsWith(".java"))&#123; System.out.println(f); &#125; &#125; &#125; &#125;&#125; 3.2 文件过滤器优化在File类中有两个和ListFiles重载的方法,方法的参数 传递的就是过滤器 File[] listFiles(FileFilter filter)java.io.FileFilter接口:用于抽象路径名(File对象)的过滤器。作用:用来过滤文件(File对象)抽象方法:用来过滤文件的方法boolean accept(File pathname)测试指定抽象路径名是否应该包含在某个路径名列表中。参数:File pathname:使用ListFiles方法遍历目录,得到的每一个文件对象 File[] listFiles(FilenameFilter filter)java.io.FilenameFilter接口:实现此接口的类实例可用于过滤器文件名。作用:用于过滤文件名称抽象方法:用来过滤文件的方法boolean accept(File dir, String name)测试指定文件是否应该包含在某一文件列表中。参数:File dir:构造方法中传递的被遍历的目录String name:使用ListFiles方法遍历目录,获取的每一个文件/文件夹的名称 注意: 两个过滤器接口是没有实现类的,需要我们自己写实现类,重写过滤的方法accept,在方法中自己定义过滤的规则 分析： 接口作为参数，需要传递子类对象，重写其中方法 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： 1234567891011121314151617181920212223242526public class Demo01Filter &#123; public static void main(String[] args) &#123; File file = new File("c:\\abc"); getAllFile(file); &#125; /* 定义一个方法,参数传递File类型的目录 方法中对目录进行遍历 */ public static void getAllFile(File dir)&#123; File[] files = dir.listFiles(new FileFilterImpl());//传递过滤器对象 for (File f : files) &#123; //对遍历得到的File对象f进行判断,判断是否是文件夹 if(f.isDirectory())&#123; //f是一个文件夹,则继续遍历这个文件夹 //我们发现getAllFile方法就是传递文件夹,遍历文件夹的方法 //所以直接调用getAllFile方法即可:递归(自己调用自己) getAllFile(f); &#125;else&#123; //f是一个文件,直接打印即可 System.out.println(f); &#125; &#125; &#125;&#125; 接口 1234567891011121314151617public class FileFilterImpl implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; /* 过滤的规则: 在accept方法中,判断File对象是否是以.java结尾 是就返回true 不是就返回false */ //如果pathname是一个文件夹,返回true,继续遍历这个文件夹 if(pathname.isDirectory())&#123; return true; &#125; return pathname.getName().toLowerCase().endsWith(".java"); &#125;&#125; 3.3 Lambda优化代码可以用匿名内部类简化，FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Demo02Filter &#123; public static void main(String[] args) &#123; File file = new File("c:\\abc"); getAllFile(file); &#125; public static void getAllFile(File dir)&#123; //1-1 传递过滤器对象FileFilter 使用匿名内部类 /*File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; //过滤规则,pathname是文件夹或者是.java结尾的文件返回true return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java"); &#125; &#125;);*/ //1-2 使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法) /*File[] files = dir.listFiles((File pathname)-&gt;&#123; return pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java"); &#125;);*/ File[] files = dir.listFiles(pathname-&gt;pathname.isDirectory() || pathname.getName().toLowerCase().endsWith(".java")); //2-1 传递过滤器对象FilenameFilter 使用匿名内部类 /*File[] files = dir.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; //过滤规则,pathname是文件夹或者是.java结尾的文件返回true return new File(dir,name).isDirectory() || name.toLowerCase().endsWith(".java"); &#125; &#125;);*/ //2-2 使用Lambda表达式优化匿名内部类(接口中只有一个抽象方法) /*File[] files = dir.listFiles((File d, String name)-&gt;&#123; //过滤规则,pathname是文件夹或者是.java结尾的文件返回true return new File(d,name).isDirectory() || name.toLowerCase().endsWith(".java"); &#125;);*/ //File[] files = dir.listFiles((d,name)-&gt;new File(d,name).isDirectory() || name.toLowerCase().endsWith(".java")); // 循环打印 for (File f : files) &#123; if(f.isDirectory())&#123; getAllFile(f); &#125;else&#123; System.out.println(f); &#125; &#125; &#125;&#125; 第四章 字节流4.1 IO概述数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 IO的分类： 根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 4.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。int off:数组的开始索引,int len:写几个字节 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 4.3 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 写入数据的原理(内存–&gt;硬盘):java程序–&gt;JVM(java虚拟机)–&gt;OS(操作系统)–&gt;OS调用写数据的方法–&gt;把数据写入到文件中 字节输出流的使用步骤(重点): 创建一个FileOutputStream对象,构造方法中传递写入数据的目的地 调用FileOutputStream对象中的方法write,把数据写入到文件中 释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率) 构造举例，代码如下： 12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("b.txt"); &#125;&#125; 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组： public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 一次写多个字节:如果写的第一个字节是正数(0-127),那么显示的时候会查询ASCII表如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK) 123456789101112131415161718192021public class Demo02OutputStream &#123; public static void main(String[] args) throws IOException &#123; //创建FileOutputStream对象,构造方法中绑定要写入数据的目的地 FileOutputStream fos = new FileOutputStream(new File("09_IOAndProperties\\b.txt")); byte[] bytes = &#123;65,66,67,68,69&#125;;//ABCDE //byte[] bytes = &#123;-65,-66,-67,68,69&#125;;//烤紻E fos.write(bytes); /* 写入字符的方法:可以使用String类中的方法把字符串,转换为字节数组 byte[] getBytes() 把字符串转换为字节数组 */ byte[] bytes2 = "你好".getBytes(); System.out.println(Arrays.toString(bytes2));//[-28, -67, -96, -27, -91, -67] fos.write(bytes2); //释放资源 fos.close(); &#125;&#125; 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 字符串转换为字节数组 byte[] b = "abcde".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 参数:String name,File file:写入数据的目的地boolean append:追加写开关 true:创建对象不会覆盖源文件,继续在文件的末尾追加写数据 false:创建一个新文件,覆盖源文件： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"，true); // 字符串转换为字节数组 byte[] b = "abcde".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write("\r\n".getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 回车符\r和换行符\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\r\n； Unix系统里，每行结尾只有 换行 ，即\n； Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。 4.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 4.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 读取数据的原理(硬盘–&gt;内存):java程序–&gt;JVM–&gt;OS–&gt;OS读取数据的方法–&gt;读取文件 字节输入流的使用步骤(重点): 创建FileInputStream对象,构造方法中绑定要读取的数据源 使用FileInputStream对象中的方法read,读取文件 释放资源 构造举例，代码如下： 12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream("b.txt"); &#125;&#125; 读取字节数据读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1 代码使用演示： 123456789101112131415161718192021222324252627282930public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 //read.txt 内容为abcde FileInputStream fis = new FileInputStream("read.txt"); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream("read.txt"); // 定义变量，保存数据 int b ； /* 发现以上读取文件是一个重复的过程,所以可以使用循环优化 不知道文件中有多少字节,使用while循环 while循环结束条件,读取到-1的时候结束 布尔表达式(len = fis.read())!=-1 1.fis.read():读取一个字节 2.len = fis.read():把读取到的字节赋值给变量len 3.(len = fis.read())!=-1:判断变量len是否不等于-1 */ while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 明确两件事情: 方法的参数byte[]的作用?起到缓冲作用,存储每次读取到的多个字节数组的长度一把定义为1024(1kb)或者1024的整数倍 方法的返回值int是什么?每次读取的有效字节个数 注意： String类的构造方法:String(byte[] bytes) :把字节数组转换为字符串String(byte[] bytes, int offset, int length)把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo02InputStream &#123; public static void main(String[] args) throws IOException &#123; //创建FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream("09_IOAndProperties\\b.txt"); //使用FileInputStream对象中的方法read读取文件 //int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 /* byte[] bytes = new byte[2]; int len = fis.read(bytes); System.out.println(len);//2 //System.out.println(Arrays.toString(bytes));//[65, 66] System.out.println(new String(bytes));//AB len = fis.read(bytes); System.out.println(len);//2 System.out.println(new String(bytes));//CD len = fis.read(bytes); System.out.println(len);//1 System.out.println(new String(bytes));//ED len = fis.read(bytes); System.out.println(len);//-1 System.out.println(new String(bytes));//ED */ //循环优化 byte[] bytes = new byte[1024];//存储读取到的多个字节 int len = 0; //记录每次读取的有效字节个数 while((len = fis.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //释放资源 fis.close(); &#125;&#125; 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 4.6 字节流练习：图片复制复制原理图解 案例实现复制图片文件，代码使用演示： 123456789101112131415161718192021222324public class Copy &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream("D:\\test.jpg"); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream("test_copy.jpg"); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=-1) &#123; // 2.4 写出数据 fos.write(b, 0 , len); &#125; // 3.关闭资源 fos.close(); fis.close(); &#125;&#125; 小贴士： 流的关闭原则：先开后关，后开先关。 第五章 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 5.1 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 5.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader("b.txt"); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员序 获取有效的字符改进，代码使用演示： 123456789101112131415161718192021public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 5.3 字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 5.4 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter("b.txt"); &#125;&#125; 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭（或者不flush）,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 字符串转换为字节数组 char[] chars = "黑马程序员".toCharArray(); // 写出字符数组 fw.write(chars); // 黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(chars,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 字符串 String msg = "黑马程序员"; // 写出字符数组 fw.write(msg); //黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(msg,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 续写,追加写:使用两个参数的构造方法 FileWriter(String fileName, boolean append)FileWriter(File file, boolean append) 参数:String fileName,File file:写入数据的目的地boolean append:续写开关 true:不会创建新的文件覆盖源文件,可以续写; false:创建新的文件覆盖源文件 换行:换行符号windows:\r\nlinux:/nmac:/r 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter("fw.txt"，true); // 写出字符串 fw.write("黑马"); // 写出换行 fw.write("\r\n"); // 写出字符串 fw.write("程序员"); // 关闭资源 fw.close(); &#125;&#125;输出结果:黑马程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 5.5 IO异常的处理JDK7前处理之前的入门练习，我们一直使用throws把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 123456789101112131415161718192021222324252627282930public class Demo01TryCatch &#123; public static void main(String[] args) &#123; //提高变量fw的作用域,让finally可以使用 //变量在定义的时候,可以没有值,但是使用的时候必须有值 //fw = new FileWriter("09_IOAndProperties\\g.txt",true); 执行失败,fw没有值,fw.close会报错 FileWriter fw = null; try&#123; //可能会产出异常的代码 fw = new FileWriter("w:\\09_IOAndProperties\\g.txt",true); for (int i = 0; i &lt;10 ; i++) &#123; fw.write("HelloWorld"+i+"\r\n"); &#125; &#125;catch(IOException e)&#123; //异常的处理逻辑 System.out.println(e); &#125;finally &#123; //一定会执行的代码 //创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放 if(fw!=null)&#123; try &#123; //fw.close方法声明抛出了IOException异常对象,所以我们就的处理这个异常对象,要么throws,要么try catch fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; JDK7的处理(扩展知识点了解内容)还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011public class HandleException2 &#123; public static void main(String[] args) &#123; // 创建流对象 try ( FileWriter fw = new FileWriter("fw.txt"); ) &#123; // 写出数据 fw.write("黑马程序员"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK9的改进(扩展知识点了解内容)JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。 改进前格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource("resource1");// 普通对象Resource resource2 = new Resource("resource2");// 引入方式：创建新的变量保存try (Resource r1 = resource1; Resource r2 = resource2) &#123; // 使用对象&#125; 改进后格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource("resource1");// 普通对象Resource resource2 = new Resource("resource2");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 改进后，代码使用演示： 12345678910111213141516171819public class TryDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 final FileReader fr = new FileReader("in.txt"); FileWriter fw = new FileWriter("out.txt"); // 引入到try中 try (fr; fw) &#123; // 定义变量 int b; // 读取数据 while ((b = fr.read())!=-1) &#123; // 写出数据 fw.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第六章 属性集6.1 概述java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt; Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。 Properties集合是一个唯一和IO流相结合的集合 可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用 属性列表中每个键及其对应值都是一个字符串 Properties集合是一个双列集合,key和value默认都是字符串 6.2 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 12345678910111213141516171819202122232425262728293031public class ProDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty("filename", "a.txt"); properties.setProperty("length", "209385038"); properties.setProperty("location", "D:\\a.txt"); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty("filename")); System.out.println(properties.getProperty("length")); System.out.println(properties.getProperty("location")); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+" -- "+properties.getProperty(key)); &#125; &#125;&#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\a.txt&#125;a.txt209385038D:\a.txtfilename -- a.txtlength -- 209385038location -- D:\a.txt 与流相关的方法可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 void store(OutputStream out, String comments) void store(Writer writer, String comments) 参数:OutputStream out:字节输出流,不能写入中文Writer writer:字符输出流,可以写中文String comments:注释,用来解释说明保存的文件是做什么用的。(不能使用中文,会产生乱码,默认是Unicode编码，一般使用””空字符串) 使用步骤: 创建Properties集合对象,添加数据 创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 释放资源 1234567891011121314151617181920private static void show02() throws IOException &#123; //1.创建Properties集合对象,添加数据 Properties prop = new Properties(); prop.setProperty("赵丽颖","168"); prop.setProperty("迪丽热巴","165"); prop.setProperty("古力娜扎","160"); //2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 FileWriter fw = new FileWriter("09_IOAndProperties\\prop.txt"); //3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 prop.store(fw,"save data"); //4.释放资源 fw.close(); // prop.store(new FileOutputStream("09_IOAndProperties\\prop2.txt"),""); // 字节输出流会乱码 // 匿名对象不用close，使用完会自己释放&#125; 可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用 void load(InputStream inStream)void load(Reader reader) 参数:InputStream inStream:字节输入流,不能读取含有中文的键值对Reader reader:字符输入流,能读取含有中文的键值对 使用步骤: 创建Properties集合对象 使用Properties集合对象中的方法load读取保存键值对的文件 遍历Properties集合 注意: 存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号) 存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取 存储键值对的文件中,键与值默认都是字符串,不用再加引号 prop.txt 文本数据格式： 123赵丽颖=168迪丽热巴 165#古力娜扎=160 1234567891011121314151617private static void show03() throws IOException &#123; //1.创建Properties集合对象 Properties prop = new Properties(); //2.使用Properties集合对象中的方法load读取保存键值对的文件 prop.load(new FileReader("09_IOAndProperties\\prop.txt")); //prop.load(new FileInputStream("09_IOAndProperties\\prop.txt")); //乱码 //3.遍历Properties集合 Set&lt;String&gt; set = prop.stringPropertyNames(); for (String key : set) &#123; String value = prop.getProperty(key); System.out.println(key+"="+value); &#125; &#125;输出：赵丽颖=168迪丽热巴=165 第七章 缓冲流前面学习了基本的一些流，作为IO流的入门，后面介绍一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，相当于是对基本流对象的一种增强。 7.1 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 7.2 字节缓冲流字节缓冲输出流java.io.BufferedOutputStream extends OutputStream BufferedOutputStream:字节缓冲输出流 继承自父类的共性成员方法: public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 构造方法: BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 参数: OutputStream out:字节输出流我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率 int size:指定缓冲流内部缓冲区的大小,不指定默认 使用步骤(重点) 创建FileOutputStream对象,构造方法中绑定要输出的目的地 创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 释放资源(会先调用flush方法刷新数据,第4部可以省略) 123456789101112131415public class Demo01BufferedOutputStream &#123; public static void main(String[] args) throws IOException &#123; //1.创建FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream("10_IO\\a.txt"); //2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 BufferedOutputStream bos = new BufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 bos.write("我把数据写入到内部缓冲区中".getBytes()); //4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 bos.flush(); //5.释放资源(会先调用flush方法刷新数据,第4部可以省略) bos.close(); &#125;&#125; 字节缓冲输入流java.io.BufferedInputStream extends InputStream BufferedInputStream:字节缓冲输入流 继承自父类的成员方法: int read()从输入流中读取数据的下一个字节。 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 void close() 关闭此输入流并释放与该流关联的所有系统资源。 构造方法: BufferedInputStream(InputStream in)创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 参数: InputStream in:字节输入流我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率 int size:指定缓冲流内部缓冲区的大小,不指定默认 使用步骤(重点): 创建FileInputStream对象,构造方法中绑定要读取的数据源 创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 使用BufferedInputStream对象中的方法read,读取文件 释放资源 123456789101112131415161718192021222324public class Demo02BufferedInputStream &#123; public static void main(String[] args) throws IOException &#123; //1.创建FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream("10_IO\\a.txt"); //2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 BufferedInputStream bis = new BufferedInputStream(fis); //3.使用BufferedInputStream对象中的方法read,读取文件 //int read()从输入流中读取数据的下一个字节。 /*int len = 0;//记录每次读取到的字节 while((len = bis.read())!=-1)&#123; System.out.println(len); &#125;*/ //int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 byte[] bytes =new byte[1024];//存储每次读取的数据 int len = 0; //记录每次读取的有效字节个数 while((len = bis.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //4.释放资源 bis.close(); &#125;&#125; 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream("jdk9.exe"); FileOutputStream fos = new FileOutputStream("copy.exe") )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println("普通流复制时间:"+(end - start)+" 毫秒"); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe")); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println("缓冲流复制时间:"+(end - start)+" 毫秒"); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe")); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println("缓冲流使用数组复制时间:"+(end - start)+" 毫秒"); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 7.3 字符缓冲流字符缓冲输出流java.io.BufferedWriter extends Writer BufferedWriter:字符缓冲输出流 继承自父类的共性成员方法: void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 构造方法: BufferedWriter(Writer out)创建一个使用默认大小输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 参数: Writer out:字符输出流我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率 int sz:指定缓冲区的大小,不写默认大小 特有的成员方法: void newLine() 写入一个行分隔符。会根据不同的操作系统,获取不同的行分隔符 使用步骤: 创建字符缓冲输出流对象,构造方法中传递字符输出流 调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 释放资源 1234567891011121314151617public class Demo03BufferedWriter &#123; public static void main(String[] args) throws IOException &#123; //System.out.println(); //1.创建字符缓冲输出流对象,构造方法中传递字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\c.txt")); //2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 for (int i = 0; i &lt;10 ; i++) &#123; bw.write("传智播客"); //bw.write("\r\n"); bw.newLine(); &#125; //3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 bw.flush(); //4.释放资源 bw.close(); &#125;&#125; 字符缓冲输入流java.io.BufferedReader extends Reader BufferedReader:字符缓冲输入流 继承自父类的共性成员方法: int read()读取单个字符并返回。 int read(char[] cbuf)一次读取多个字符,将字符读入数组。 void close() 关闭该流并释放与之关联的所有资源。 构造方法: BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。 参数:Reader in:字符输入流我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率 特有的成员方法: String readLine() 读取一个文本行。读取一行数据行的终止符号:通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行(\r\n)。返回值：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 使用步骤: 创建字符缓冲输入流对象,构造方法中传递字符输入流 使用字符缓冲输入流对象中的方法read/readLine读取文本 释放资源 123456789101112131415public class Demo04BufferedReader &#123; public static void main(String[] args) throws IOException &#123; //1.创建字符缓冲输入流对象,构造方法中传递字符输入流 BufferedReader br = new BufferedReader(new FileReader("10_IO\\c.txt")); String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; //3.释放资源 br.close(); &#125;&#125; 7.4 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本 创建字符缓冲输入流对象,构造方法中绑定字符输入流 创建字符缓冲输出流对象,构造方法中绑定字符输出流 使用字符缓冲输入流中的方法readline,逐行读取文本 对读取到的文本进行切割,获取行中的序号和文本内容 把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..) 遍历HashMap集合,获取每一个键值对 把每一个键值对,拼接为一个文本行 把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中 释放资源 12345678910111213141516171819202122232425262728293031public class Demo05Test &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); //2.创建字符缓冲输入流对象,构造方法中绑定字符输入流 BufferedReader br = new BufferedReader(new FileReader("10_IO\\in.txt")); //3.创建字符缓冲输出流对象,构造方法中绑定字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\out.txt")); //4.使用字符缓冲输入流中的方法readline,逐行读取文本 String line; while((line = br.readLine())!=null)&#123; //5.对读取到的文本进行切割,获取行中的序号和文本内容 String[] arr = line.split("\\."); //6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..) map.put(arr[0],arr[1]); &#125; //7.遍历HashMap集合,获取每一个键值对 for(String key : map.keySet())&#123; String value = map.get(key); //8.把每一个键值对,拼接为一个文本行 line = key + "." + value; //9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中 bw.write(line); bw.newLine();//写换行 &#125; //10.释放资源 bw.close(); br.close(); &#125;&#125; 第八章 转换流8.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 编码:字符(能看懂的)–字节(看不懂的) 解码:字节(看不懂的)–&gt;字符(能看懂的) 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表:生活中文字和计算机中二进制的对应规则 字符集 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。 常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 8.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader("E:\\File_GBK.txt"); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 8.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 继承自父类的共性成员方法: int read() 读取单个字符并返回。 int read(char[] cbuf)一次读取多个字符,将字符读入数组。 void close() 关闭该流并释放与之关联的所有资源。 构造方法: InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。 InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的 InputStreamReader。 参数: InputStream in:字节输入流,用来读取文件中保存的字节 String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8 使用步骤: 创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称 使用InputStreamReader对象中的方法read读取文件 释放资源 注意事项:构造方法中指定的编码表名称要和文件的编码相同,否则会发生乱码 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK"); 指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = "E:\\file_gbk.txt"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK"); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; 8.4 OutputStreamWriter类转换流java.io.OutputStreamWriter，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 继续自父类的共性成员方法: void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 构造方法: OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。 OutputStreamWriter(OutputStream out, String charsetName)创建使用指定字符集的 OutputStreamWriter。 参数: OutputStream out:字节输出流,可以用来写转换之后的字节到文件中 String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,…不指定默认使用UTF-8 使用步骤: 创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称 使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码) 使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程) 释放资源 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream("out.txt"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK"); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = "E:\\out.txt"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write("你好"); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = "E:\\out2.txt"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK"); // 写出数据 osw2.write("你好");// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 8.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现12345678910111213141516171819202122232425public class TransDemo &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = "file_gbk.txt"; String destFile = "file_utf8.txt"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , "GBK"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125; 第九章 序列化Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 9.1 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 java.io.ObjectOutputStream extends OutputStream 构造方法: ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。 参数:OutputStream out:字节输出流 特有的成员方法: void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。 使用步骤: 创建ObjectOutputStream对象,构造方法中传递字节输出流 使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中 释放资源 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream("employee.txt");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println("Address check : " + name + " -- " + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = "zhangsan"; e.address = "beiqinglu"; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.txt")); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println("Serialized data is saved"); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved 9.2 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 java.io.ObjectInputStream extends InputStream 构造方法: ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。 参数:InputStream in:字节输入流 特有的成员方法: Object readObject()从 ObjectInputStream 读取对象。 使用步骤: 创建ObjectInputStream对象,构造方法中传递字节输入流 使用ObjectInputStream对象中的方法readObject读取保存对象的文件 释放资源 使用读取出来的对象(打印) readObject方法声明抛出了ClassNotFoundException(class文件找不到异常)，当不存在对象的class文件时抛出此异常 反序列化的前提: 类必须实现Serializable 必须存在类对应的class文件 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream("employee.txt"); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println("Employee class not found"); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println("Name: " + e.name); // zhangsan System.out.println("Address: " + e.address); // beiqinglu System.out.println("age: " + e.age); // 0 &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 类： 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println("Address check : " + name + " -- " + address); &#125;&#125; 9.3 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 定义一个存储Person对象的ArrayList集合 往ArrayList集合中存储Person对象 创建一个序列化流ObjectOutputStream对象 使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化 创建一个反序列化ObjectInputStream对象 使用ObjectInputStream对象中的方法readObject读取文件中保存的集合 把Object类型的集合转换为ArrayList类型 遍历ArrayList集合 释放资源 案例实现123456789101112131415161718192021222324252627public class Demo03Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.定义一个存储Person对象的ArrayList集合 ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); //2.往ArrayList集合中存储Person对象 list.add(new Person("张三",18)); list.add(new Person("李四",19)); list.add(new Person("王五",20)); //3.创建一个序列化流ObjectOutputStream对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("10_IO\\list.txt")); //4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化 oos.writeObject(list); //5.创建一个反序列化ObjectInputStream对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("10_IO\\list.txt")); //6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合 Object o = ois.readObject(); //7.把Object类型的集合转换为ArrayList类型 ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o; //8.遍历ArrayList集合 for (Person p : list2) &#123; System.out.println(p); &#125; //9.释放资源 ois.close(); oos.close(); &#125;&#125; 第十章 打印流平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 10.1 PrintStream类java.io.PrintStream:打印流 PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 PrintStream特点: 只负责数据的输出,不负责数据的读取 与其他输出流不同，PrintStream 永远不会抛出 IOException 有特有的方法,print,println void print(任意类型的值) void println(任意类型的值并换行) 构造方法: PrintStream(File file):输出的目的地是一个文件 PrintStream(OutputStream out):输出的目的地是一个字节输出流 PrintStream(String fileName):输出的目的地是一个文件路径 PrintStream extends OutputStream继承自父类的成员方法: public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 注意: 如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a 如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97 12345678910111213141516171819public class Demo01PrintStream &#123; public static void main(String[] args) throws FileNotFoundException &#123; //System.out.println("HelloWorld"); //创建打印流PrintStream对象,构造方法中绑定要输出的目的地 PrintStream ps = new PrintStream("10_IO\\print.txt"); //如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97-&gt;a ps.write(97); //如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97-&gt;97 ps.println(97); ps.println(8.8); ps.println('a'); ps.println("HelloWorld"); ps.println(true); //释放资源 ps.close(); &#125;&#125; print.txt文本(println会换行)： 12345a978.8aHelloWorldtrue 改变打印流向: 可以改变输出语句的目的地(打印流的流向) 输出语句,默认在控制台输出 使用System.setOut方法改变输出语句的目的地改为参数中传递的打印流的目的地 static void setOut(PrintStream out)：重新分配“标准”输出流。 1234567891011public class Demo02PrintStream &#123; public static void main(String[] args) throws FileNotFoundException &#123; System.out.println("我是在控制台输出"); PrintStream ps = new PrintStream("10_IO\\目的地是打印流.txt"); System.setOut(ps);//把输出语句的目的地改变为打印流的目的地 System.out.println("我在打印流的目的地中输出"); ps.close(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java_多线程]]></title>
    <url>%2F2019%2F09%2F04%2FJava_%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第一章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 1.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 1.2 线程与进程 进程：是指一个内存中运行的应用程序。每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 1.3 主线程主线程:执行主(main)方法的线程 单线程程序:java程序中只有一个线程，执行从main方法开始,从上到下依次执行。 JVM执行main方法，main方法会进入到栈内存，JVM会找操作系统开辟一条main方法通向cpu的执行路径，cpu就可以通过这个路径来执行main方法，而这个路径有一个名字,叫main(主)线程。 1234567891011public class Demo01MainThread &#123; public static void main(String[] args) &#123; Person p1 = new Person("小强"); p1.run(); System.out.println(0/0); //ArithmeticException: / by zero //当出现异常时，下面的代码将不再执行 Person p2 = new Person("旺财"); p2.run(); &#125;&#125; 1.4 Thread类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。 java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类 构造方法: public Thread() :分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法: public String getName() :获取当前线程名称。 public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 获取线程的名称:两种方法： 使用Thread类中的方法getName()String getName() 返回该线程的名称。 可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称static Thread currentThread() 返回对当前正在执行的线程对象的引用。 定义一个Thread类的子类 123456789101112131415161718public class MyThread extends Thread&#123; //重写Thread类中的run方法,设置线程任务 @Override public void run() &#123; //方法一获取线程名称 //String name = getName(); //System.out.println(name); //方法二 //Thread t = Thread.currentThread(); //System.out.println(t);//Thread[Thread-0,5,main] //String name = t.getName(); //System.out.println(name); //链式编程 System.out.println(Thread.currentThread().getName()); &#125;&#125; 测试类 12345678910111213141516171819/* 线程的名称: 主线程: main 新线程: Thread-0,Thread-1,Thread-2 */public class Demo01GetThreadName &#123; public static void main(String[] args) &#123; //创建Thread类的子类对象 MyThread mt = new MyThread(); //调用start方法,开启新线程,执行run方法 mt.start(); new MyThread().start(); new MyThread().start(); //链式编程（注意主方法只能用方法二，它没有继承thread类） System.out.println(Thread.currentThread().getName()); &#125;&#125; 设置线程的名称:(了解)两种方法： 使用Thread类中的方法setName(名字)void setName(String name)改变线程名称，使之与参数 name 相同。 创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字Thread(String name)分配新的 Thread 对象。 1234567891011121314public class MyThread extends Thread&#123; public MyThread()&#123;&#125; public MyThread(String name)&#123; super(name);//把线程名称传递给父类,让父类(Thread)给子线程起一个名字 &#125; @Override public void run() &#123; //获取线程的名称 System.out.println(Thread.currentThread().getName()); &#125;&#125; 1234567891011public class Demo01SetThreadName &#123; public static void main(String[] args) &#123; //开启多线程 MyThread mt = new MyThread(); mt.setName("小强"); mt.start(); //开启多线程 new MyThread("旺财").start(); &#125;&#125; sleep方法12345678910111213141516public class Demo01Sleep &#123; public static void main(String[] args) &#123; //模拟秒表 for (int i = 1; i &lt;=60 ; i++) &#123; System.out.println(i); //使用Thread类的sleep方法让程序睡眠1秒钟 //sleep方法本身有报错，处理一下 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1.5 创建线程类翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式 创建Thread类的子类创建多线程程序的第一种方式:创建Thread类的子类 实现步骤: 创建一个Thread类的子类 在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?) 创建Thread类的子类对象 调用Thread类中的方法start方法,开启新的线程,执行run方法void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行 代码如下： 测试类： 123456789101112public class Demo01Thread &#123; public static void main(String[] args) &#123; //3.创建Thread类的子类对象 MyThread mt = new MyThread(); //4.调用Thread类中的方法start方法,开启新的线程,执行run方法 mt.start(); for (int i = 0; i &lt;20 ; i++) &#123; System.out.println("main:"+i); &#125; &#125;&#125; 自定义线程类： 12345678910//1.创建一个Thread类的子类public class MyThread extends Thread&#123; //2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?) @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println("run:"+i); &#125; &#125;&#125; 执行结果是main、run交替输出。 实现Runnable接口方式创建多线程程序的第二种方式:实现Runnable接口 java.lang.RunnableRunnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。 java.lang.Thread类的构造方法Thread(Runnable target)分配新的 Thread 对象。Thread(Runnable target, String name)分配新的 Thread 对象。 实现步骤: 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法,设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象,构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法,开启新的线程执行run方法 测试类 123456789101112131415public class Demo01Runnable &#123; public static void main(String[] args) &#123; //3.创建一个Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); //4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象 Thread t = new Thread(run);//打印线程名称 //5.调用Thread类中的start方法,开启新的线程执行run方法 t.start(); for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); &#125; &#125;&#125; Runnable接口 12345678910//1.创建一个Runnable接口的实现类public class RunnableImpl implements Runnable&#123; //2.在实现类中重写Runnable接口的run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); &#125; &#125;&#125; Thread和Runnable的区别实现Runnable接口创建多线程程序的好处: 避免了单继承的局限性 一个类只能继承一个类，类继承了Thread类就不能继承其他的类 实现了Runnable接口,还可以继承其他的类,实现其他的接口 增强了程序的扩展性,降低了程序的耦合性(解耦) 实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦) 实现类中,重写了run方法:用来设置线程任务 创建Thread类对象,调用start方法:用来开启新线程 匿名内部类方式匿名内部类方式实现线程的创建 匿名:没有名字内部类:写在其他类内部的类 匿名内部类作用:简化代码 把子类继承父类,重写父类的方法,创建子类对象合一步完成 把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成 匿名内部类的最终产物:子类/实现类对象,而这个类没有名字 格式: 123new 父类/接口()&#123; 重复父类/接口中的方法&#125;; 123456789101112131415161718192021222324252627282930313233343536373839public class Demo01InnerClassThread &#123; public static void main(String[] args) &#123; //线程的父类是Thread // new MyThread().start(); new Thread()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+"黑马"); &#125; &#125; &#125;.start(); //线程的接口Runnable //Runnable r = new RunnableImpl();//多态 Runnable r = new Runnable()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+"程序员"); &#125; &#125; &#125;; new Thread(r).start(); //简化接口的方式 new Thread(new Runnable()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+"传智播客"); &#125; &#125; &#125;).start(); &#125;&#125; 第二章 线程安全2.1 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 案例： 模拟电影院的卖票过程，共有电影票100张，三个窗口同时卖这100张票 需要窗口，采用线程对象来模拟;需要票，Runnable接口子类来模拟 模拟票 1234567891011121314151617181920212223242526272829/* 实现卖票案例 */public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket = 100; //设置线程任务:卖票 @Override public void run() &#123; //使用死循环,让卖票操作重复执行 while(true)&#123; //先判断票是否存在 if(ticket&gt;0)&#123; //提高安全问题出现的概率,让程序睡眠,可以没有，多执行几次就会出现 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //票存在,卖票 ticket-- System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"); ticket--; &#125; &#125; &#125;&#125; 测试类 123456789101112131415161718/* 模拟卖票案例 创建3个线程,同时开启,对共享的票进行出售 */public class Demo01Ticket &#123; public static void main(String[] args) &#123; //创建Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); //创建Thread类对象,构造方法中传递Runnable接口的实现类对象 Thread t0 = new Thread(run); Thread t1 = new Thread(run); Thread t2 = new Thread(run); //调用start方法开启多线程 t0.start(); t1.start(); t2.start(); &#125;&#125; 出现如下问题，不存在的票和重复的票： 这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题产生的原理： 2.2 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 (synchronized)来解决。 有三种方式完成同步操作: 同步代码块 同步方法 锁机制 同步代码块同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 123synchronized(锁对象)&#123; 可能会出现线程安全问题的代码(访问了共享数据的代码)&#125; 注意: 通过代码块中的锁对象,可以使用任意的对象 但是必须保证多个线程使用的锁对象是同一个 锁对象作用:把同步代码块锁住,只让一个线程在同步代码块中执行 12345678910111213141516171819202122232425262728293031public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket = 100; //创建一个锁对象 Object obj = new Object(); //设置线程任务:卖票 @Override public void run() &#123; //使用死循环,让卖票操作重复执行 while(true)&#123; //同步代码块 synchronized (obj)&#123; //先判断票是否存在 if(ticket&gt;0)&#123; //提高安全问题出现的概率,让程序睡眠 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //票存在,卖票 ticket-- System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"); ticket--; &#125; &#125; &#125; &#125;&#125; 原理： 同步方法同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 使用步骤: 把访问了共享数据的代码抽取出来,放到一个方法中 在方法上添加synchronized修饰符 格式:定义方法的格式 123修饰符 synchronized 返回值类型 方法名(参数列表)&#123; 可能会出现线程安全问题的代码(访问了共享数据的代码)&#125; 1234567891011121314151617181920212223242526272829303132public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket = 100; //设置线程任务:卖票 @Override public void run() &#123; System.out.println("this:"+this);//this:com.itheima.demo08.Synchronized.RunnableImpl@58ceff1 //使用死循环,让卖票操作重复执行 while(true)&#123; payTicket(); &#125; &#125; public synchronized void payTicket()&#123; //先判断票是否存在 if(ticket&gt;0)&#123; //提高安全问题出现的概率,让程序睡眠 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //票存在,卖票 ticket-- System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"); ticket--; &#125; &#125;&#125; 原理： 定义一个同步方法，同步方法也会把方法内部的代码锁住，只让一个线程执行 同步方法的锁对象是谁?就是实现类对象 new RunnableImpl()，也是就是this Lock锁java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下: public void lock() :加同步锁 public void unlock() :释放同步锁 使用步骤: 在成员位置创建一个ReentrantLock对象 在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 12345678910111213141516171819202122232425262728293031323334public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket = 100; //1.在成员位置创建一个ReentrantLock对象 Lock l = new ReentrantLock(); //设置线程任务:卖票 @Override public void run() &#123; //使用死循环,让卖票操作重复执行 while(true)&#123; //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 l.lock(); //先判断票是否存在 if(ticket&gt;0)&#123; //提高安全问题出现的概率,让程序睡眠 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //票存在,卖票 ticket-- System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"); ticket--; &#125; //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 l.unlock(); &#125; &#125;&#125; 部分代码简化： 123456789101112131415161718@Overridepublic void run() &#123; while(true)&#123; l.lock(); if(ticket&gt;0)&#123; try &#123; Thread.sleep(10); System.out.println(Thread.currentThread().getName()+"--&gt;正在卖第"+ticket+"张票"); ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; l.unlock();//无论程序是否异常,都会把锁释放 &#125; &#125; &#125;&#125; 第三章 等待唤醒机制3.1 线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。java.lang.Thread.State 枚举中给出了六种线程状态 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可 运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。 Blocked(锁阻 塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态;当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限 等待) 一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时 等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。 Teminated(被 终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 Timed Waiting(计时等待)进入到TimeWaiting(计时等待)有两种方 使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态 使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态 唤醒的方法:void notify() 唤醒在此对象监视器上等待的单个线程。void notifyAll() 唤醒在此对象监视器上等待的所有线程。 BLOCKED(锁阻塞) Waiting(无限等待) 等待唤醒案例:线程之间的通信 创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待) 创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子 注意: 顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行 同步使用的锁对象必须保证唯一 只有锁对象才能调用wait和notify方法 Obejct类中的方法void wait():在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。void notify():唤醒在此对象监视器上等待的单个线程。会继续执行wait方法之后的代码void notifyAll() 唤醒在此对象监视器上等待的所有线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Demo01WaitAndNotify &#123; public static void main(String[] args) &#123; //创建锁对象,保证唯一 Object obj = new Object(); // 创建一个顾客线程(消费者) new Thread()&#123; @Override public void run() &#123; //一直等着买包子 while(true)&#123; //保证等待和唤醒的线程只能有一个执行,需要使用同步技术 synchronized (obj)&#123; System.out.println("告知老板要的包子的种类和数量"); //调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待) try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //唤醒之后执行的代码 System.out.println("包子已经做好了,开吃!"); System.out.println("---------------------------------------"); &#125; &#125; &#125; &#125;.start(); //创建一个老板线程(生产者) new Thread()&#123; @Override public void run() &#123; //一直做包子 while (true)&#123; //花了5秒做包子 try &#123; Thread.sleep(5000);//花5秒钟做包子 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //保证等待和唤醒的线程只能有一个执行,需要使用同步技术 synchronized (obj)&#123; System.out.println("老板5秒钟之后做好包子,告知顾客,可以吃包子了"); //做好包子之后,调用notify方法,唤醒顾客吃包子 obj.notify(); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 3.2 线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。 为什么要处理线程间通信： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 3.3 等待唤醒机制等待唤醒机制: 这是多个线程间的一种协作机制。就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 3.4 生产者与消费者问题等待唤醒机制其实就是经典的“生产者与消费者”的问题。 就拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 代码演示： 包子资源类： 12345678910111213141516/* 资源类:包子类 设置包子的属性 皮 陷 包子的状态: 有 true,没有 false */public class BaoZi &#123; //皮 String pi; //陷 String xian; //包子的状态: 有 true,没有 false,设置初始值为false没有包子 boolean flag = false;&#125; 吃货线程类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 消费者(吃货)类:是一个线程类,可以继承Thread 设置线程任务(run):吃包子 对包子的状态进行判断 false:没有包子 吃货调用wait方法进入等待状态 true:有包子 吃货吃包子 吃货吃完包子 修改包子的状态为false没有 吃货唤醒包子铺线程,生产包子 */public class ChiHuo extends Thread&#123; //1.需要在成员位置创建一个包子变量 private BaoZi bz; //2.使用带参数构造方法,为这个包子变量赋值 public ChiHuo(BaoZi bz) &#123; this.bz = bz; &#125; //设置线程任务(run):吃包子 @Override public void run() &#123; //使用死循环,让吃货一直吃包子 while (true)&#123; //必须同时同步技术保证两个线程只能有一个在执行 synchronized (bz)&#123; //对包子的状态进行判断 if(bz.flag==false)&#123; //吃货调用wait方法进入等待状态 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //被唤醒之后执行的代码,吃包子 System.out.println("吃货正在吃:"+bz.pi+bz.xian+"的包子"); //吃货吃完包子 //修改包子的状态为false没有 bz.flag = false; //吃货唤醒包子铺线程,生产包子 bz.notify(); System.out.println("吃货已经把:"+bz.pi+bz.xian+"的包子吃完了,包子铺开始生产包子"); System.out.println("----------------------------------------------------"); &#125; &#125; &#125;&#125; 包子铺线程类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 生产者(包子铺)类:是一个线程类,可以继承Thread 设置线程任务(run):生产包子 对包子的状态进行判断 true:有包子 包子铺调用wait方法进入等待状态 false:没有包子 包子铺生产包子 增加一些趣味性:交替生产两种包子 有两种状态(i%2==0) 包子铺生产好了包子 修改包子的状态为true有 唤醒吃货线程,让吃货线程吃包子 注意: 包子铺线程和包子线程关系--&gt;通信(互斥) 必须同时同步技术保证两个线程只能有一个在执行 锁对象必须保证唯一,可以使用包子对象作为锁对象 包子铺类和吃货的类就需要把包子对象作为参数传递进来 1.需要在成员位置创建一个包子变量 2.使用带参数构造方法,为这个包子变量赋值 */public class BaoZiPu extends Thread&#123; //1.需要在成员位置创建一个包子变量 private BaoZi bz; //2.使用带参数构造方法,为这个包子变量赋值 public BaoZiPu(BaoZi bz) &#123; this.bz = bz; &#125; //设置线程任务(run):生产包子 @Override public void run() &#123; //定义一个变量 int count = 0; //让包子铺一直生产包子 while(true)&#123; //必须同时同步技术保证两个线程只能有一个在执行 synchronized (bz)&#123; //对包子的状态进行判断 if(bz.flag==true)&#123; //包子铺调用wait方法进入等待状态 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //被唤醒之后执行,包子铺生产包子 //增加一些趣味性:交替生产两种包子 if(count%2==0)&#123; //生产 薄皮三鲜馅包子 bz.pi = "薄皮"; bz.xian = "三鲜馅"; &#125;else&#123; //生产 冰皮 牛肉大葱陷 bz.pi = "冰皮"; bz.xian = "牛肉大葱陷"; &#125; count++; System.out.println("包子铺正在生产:"+bz.pi+bz.xian+"包子"); //生产包子需要3秒钟 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //包子铺生产好了包子 //修改包子的状态为true有 bz.flag = true; //唤醒吃货线程,让吃货线程吃包子 bz.notify(); System.out.println("包子铺已经生产好了:"+bz.pi+bz.xian+"包子,吃货可以开始吃了"); &#125; &#125; &#125;&#125; 测试类： 1234567891011121314151617/* 测试类: 包含main方法,程序执行的入口,启动程序 创建包子对象; 创建包子铺线程,开启,生产包子; 创建吃货线程,开启,吃包子; */public class Demo &#123; public static void main(String[] args) &#123; //创建包子对象; BaoZi bz =new BaoZi(); //创建包子铺线程,开启,生产包子; new BaoZiPu(bz).start(); //创建吃货线程,开启,吃包子; new ChiHuo(bz).start(); &#125;&#125; 执行效果： 第四章 线程池如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 4.1 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 2.3 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中创建线程池的方法： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 参数:int nThreads创建线程池中包含的线程数量 返回值:ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程 获取到了一个线程池ExecutorService对象，使用线程池对象的方法： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 关闭/销毁线程池的方法 void shutdown() 线程池的使用步骤: 使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类,实现Runnable接口,重写run方法,设置线程任务 调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法 调用ExecutorService中的方法shutdown销毁线程池(不建议执行) Runnable实现类代码： 12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("我要一个教练"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("教练来了： " + Thread.currentThread().getName()); System.out.println("教我游泳,交完后，教练回到了游泳池"); &#125;&#125; 线程池测试类： 12345678910111213141516171819202122public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125; 第五章 Lambda表达式5.1 背景函数式编程思想概述在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 面向对象的思想:做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想:只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 冗余的Runnable代码传统写法 当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789101112public class Demo01Runnable &#123; public static void main(String[] args) &#123; // 匿名内部类 Runnable task = new Runnable() &#123; @Override public void run() &#123; // 覆盖重写抽象方法 System.out.println("多线程任务执行！"); &#125; &#125;; new Thread(task).start(); // 启动线程 &#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析 对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 编程思想转换做什么，而不是怎么做 我们并不希望创建一个匿名内部类对象吗，只是为了做这件事情而不得不创建一个对象。真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。 体验Lambda的更优写法2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性。 借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 12345public class Demo02LambdaRunnable &#123; public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println("多线程任务执行！")).start(); // 启动线程 &#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 回顾匿名内部类Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容： 1() -&gt; System.out.println("多线程任务执行！") 为了理解Lambda的语义，我们需要从传统的代码起步。 使用实现类: 要启动一个线程，需要创建一个Thread类的对象并调用start方法。而为了指定线程执行的内容，需要调用Thread类的构造方法： public Thread(Runnable target) 为了获取Runnable接口的实现对象，可以为该接口定义一个实现类RunnableImpl： 123456public class RunnableImpl implements Runnable &#123; @Override public void run() &#123; System.out.println("多线程任务执行！"); &#125;&#125; 然后创建该实现类的对象作为Thread类的构造参数： 123456public class Demo03ThreadInitParam &#123; public static void main(String[] args) &#123; Runnable task = new RunnableImpl(); new Thread(task).start(); &#125;&#125; 使用匿名内部类: 这个RunnableImpl类只是为了实现Runnable接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类： 12345678910public class Demo04ThreadNameless &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("多线程任务执行！"); &#125; &#125;).start(); &#125;&#125; 匿名内部类的好处与弊端: 一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！ 语义分析: 仔细分析该代码中的语义，Runnable接口只有一个run方法的定义： public abstract void run(); 即制定了一种做事情的方案（其实就是一个函数）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： 1() -&gt; System.out.println("多线程任务执行！") 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 5.2 Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： 1(参数类型 参数名称) -&gt; &#123; 一些重写方法的代码 &#125; 格式说明： ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔 -&gt;是新引入的语法格式，代表指向动作。 {}:重写接口的抽象方法的方法体 使用Lambda标准格式（无参无返回）题目 给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。如下： 123public interface Cook &#123; void makeFood();&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样： 123456789public class Demo05InvokeCook &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCook方法 &#125; private static void invokeCook(Cook cook) &#123; cook.makeFood(); &#125;&#125; 解答 123456789101112131415161718192021222324public class Demo01Cook &#123; public static void main(String[] args) &#123; //调用invokeCook方法,参数是Cook接口,传递Cook接口的匿名内部类对象 invokeCook(new Cook() &#123; @Override public void makeFood() &#123; System.out.println("吃饭了"); &#125; &#125;); //使用Lambda表达式,简化匿名内部类的书写 invokeCook(()-&gt;&#123; System.out.println("吃饭了"); &#125;); //优化省略Lambda invokeCook(()-&gt; System.out.println("吃饭了")); &#125; //定义一个方法,参数传递Cook接口,方法内部调用Cook接口中的方法makeFood public static void invokeCook(Cook cook)&#123; cook.makeFood(); &#125;&#125; 备注：小括号代表Cook接口makeFood抽象方法的参数为空，大括号代表makeFood的方法体。 5.3 Lambda的参数和返回值 需求: 使用数组存储多个Person对象 对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序 下面举例演示java.util.Comparator&lt;T&gt;接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： 123456public class Person &#123; private String name; private int age; // 省略构造器、toString方法与Getter Setter &#125; 传统写法如果使用传统的代码对Person[]数组进行排序，写法如下： 12345678910111213141516171819202122232425import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator &#123; public static void main(String[] args) &#123; // 本来年龄乱序的对象数组 Person[] array = &#123; new Person("古力娜扎", 19), new Person("迪丽热巴", 18), new Person("马尔扎哈", 20) &#125;; // 匿名内部类 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;; Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例 for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 代码分析: 下面我们来搞清楚上述代码真正要做什么事情。 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法123456789101112131415161718192021import java.util.Arrays;public class Demo07ComparatorLambda &#123; public static void main(String[] args) &#123; Person[] array = &#123; new Person("古力娜扎", 19), new Person("迪丽热巴", 18), new Person("马尔扎哈", 20) &#125;; Arrays.sort(array, (Person a, Person b) -&gt; &#123; return a.getAge() - b.getAge(); &#125;); //优化省略Lambda //Arrays.sort(arr,(o1, o2)-&gt;o1.getAge()-o2.getAge()); for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 练习：使用Lambda标准格式（有参有返回）题目 给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值： 123public interface Calculator &#123; int calc(int a, int b);&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算： 12345678910public class Demo08InvokeCalc &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß &#125; private static void invokeCalc(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println("结果是：" + result); &#125;&#125; 解答 12345678public static void main(String[] args) &#123; invokeCalc(120, 130, (int a, int b) -&gt; &#123; return a + b; &#125;); //优化省略Lambda //invokeCalc(120,130,(a,b)-&gt; a + b);&#125; 备注：小括号代表Calculator接口calc抽象方法的参数，大括号代表calc的方法体。 5.4 Lambda省略格式可推导即可省略: 凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： 123public static void main(String[] args) &#123; invokeCalc(120, 130, (a, b) -&gt; a + b);&#125; 省略规则: 在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号（要省略三个必须一起省略） 具体例子可以看前面的代码。 5.5 Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java_异常]]></title>
    <url>%2F2019%2F09%2F02%2FJava_%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[第一章 异常 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.1 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.2 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.3 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println("num=" + num); System.out.println("over"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throwthrow关键字 作用: 可以使用throw关键字在指定的方法中抛出指定的异常 使用格式： 1throw new 异常类名(参数); 注意: throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象,我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者是 RuntimeException的子类对象,我们可以不处理,默认交给JVM处理(打印异常对象,中断程序) throw关键字后边创建的是编译异常(写代码的时候报错),我们就必须处理这个异常,要么throws,要么try…catch throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 例如： 123throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Demo03Throw &#123; public static void main(String[] args) &#123; //int[] arr = null; int[] arr = new int[3]; int e = getElement(arr,3); System.out.println(e); &#125; /* 定义一个方法,获取数组指定索引处的元素 参数: int[] arr int index 以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验 如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题 注意: NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理 ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理 */ public static int getElement(int[] arr,int index)&#123; /* 我们可以对传递过来的参数数组,进行合法性校验 如果数组arr的值是null 那么我们就抛出空指针异常,告知方法的调用者"传递的数组的值是null" */ if(arr == null)&#123; throw new NullPointerException("传递的数组的值是null"); &#125; /* 我们可以对传递过来的参数index进行合法性校验 如果index的范围不在数组的索引范围内 那么我们就抛出数组索引越界异常,告知方法的调用者"传递的索引超出了数组的使用范围" */ if(index&lt;0 || index&gt;arr.length-1)&#123; throw new ArrayIndexOutOfBoundsException("传递的索引超出了数组的使用范围"); &#125; int ele = arr[index]; return ele; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，处理方法，一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断我们学习过一个类Objects，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 源码: 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 使用： 123456789101112131415public class Demo04Objects &#123; public static void main(String[] args) &#123; method(null); &#125; public static void method(Object obj)&#123; //对传递过来的参数进行合法性判断,判断是否为null /*if(obj == null)&#123; throw new NullPointerException("传递的对象的值是null"); &#125;*/ //Objects.requireNonNull(obj); Objects.requireNonNull(obj,"传递的对象的值是null"); &#125;&#125; 2.3 声明异常throwsthrows关键字:异常处理的第一种方式,交给别人处理 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常)(自己不处理,给别人处理),最终交给JVM处理–&gt;中断处理。 声明异常格式： 12345修饰符 返回值类型 方法名(参数列表) throws AAAExcepiton,BBBExcepiton...&#123; throw new AAAExcepiton(&quot;产生原因&quot;); throw new BBBExcepiton(&quot;产生原因&quot;); ...&#125; 注意： throws关键字必须写在方法声明处 throws关键字后边声明的异常必须是Exception或者是Exception的子类 方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常 如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可 调用了一个声明抛出异常的方法,我们就必须的处理声明的异常 要么继续使用throws声明抛出,交给方法的调用者处理,最终交给JVM 要么try…catch自己处理异常 声明异常的代码演示： 1234567891011121314151617181920212223242526272829303132333435363738public class Demo05Throws &#123; /* FileNotFoundException extends IOException extends Excepiton 如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可 */ //public static void main(String[] args) throws FileNotFoundException,IOException &#123; //public static void main(String[] args) throws IOException &#123; public static void main(String[] args) throws Exception &#123; readFile("c:\\a.tx"); System.out.println("后续代码"); &#125; /* 定义一个方法,对传递的文件路径进行合法性判断 如果路径不是"c:\\a.txt",那么我们就抛出文件找不到异常对象,告知方法的调用者 注意: FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常 可以使用throws继续声明抛出FileNotFoundException这个异常对象,让方法的调用者处理 */ public static void readFile(String fileName) throws FileNotFoundException,IOException&#123; if(!fileName.equals("c:\\a.txt"))&#123; throw new FileNotFoundException("传递的文件路径不是c:\\a.txt"); &#125; /* 如果传递的路径,不是.txt结尾 那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对 */ if(!fileName.endsWith(".txt"))&#123; throw new IOException("文件的后缀名不对"); &#125; System.out.println("路径没有问题,读取文件"); &#125;&#125; 此种方法异常后面如果有后续代码，不会继续执行了 2.4 捕获异常try…catchtry…catch:异常处理的第二种方式,自己处理异常 格式: 1234567891011try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 异常的处理逻辑,异常异常对象之后,怎么处理异常对象 一般在工作中,会把异常的信息记录到一个日志中&#125;...catch(异常类型 变量名)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意: try中可能会抛出多个异常对象,那么就可以使用多个catch来处理这些异常对象 如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try…catch之后的代码。如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try…catch之后的代码 try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read("b.txt"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println("over"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 12345678910111213141516171819202122232425262728293031323334353637public class Demo01TryCatch &#123; public static void main(String[] args) &#123; try&#123; //可能产生异常的代码 readFile("d:\\a.tx"); System.out.println("资源释放"); &#125;catch (IOException e)&#123; //System.out.println("catch - 传递的文件后缀不是.txt"); //System.out.println(e.getMessage());//文件的后缀名不对 //System.out.println(e.toString()); //重写Object类的toString java.io.IOException: 文件的后缀名不对 //System.out.println(e); //java.io.IOException: 文件的后缀名不对 /* java.io.IOException: 文件的后缀名不对 at com.itheima.demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:55) at com.itheima.demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:27) */ e.printStackTrace(); &#125; System.out.println("后续代码"); &#125; public static void readFile(String fileName) throws IOException &#123; if(!fileName.endsWith(".txt"))&#123; throw new IOException("文件的后缀名不对"); &#125; System.out.println("路径没有问题,读取文件"); &#125;&#125; 2.5 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 语法: 12345try&#123;&#125;catch()&#123;&#125;finally&#123; //自身需要处理异常,最终还得关闭资源。&#125; 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 12345678910111213141516171819202122public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read("a.txt"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println("不管程序怎样，这里都将会被执行。"); &#125; System.out.println("over"); &#125; //我们 当前的这个方法中 有异常 有编译期异常 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException("文件不存在"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 处理掉第一个异常后才会显示第二个异常 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 多个异常一次捕获一次处理，比如： 12345678910try &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]); //ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3)); //IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (Exception e)&#123; System.out.println(e); &#125; 运行时异常被抛出可以不处理。即不捕获也不声明抛出。（比如上面的例子的两个越界异常，其实可以不处理，默认给虚拟机处理，终止程序，什么时候不抛出运行时异常了，在来继续执行程序） 如果finally有return语句，永远返回finally中的结果，要避免该情况发生。 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常、或者抛出父类异常的子类异常、或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 1234567891011121314151617181920212223242526272829303132 //注意:父类异常时什么样,子类异常就什么样public class Fu &#123; public void show01() throws NullPointerException,ClassCastException&#123;&#125; public void show02() throws IndexOutOfBoundsException&#123;&#125; public void show03() throws IndexOutOfBoundsException&#123;&#125; public void show04() throws Exception &#123;&#125;&#125;class Zi extends Fu&#123; //子类重写父类方法时,抛出和父类相同的异常 public void show01() throws NullPointerException,ClassCastException&#123;&#125; //子类重写父类方法时,抛出父类异常的子类 public void show02() throws ArrayIndexOutOfBoundsException&#123;&#125; //子类重写父类方法时,不抛出异常 public void show03() &#123;&#125; /* 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。 */ //public void show04() throws Exception&#123;&#125; //此时子类产生该异常，只能捕获处理，不能声明抛出 public void show04() &#123; try &#123; throw new Exception("编译期异常"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第三章 自定义异常3.1 概述为什么需要自定义异常类: Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的，此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题等等。 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 格式: 1234public class XXXExcepiton extends Exception | RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法&#125; 注意: 自定义异常类一般都是以Exception结尾,说明该类是一个异常类 自定义异常类,必须的继承Exception或者RuntimeException 继承Exception:那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理这个异常,要么throws,要么try…catch 继承RuntimeException:那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理) 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 123456789101112131415// 业务逻辑异常public class RegisterException extends /*Exception*/ RuntimeException&#123; //添加一个空参数的构造方法 public RegisterException()&#123; super(); &#125; /* 添加一个带异常信息的构造方法 查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息 */ public RegisterException(String message)&#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 12345678910111213141516171819202122232425262728public class Demo02RegisterException &#123; // 1.使用数组保存已经注册过的用户名(数据库) static String[] usernames = &#123;"张三","李四","王五"&#125;; public static void main(String[] args) &#123; //2.使用Scanner获取用户输入的注册的用户名(前端,页面) Scanner sc = new Scanner(System.in); System.out.println("请输入您要注册的用户名:"); String username = sc.next(); checkUsername(username); &#125; //3.定义一个方法,对用户输入的中注册的用户名进行判断 public static void checkUsername(String username) &#123; //遍历存储已经注册过用户名的数组,获取每一个用户名 for (String name : usernames) &#123; //使用获取到的用户名和用户输入的用户名比较 if(name.equals(username))&#123; //true:用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册"; throw new RegisterException("亲，该用户名已经被注册");//抛出运行期异常,无需处理,交给JVM处理,中断处理 &#125; &#125; //如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!"; System.out.println("恭喜您,注册成功!"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java_List、Set、Map集合]]></title>
    <url>%2F2019%2F08%2F30%2FJava_List%E3%80%81Set%E3%80%81Map%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[第一章 数据结构1.1 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树 栈栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素） 栈的入口、出口的都是栈的顶端位置。 注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素） 队列的入口、出口各占一侧 数组数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。 链表链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 我们常说的链表结构有单向链表与双向链表 单向链表: 采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树二叉树：binary tree ,是每个结点不超过2的有序树（tree）。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 第二章 List集合Collection中的常用子类（java.util.List集合、java.util.Set集合）。 2.1 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:java.util.ArrayList类是List接口的子类，该类中的方法都是来自List中定义。 2.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 注意：操作索引时注意不要越界异常 List集合特有的方法都是跟索引相关，前面学过，此处复习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ListDemo &#123; public static void main(String[] args) &#123; // 创建List集合对象，多态 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add("图图"); list.add("小美"); list.add("不高兴"); System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,"没头脑"); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println("删除索引位置为2的元素"); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, "三毛"); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; 第三章 List的子类（实现类）3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 3.2 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。查询慢，增删快，方便元素添加、删除的集合。 LinkedList是一个双向链表 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素（等效于removeFirst） public void push(E e):将元素推入此列表所表示的堆栈。（等效于addFirst） public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里不做详细介绍，了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Demo02LinkedList &#123; public static void main(String[] args) &#123; show03(); &#125; private static void show03() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add("a"); linked.add("b"); linked.add("c"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println("被移除的第一个元素:"+first); String last = linked.removeLast(); System.out.println("被移除的最后一个元素:"+last); System.out.println(linked);//[b] &#125; private static void show02() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add("a"); linked.add("b"); linked.add("c"); //linked.clear();//清空集合中的元素 在获取集合中的元素会抛出NoSuchElementException //public boolean isEmpty()：如果列表不包含元素，则返回true。 if(!linked.isEmpty())&#123; String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c &#125; &#125; private static void show01() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add("a"); linked.add("b"); linked.add("c"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst("www"); linked.push("www"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast("com"); System.out.println(linked);//[www, a, b, c, com] &#125;&#125; 第四章 Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，和Collection一样没有索引，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。 与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips:Set集合取出元素的方式可以采用：迭代器、增强for。 4.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类 存储的元素是不可重复的 元素都是无序的(即存取顺序不一致)。 java.util.HashSet底层的实现其实是一个java.util.HashMap支持 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 1234567891011121314151617181920212223public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String("cba")); set.add("abc"); set.add("bac"); set.add("cba"); //使用迭代器遍历set集合 Iterator&lt;Integer&gt; it = set.iterator(); while (it.hasNext())&#123; Integer n = it.next(); System.out.println(n); &#125; //使用增强for遍历set集 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素，且无序： 123cbaabcbac 4.2 HashSet集合存储数据的结构（哈希表）哈希值哈希值是一个十进制的整数,由系统随机给出(就是对象的地址值,是一个逻辑地址,是模拟出来得到地址,不是数据实际存储的物理地址) 在Object类有一个方法,可以获取对象的哈希值： int hashCode() 返回该对象的哈希码值。 hashCode方法的源码:public native int hashCode();native:代表该方法调用的是本地操作系统的方法 1234567891011121314151617181920212223242526272829303132public class Demo01HashCode &#123; public static void main(String[] args) &#123; //Person类继承了Object类,所以可以使用Object类的hashCode方法 Person p1 = new Person(); int h1 = p1.hashCode(); System.out.println(h1);//1967205423 （十进制） Person p2 = new Person(); int h2 = p2.hashCode(); System.out.println(h2);//42121758 /* toString方法的源码: return getClass().getName() + "@" + Integer.toHexString(hashCode()); */ System.out.println(p1);//com.itheima.demo03.hashCode.Person@75412c2f（十六进制） System.out.println(p2);//com.itheima.demo03.hashCode.Person@282ba1e System.out.println(p1==p2);//false /* String类的哈希值 String类重写Obejct类的hashCode方法 */ String s1 = new String("abc"); String s2 = new String("abc"); System.out.println(s1.hashCode());//96354 System.out.println(s2.hashCode());//96354（字符串相同，纸相同） System.out.println("重地".hashCode());//1179395 System.out.println("通话".hashCode());//1179395（这两个是巧合） &#125;&#125; 哈希表在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。 而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如图所示 结合一个存储流程图理解： Set集合存储元素不重复的原理: JDK1.8引入红黑树大程度优化了HashMap的性能 保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法决定。如果我们往集合中存放自定义的对象，那么为保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 4.3 HashSet存储自定义类型元素给HashSet中存放String、Integer等Java定义好的类时，这些类的特点是它们都重写了hashCode和equals方法，以保证元素不重复。 给HashSet中存放自定义类型元素时，需要重写自定义类中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。否则创建的自定义类型元素，即使元素内容是一样的，它们的hashcode和地址值其实也是不一样的。 创建自定义Student类要求:同名同年龄的人,视为同一个人,只能存储一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; tips:重写IDEA快捷键可以自动生成 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student("于谦", 43); stuSet.add(stu); stuSet.add(new Student("郭德纲", 44)); stuSet.add(new Student("于谦", 43)); stuSet.add(new Student("郭麒麟", 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] 4.4 LinkedHashSetHashSet保证元素唯一，但元素存放进去是没有顺序 在HashSet下面有一个子类java.util.LinkedHashSet，底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add("bbb"); set.add("aaa"); set.add("abc"); set.add("bbc"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 结果有序 4.5 可变参数使用前提:当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数。 使用格式: 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 可变参数的原理:可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数传递的参数个数,可以是0个(不传递),1,2…多个 代码演示： 1234567891011121314151617181920212223242526272829303132public class ChangeArgs &#123; public static void main(String[] args) &#123; // int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; // int sum = getSum(arr); // System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; /* * 完成数组 所有元素的求和 原始写法 public static int getSum(int[] arr)&#123; int sum = 0; for(int a : arr)&#123; sum += a; &#125; return sum; &#125; */ //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; 注意事项： 一个方法的参数列表,只能有一个可变参数 如果方法的参数有多个,那么可变参数必须写在参数列表的末尾 可变参数的特殊(终极)写法 1public static void method(Object...obj)&#123;&#125; 第五章 Collections5.1 常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加多个元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 addall、sort（默认）代码演示： 12345678910111213141516171819public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222] 5.2 Comparable接口public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序 当list中只是数字或者简单的字母字符串时，直接sort即可，就像上面的代码，但当list存储当不是integer、string等类型，比如存储的是自己定义的Person类时，默认排序规则将不管用，会编译报错。 此时仍使用sort(List&lt;T&gt; list)则需要：被排序的集合里边存储的元素,必须实现Comparable,重写接口中的方法compareTo定义排序的规则 Comparable接口的排序规则: 自己(this) - 参数 —&gt; 升序 参数 - 自己(this) —&gt; 降序 main代码： 1234567891011121314151617181920212223242526272829303132public class Demo02Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] //public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 Collections.sort(list01);//默认是升序 System.out.println(list01);//[1, 2, 3] ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;(); list02.add("a"); list02.add("c"); list02.add("b"); System.out.println(list02);//[a, c, b] Collections.sort(list02); System.out.println(list02);//[a, b, c] ArrayList&lt;Person&gt; list03 = new ArrayList&lt;&gt;(); list03.add(new Person("张三",18)); list03.add(new Person("李四",20)); list03.add(new Person("王五",15)); System.out.println(list03);//[Person&#123;name='张三', age=18&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=15&#125;] Collections.sort(list03); System.out.println(list03);//[Person&#123;name='李四', age=20&#125;, Person&#123;name='张三', age=18&#125;, Person&#123;name='王五', age=15&#125;] &#125;&#125; Person类 1234567891011121314151617181920212223public class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; //getter、setter、构造方法省略 @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; //重写排序的规则 @Override public int compareTo(Person o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 return o.getAge() - this.getAge();//年龄降序排序 &#125;&#125; 5.3 Comparator比较器public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序 public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序：o1-o2则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序：o2-o1则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） Comparator和Comparable的区别: Comparable:自己(this)和别人(参数)比较,自己需要实现Comparable接口,重写比较的规则compareTo方法 Comparator:相当于找一个第三方的裁判,比较两个 Comparator的排序规则:&emsp;&emsp;&emsp;&emsp;o1-o2:升序 main代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Demo03Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125; &#125;); System.out.println(list01);//[3, 2, 1] ArrayList&lt;Student&gt; list02 = new ArrayList&lt;&gt;(); list02.add(new Student("迪丽热巴",18)); list02.add(new Student("古力娜扎",20)); list02.add(new Student("杨幂",17)); System.out.println(list02);//[Student&#123;name='迪丽热巴', age=18&#125;, Student&#123;name='古力娜扎', age=20&#125;, Student&#123;name='杨幂', age=17&#125;] Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 return o1.getAge()-o2.getAge(); &#125; &#125;); System.out.println(list02);//[Student&#123;name='杨幂', age=17&#125;, Student&#123;name='迪丽热巴', age=18&#125;, Student&#123;name='古力娜扎', age=20&#125;] //扩展:了解 //复合判断排序 ArrayList&lt;Student&gt; list03 = new ArrayList&lt;&gt;(); list02.add(new Student("a迪丽热巴",18)); list02.add(new Student("古力娜扎",20)); list02.add(new Student("杨幂",17)); list02.add(new Student("b杨幂",18)); System.out.println(list03);//[Student&#123;name='a迪丽热巴', age=18&#125;, Student&#123;name='古力娜扎', age=20&#125;, Student&#123;name='杨幂', age=17&#125;, Student&#123;name='b杨幂', age=18&#125;] Collections.sort(list03, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); System.out.println(list03);//[Student&#123;name='杨幂', age=17&#125;, Student&#123;name='a迪丽热巴', age=18&#125;, Student&#123;name='b杨幂', age=18&#125;, Student&#123;name='古力娜扎', age=20&#125;] &#125;&#125; Student类： 12345678910111213public class Student &#123; private String name; private int age; //getter、setter、构造方法省略 @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; 5.4 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 第六章 Map集合现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 Map接口下的集合与Collection接口下的集合，存储数据的形式不同，如图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 6.1 Map常用子类Map有多个子类，常用的有HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 6.2 Map常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map接口的方法演示 1234567891011121314151617181920public class MapDemo &#123; public static void main(String[] args) &#123; //创建 map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素到集合 map.put("黄晓明", "杨颖"); map.put("文章", "马伊琍"); map.put("邓超", "孙俪"); System.out.println(map);//&#123;邓超=孙俪, 文章=马伊琍, 黄晓明=杨颖&#125; //String remove(String key) System.out.println(map.remove("邓超"));//孙俪 System.out.println(map);//&#123;文章=马伊琍, 黄晓明=杨颖&#125; // 想要查看 黄晓明的媳妇 是谁 System.out.println(map.get("黄晓明"));//杨颖 System.out.println(map.get("邓超")); //null &#125;&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 6.3 遍历键找值键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： 1234567891011121314151617181920public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //添加元素到集合 map.put("胡歌", "霍建华"); map.put("郭德纲", "于谦"); map.put("薛之谦", "大张伟"); //获取所有的键 获取键集 Set&lt;String&gt; keys = map.keySet(); // 遍历键集 得到 每一个键 for (String key : keys) &#123; //key 就是键 //获取对应值 String value = map.get(key); System.out.println(key+"的CP是："+value); &#125; &#125;&#125; 遍历图解： 6.4 Entry键值对对象我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。 Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 6.5 遍历键值对键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718192021public class MapDemo02 &#123; public static void main(String[] args) &#123; // 创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); // 添加元素到集合 map.put("胡歌", "霍建华"); map.put("郭德纲", "于谦"); map.put("薛之谦", "大张伟"); // 获取 所有的 entry对象 entrySet Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); // 遍历得到每一个entry对象 for (Entry&lt;String, String&gt; entry : entrySet) &#123; // 解析 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"的CP是:"+value); &#125; &#125;&#125; 遍历图解： tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 6.6 HashMap存储自定义类型键值练习：每位学生（姓名，年龄）都有自己的家庭住址。将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。(学生姓名相同并且年龄相同视为同一名学生) 编写学生类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 编写测试类： 12345678910111213141516171819public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(newStudent("lisi",28), "上海"); map.put(newStudent("wangwu",22), "北京"); map.put(newStudent("zhaoliu",24), "成都"); map.put(newStudent("zhouqi",25), "广州"); map.put(newStudent("wangwu",22), "南京"); //3,取出元素。键找值方式 Set&lt;Student&gt; keySet = map.keySet(); for(Student key: keySet)&#123; Stringvalue = map.get(key); System.out.println(key.toString()+"....."+value); &#125; &#125;&#125; 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须重写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 6.7 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 123456789101112public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put("邓超", "孙俪"); map.put("李晨", "范冰冰"); map.put("刘德华", "朱丽倩"); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + " " + entry.getValue()); &#125; &#125;&#125; 结果: 123邓超 孙俪李晨 范冰冰刘德华 朱丽倩 6.8 Map集合练习需求： 计算一个字符串中每个字符出现次数。 分析： 使用Scanner获取用户输入的字符串 创建Map集合,key是字符串中的字符,value是字符的个数 遍历字符串,获取每一个字符 使用获取到的字符,去Map集合判断key是否存在&emsp;&emsp;key存在:&emsp;&emsp;&emsp;&emsp;通过字符(key),获取value(字符个数)&emsp;&emsp;&emsp;&emsp;value++&emsp;&emsp;&emsp;&emsp;put(key,value)把新的value存储到Map集合中&emsp;&emsp;key不存在:&emsp;&emsp;&emsp;&emsp;put(key,1) 遍历Map集合,输出结果 代码： 123456789101112131415161718192021222324252627282930313233public class Demo03MapTest &#123; public static void main(String[] args) &#123; //1.使用Scanner获取用户输入的字符串 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串:"); String str = sc.next(); //2.创建Map集合,key是字符串中的字符,value是字符的个数 HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); //3.遍历字符串,获取每一个字符 for(char c :str.toCharArray())&#123; //4.使用获取到的字符,去Map集合判断key是否存在 if(map.containsKey(c))&#123; //key存在 Integer value = map.get(c); value++; map.put(c,value); &#125;else&#123; //key不存在 map.put(c,1); &#125; &#125; //5.遍历Map集合,输出结果 for(Character key :map.keySet())&#123; Integer value = map.get(key); System.out.println(key+"="+value); &#125; &#125;&#125; 第七章 List、Set、Map综合7.1 JDK9对集合添加的优化通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。 123456789public class Demo01 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("abc"); list.add("def"); list.add("ghi"); System.out.println(list); &#125;&#125; Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。 例子： 1234567891011public class HelloJDK9 &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str1=Set.of("a","b","c"); //str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 System.out.println(str1); Map&lt;String,Integer&gt; str2=Map.of("a",1,"b",2); System.out.println(str2); List&lt;String&gt; str3=List.of("a","b"); System.out.println(str3); &#125; &#125; 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如HashSet，ArrayList等； 2:返回的集合是不可变的； 7.2 模拟斗地主洗牌发牌案例介绍按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 实现代码步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Poker &#123; public static void main(String[] args) &#123; /* * 1组装54张扑克牌 */ // 1.1 创建Map集合存储 HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;(); // 1.2 创建 花色集合 与 数字集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); // 1.3 存储 花色 与数字 Collections.addAll(colors, "♦", "♣", "♥", "♠"); Collections.addAll(numbers, "2", "A", "K", "Q", "J", "10", "9", "8", "7", "6", "5", "4", "3"); // 设置 存储编号变量 int count = 1; pokerMap.put(count++, "大王"); pokerMap.put(count++, "小王"); // 1.4 创建牌 存储到map集合中 for (String number : numbers) &#123; for (String color : colors) &#123; String card = color + number; pokerMap.put(count++, card); &#125; &#125; /* * 2 将54张牌顺序打乱 */ // 取出编号 到Set集合 Set&lt;Integer&gt; numberSet = pokerMap.keySet(); // set无序、list有序 // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中 ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;(); numberList.addAll(numberSet); // 打乱顺序 Collections.shuffle(numberList); // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌 // 3.1 发牌的编号 // 创建三个玩家编号集合 和一个 底牌编号集合 ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;(); // 3.2发牌的编号 for (int i = 0; i &lt; numberList.size(); i++) &#123; // 获取该编号 Integer no = numberList.get(i); // 发牌 // 留出底牌 if (i &gt;= 51) &#123; dipaiNo.add(no); &#125; else &#123; if (i % 3 == 0) &#123; noP1.add(no); &#125; else if (i % 3 == 1) &#123; noP2.add(no); &#125; else &#123; noP3.add(no); &#125; &#125; &#125; // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌 // 4.1 对手中编号进行排序 Collections.sort(noP1); Collections.sort(noP2); Collections.sort(noP3); Collections.sort(dipaiNo); // 4.2 进行牌面的转换 // 创建三个玩家牌面集合 以及底牌牌面集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); // 4.3转换 for (Integer i : noP1) &#123; // 4.4 根据编号找到 牌面 pokerMap String card = pokerMap.get(i); // 添加到对应的 牌面集合中 player1.add(card); &#125; for (Integer i : noP2) &#123; String card = pokerMap.get(i); player2.add(card); &#125; for (Integer i : noP3) &#123; String card = pokerMap.get(i); player3.add(card); &#125; for (Integer i : dipaiNo) &#123; String card = pokerMap.get(i); dipai.add(card); &#125; //4.5 查看 System.out.println("令狐冲："+player1); System.out.println("石破天："+player2); System.out.println("鸠摩智："+player3); System.out.println("底牌："+dipai); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_Collection集合、泛型]]></title>
    <url>%2F2019%2F08%2F29%2FJava_Collection%E9%9B%86%E5%90%88%E3%80%81%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[第一章 Collection集合前面使用过集合ArrayList 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组都是容器，它们的区别： 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map 1.1 集合框架Collection： 单列集合类的根接口，用于存储一系列符合某种规则的元素。它有两个重要的子接口，分别是java.util.List和java.util.Set。 List的特点是元素有序、元素可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList。 Set的特点是元素无序，而且不可重复。Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.2 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式，接口指向实现类 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); //打印coll为[]，重写了toString方法 // 使用方法 // 添加功能 boolean add(String s) coll.add("小李广"); coll.add("扫地僧"); coll.add("石破天"); //无需接受返回值，返回值一般为true System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 扫地僧 是否在集合中"+coll.contains("扫地僧")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除石破天："+coll.remove("石破天")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。 Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 迭代： 即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 获取迭代器： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 Iterator接口的常用方法： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 迭代器的使用步骤(重点): 使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 使用Iterator接口中的方法hasNext判断还有没有下一个元素 使用Iterator接口中的方法next取出集合中的下一个元素 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("串串星人"); coll.add("吐槽星人"); coll.add("汪星人"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 迭代器的实现原理 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.2 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("小河神"); coll.add("老河神"); coll.add("神婆"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述集合中可以存放任意对象，只要把对象存储集合后，他们都会被提升成Object类型。当我们取出每一个对象，并且进行相应的操作时，必须采用类型转换。 创建集合对象,不使用泛型 好处:集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据 弊端:不安全,会引发异常 12345678910111213141516171819202122 private static void show01() &#123; ArrayList list = new ArrayList(); list.add("abc"); list.add(1); //使用迭代器遍历list集合 //获取迭代器 Iterator it = list.iterator(); //使用迭代器中的方法hasNext和next遍历集合 while(it.hasNext())&#123; //取出元素也是Object类型 Object obj = it.next(); System.out.println(obj); //想要使用String类特有的方法,length获取字符串的长度;不能使用 多态 Object obj = "abc"; //需要向下转型 //会抛出ClassCastException类型转换异常,不能把Integer类型转换为String类型 String s = (String)obj; System.out.println(s.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时ClassCastException。Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处 创建集合对象,使用泛型 好处: 1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端:泛型是什么类型,只能存储什么类型的数 1234567891011121314151617public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用在集合中会大量使用到泛型 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型的数据类型 在创建对象的时候确定泛型的数据类型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 自定义泛型类： 定义： 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP("大胡子登登"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 1234567891011public class GenericMethod &#123; //定义一个含有泛型的方法 public &lt;M&gt; void method01(M m)&#123; System.out.println(m); &#125; //定义一个含有泛型的静态方法 public static &lt;S&gt; void method02(S s)&#123; System.out.println(s); &#125;&#125; 使用格式：调用方法时，确定泛型的类型 123456789101112131415161718192021public class Demo03GenericMethod &#123; public static void main(String[] args) &#123; //创建GenericMethod对象 GenericMethod gm = new GenericMethod(); /* 调用含有泛型的方法method01 传递什么类型,泛型就是什么类型 */ gm.method01(10); gm.method01("abc"); gm.method01(8.8); gm.method01(true); gm.method02("静态方法,不建议创建对象使用"); //静态方法,通过类名.方法名(参数)可以直接使用 GenericMethod.method02("静态方法"); GenericMethod.method02(1); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 定义类时确定泛型的类型 定义接口的实现类,实现接口,指定接口的泛型 实现类： 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型，然后main程序按照string正常使用。 始终不确定泛型的类型，直到创建对象时，确定泛型的类型 接口使用什么泛型,实现类就使用什么泛型,类跟着接口走就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型 实现类： 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; main，创建对象，确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add("aa"); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符：不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举例理解使用即可： 1234567891011121314151617public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list1); getElement(list2);&#125;public static void getElement((ArrayList&lt;?&gt; list)&#123; //使用迭代器遍历集合 Iterator&lt;?&gt; it = list.iterator(); while(it.hasNext())&#123; //it.next()方法,取出的元素是Object,可以接收任意的数据类型 Object o = it.next(); System.out.println(o); &#125;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类其中类与类之间的继承关系:Integer extends Number extends ObjectString extends Objec 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itheima.demo04.Test;import java.util.ArrayList;import java.util.Collections;/* 斗地主综合案例: 1.准备牌 2.洗牌 3.发牌 4.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //定义一个存储54张牌的ArrayList集合,泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号 String[] colors = &#123;"♠","♥","♣","♦"&#125;; String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //先把大王和小王存储到poker集合中 poker.add("大王"); poker.add("小王"); //循环嵌套遍历两个数组,组装52张牌 for(String number : numbers)&#123; for (String color : colors) &#123; //System.out.println(color+number); //把组装好的牌存储到poker集合中 poker.add(color+number); &#125; &#125; //System.out.println(poker); /* 2.洗牌 使用集合的工具类Collections中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。 */ Collections.shuffle(poker); //System.out.println(poker); /* 3.发牌 */ //定义4个集合,存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; diPai = new ArrayList&lt;&gt;(); /* 遍历poker集合,获取每一张牌 使用poker集合的索引%3给3个玩家轮流发牌 剩余3张牌给底牌 注意: 先判断底牌(i&gt;=51),否则牌就发没了 */ for (int i = 0; i &lt; poker.size() ; i++) &#123; //获取每一张牌 String p = poker.get(i); //轮流发牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(p); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(p); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(p); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(p); &#125; &#125; //4.看牌 System.out.println("刘德华:"+player01); System.out.println("周润发:"+player02); System.out.println("周星驰:"+player03); System.out.println("底牌:"+diPai); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_Object类、常用API]]></title>
    <url>%2F2019%2F08%2F27%2FJava_Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[第一章 Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类,那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。 1.1 toString方法 public String toString()：返回该对象的字符串表示： 类型+@+内存地址值 。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键^+N，点击toString()选项。选择需要包含的成员变量并确定。 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.2 equals方法 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 equals方法源码: 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 参数: Object obj:可以传递任意的对象 == 比较运算符,返回的是一个布尔值 true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 12345678910public static void main(String[] args) &#123; Person p1 = new Person("迪丽热巴",18); Person p2 = new Person("古力娜扎",19); System.out.println("p1:"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println("p2:"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 boolean b = p1.equals(p1); System.out.println(b); &#125; 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。 问题:隐含着一个多态多态的弊端:无法使用子类特有的内容(属性和方法)Object obj = p2 = new Person(“古力娜扎”,19);解决:可以使用向下转型(强转)把obj类型转换为Person IDEA中，可以快捷键^ + N，并选择equals() and hashCode()进行自动代码生成。 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; tips：Object类当中的hashCode等其他方法，今后学习。 1.3 Objects类在IDEA自动重写equals代码中，使用到了java.util.Objects类 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成 这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的） 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 源码： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 第二章 日期时间类2.1 Date类 java.util.Date类 表示特定的瞬间，精确到毫秒 毫秒:千分之一秒 1000毫秒=1秒 特定的瞬间:一个时间点,一刹那时间2088-08-08 09:55:33:333 瞬间 毫秒值的作用:&emsp;可以对时间和日期进行计算 2099-01-03 到 2088-01-01 中间一共有多少天可以日期转换为毫秒进行计算,计算完毕,在把毫秒转换为日期 把日期转换为毫秒: 当前的日期:2088-01-01 时间原点(0毫秒):1970 年 1 月 1 日 00:00:00(英国格林威治) 就是计算当前日期到时间原点之间一共经历了多少毫秒 123public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis());//获取当前系统时间到1970 年 1 月 1 日 00:00:00经历了多少毫秒&#125; 注意:中国属于东八区,会把时间增加8个小时–1970 年 1 月 1 日 08:00:00 把毫秒转换为日期: 1 天 = 24 × 60 × 60 = 86400 秒 = 86400 x 1000 = 86400000毫秒 构造方法 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910111213141516import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; /* Date类的空参数构造方法 Date() 获取当前系统的日期和时间 */ System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 /* Date类的带参数构造方法 Date(long date) :传递毫秒值,把毫秒值转换为Date日期 */ System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用成员方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值相当于System.currentTimeMillis()方法 12345private static void demo03() &#123; Date date = new Date(); long time = date.getTime(); System.out.println(time);//3742777636267&#125; 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法DateFormat为抽象类，不能直接使用，需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //字母不能改变，连接符号可以改变 &#125; &#125; 常用成员方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = "2018年12月11日"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 使用Scanner类中的方法next,获取出生日期 使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 把Date格式的出生日期转换为毫秒值 获取当前的日期,转换为毫秒值 使用当前日期的毫秒值-出生日期的毫秒值 把毫秒差值转换为天(s/1000/60/60/24) 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 2.4 Calendar类java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。 日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用成员方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH / DATE 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + "年" + month + "月" + dayOfMonth + "日");//2019年7月14日 &#125; &#125; 12345678910111213import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); //年月日的输出int设置省略了 System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2020年1月17日 //同时设置年月日,可以使用set的重载方法 cal.set(8888,8,8); &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 12345678910111213import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 日历转换为日期 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println("共耗时毫秒：" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = "Hello"; s += "World"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWorld 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容，可以提高字符串的效率。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器，其初始容量为 16 个字符。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder("itcast"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 1234567891011121314151617181920212223242526public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append("hello"); //对比一下 System.out.println("builder:"+builder);//hello System.out.println("builder2:"+builder2);//hello System.out.println(builder == builder2); //true，地址相同 // 可以添加 任何类型 // 使用append方法无需接收返回值 builder.append("hello"); builder.append("world"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append("hello").append("world").append(true).append(100); System.out.println("builder:"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder("Hello").append("World").append("Java"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类（本部分前面提到过）Java提供了两个类型系统，基本类型与引用类型。 使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能。 如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.1 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.2 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式 基本类型直接与””相连接即可；如：34+””(简单常用) 包装类的静态方法toString(参数),不是Object类的toString() 重载static String toString(int i) 返回一个表示指定整数的 String 对象。 String类的静态方法valueOf(参数)static String valueOf(int i) 返回 int 参数的字符串表示形式 123456789int i1 = 100;String s1 = i1+"";System.out.println(s1+200);//100200String s2 = Integer.toString(100);System.out.println(s2+200);//100200String s3 = String.valueOf(100);System.out.println(s3+200);//10020 String转换成对应的基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：short基本类型。 public static int parseInt(String s)：int基本类型。 public static long parseLong(String s)：long基本类型。 public static float parseFloat(String s)：float基本类型。 public static double parseDouble(String s)：double基本类型。 public static boolean parseBoolean(String s)：boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt("100"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>常用API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim基本命令]]></title>
    <url>%2F2019%2F08%2F25%2FVim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vim命令 代码操作 命令 作用 yy 复制 光标所在的这一行 4yy 复制 光标所在的行开始向下的4行 p 粘贴 dd 剪切 光标所在行 4dd 向下4行 D 从光标开始剪切，一直到行末 d0 从光标开始剪切，一直到行首 dw 删除这个单词 x 删除当前光标，每次只删除一个 X 删除当前光标前面的那个，每次只删除一个 u 撤销刚刚操作(可多次） ctrl+r 反撤销 . 重复执行上一次命令 定位操作 命令 作用 h，j，k，l 命令下的光标 左，下，上，右 H，M，L 当前屏幕的 上方，中间，下方 ctrl+f 向下翻一页代码 ctrl+b 向上翻一页代码 20G 快速定位到第20行代码 G 快速回到整个代码的最后一行 gg 快速回到整个代码的第一行 w 向后跳一个单词的长度，即下一个单词的开始 b 向前 移动替换 命令 作用 { 按段移动，上移 } 按段移动，下移 v 选中（配合上下左右可以选中一片）光标在哪选到哪 V 选中，光标所在行都选中 &gt; 整体向右移动代码 &lt; 向左 r 替换当前字符(输入r后输入替换后的字符） R 替换当前行光标后的字符 查找替换、保存退出 命令 作用 / 查找（搜不存在的可去掉颜色） n下一个搜索到的 N上一个 %s///g(：末行模式下） /被替换/替换/ 11,16s///g 替换11到16行 vim 4.py vim下 创建or进入4.py vi (似乎更方便，再次进入的时候） ：w （末行模式） 保存 ：q 直接退出（没保存的话会提示） ：q！ 不保存退出 ：wq或者x 保存并退出 shift+zz 相当于末行模式的wq ctrl+N查看已经定义的变量]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux以及命令.md]]></title>
    <url>%2F2019%2F08%2F25%2FLinux%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux操作系统命令： 命令 作用 command + 调大字体 - 调小 ls 当前路径下所有文件夹和名字 pwd 目前处在的路径，第一个/为根目录 cd 切换路径 clear 清屏 命令基本格式:命令 选项 参数选项的格式为:-选项 命令 作用 ls -a 创建的文件的名字以.开头，则为隐藏文件，ls命令看不见。此时运行ls -a，则能看见 ls -l 以列表方式显示 ls -l -h 显示列表的时候会给数字显示一个合适的单位 可以ls -a -l -h一起使用，顺序无所谓，ls -alh 查看帮助文档 命令 作用 命令 –help man 命令 （进入后不能输入命令，按q退出，f向下翻一屏，b向上） man 2 命令 查看c语言下的帮助文档 history 查看历史命令 对文件（夹）的操作 命令 作用 tab键 文件名补全 touch 新建文件 mkdir 创建文件夹 rmdir 删除文件夹（非空删除不了） open 打开并编辑文件 cat 查看文件 cat 123.txt 234.txt 会同时显示两个文件的内容 cat 123.txt 234.txt &gt; xxx.txt 合并两个文件的内容到一个文件xxx.txt more 查看文件（适合大文件，不会全显示出来，显示一页，按f键翻页，q退出) 可以结合ls命令：ls -ahl /bin ` rm 删除命令 可以删除非空文件夹：rm -r 文件夹名。不想一直询问，直接删除-rf mv 123.txt 789.txt 重命名，原文件名 新文件名 mv 789.txt A 剪切文件到A文件夹 cp 复制粘贴 不让copy文件夹，加-r，遇到文件夹不让动的，多数可以加-r解决（-r：递归） 文件中查找操作 命令 作用 grep “s” xxx.txt 在xxx.txt中查找s grep -n “s” xxx.txt 搜索显示前面会带有在哪一行 grep -n “s” xxx.txt 查找不包含s的 grep “^s” xxx.txt 查找以s开头的 grep “s$” xxx.txt 查找以s结尾的 通配符 命令 作用 ls 2* 只查看以2开头的文件 ls *.txt 只查看.txt文件 *代表的位数可以为0到n位（不只可以与ls合用，与rm等也可以一起） ls 2？ 查看以2开头且只有两位 几个？则几位 ls 2？3 .txt ls 2[12345]3.txt 查看213到253之间到文件（可以写成1-5） 重定向 命令 作用 ls -ahl &gt; xxx.txt 创建了xxx.txt文件，并且把命令ls -ahl应该显示的内容存放进去 &gt;&gt; 追加，会在原来的末尾把当前内容追加进去 如果只&gt;，会把原来的删除。如果原来没有这个文件，&gt;&gt;也会创建文件。 路径 相对路径 从当前路径算起 绝对路径 从根目录算起 cd时不知道下一层文件夹名字，可以按两次tab键，会把能补全的文件夹名字全显示出来 cd A 跳转到（当前路径的）A文件夹 cd ./A 跳转到当前路径的A文件夹 cd .. 跳转到上一层文件夹 cd ../.. 上上层 跳转文件距离根目录近，用绝对路径，距离当前文件近，用相对路径。 cd - 跳转到上一次操作所在路径（最多只能记忆一次，再次使用就跳回来了） cd ~ 回到家目录 链接 命令 作用 ln -s 789.txt 789-softlink.txt 创建软链接文件（快捷方式） 原文件删除，软链接文件没有用了 ln 789.txt 789-hardlink.txt 创建硬链接文件（快捷方式） 硬链接文件相当于给原文件重新起名，原文件删除，硬链接文件数据仍然在。 如果写完一行命令不想执行，按control+C，则直接换行。 文件查找操作 命令 作用 find 在一个路径里找东西 find / -name “” 在根目录里按名字找，名字里带双引号里的 如果有没有权限的，在find前加sudo find ./ 在当前目录查找 按照文件名查找 find / -name httpd.conf 在根目录下查找文件httpd.conf，表示在整个硬盘查找 find /etc -name httpd.conf 在/etc目录下文件httpd.conf find /etc -name ‘srm‘ 使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 find . -name ‘srm*’ 表示当前目录下查找文件名开头是字符串‘srm’的文件 -size 按大小找 2M 大小等于 +2M 大小大于2M的文件 归档管理 tar tar -cvf test.tar *.py 将*.py的文件打包为test.tar tar -xvf test.tar 将test.tar解压到当前文件夹，压缩包不删 打包不压缩 tar -zcvf test.tar.gz *.py 压缩 tar -zxvf 解压缩 tar -jcvf test.tar.bz2 *.py 另一种压缩方式 tar -jxvf 解 tar 在命令后面加-C，加指定路径 解压到指定路径 一般用上面这两种压缩 zip test.zip *.py 压缩为zip文件（压缩效果不好） unzip test.zip 解 一些其它命令 命令 作用 links … 打开网页 which 查看用的命令在哪个路径下的文件 cal 日历 cal -y 2008 date 日期时间 ps aux ; top 查看当前运行情况（任务管理器） kill PID码 结束那个进程 kill后加-9 强制结束 reboot 重启 shutdown -h now 立刻关机 +10 10分钟后关机 20:20 df df -h 查看硬盘使用情况 du -h 当前路径使用情况 ifconfig 查看当前电脑上的网卡信息 ping +IP地址 测试远程电脑联通情况，能否通信 useradd shuaige -m 添加用户 sudo（没有权限） passwd shuaige 更改密码 su shuaige 切换账户 exit 退出 whoami 当前用户是谁 userdel shuaige 删除账户 userdel -r shuaige 同时删除家目录 sudo 拥有超级管理员的权限 sudo -s 变成超级管理员(root) groupadd shuaige 创建组 groupdel 删除 cat /etc/group 查看所有组 ls -alf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_继承与多态]]></title>
    <url>%2F2019%2F07%2F09%2FJava_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一、继承多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那一个类称为父类、超类(superclass)或者基类。 继承描述的是事物之间的所属关系，这种关系是: is-a 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 定义： 继承:就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 1.1 格式123456public class 父类 &#123; ...&#125;public class 子类 extends 父类 &#123; ...&#125; 1.2 成员变量访问在父子类的继承关系当中，如果成员变量重名，则： 直接通过子类对象访问成员变量： 等号左边是谁，就优先用谁，没有则向上找。 - 间接通过成员方法访问成员变量： - 该方法属于谁，就优先用谁，没有则向上找 三种变量写法整理： 局部变量：&emsp;&emsp;&emsp; 直接写成员变量名 本类的成员变量： this.成员变量名 父类的成员变量： super.成员变量 父类： 123public class Fu &#123; int num = 10;&#125; 子类： 1234567891011public class Zi extends Fu &#123; int num = 20; public void method() &#123; int num = 30; System.out.println(num); // 30，局部变量 System.out.println(this.num); // 20，本类的成员变量 System.out.println(super.num); // 10，父类的成员变量 &#125;&#125; 1.3 成员方法 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。 注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的 重写（覆盖重写）– 成员方法重名方法重写 :子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 特点：创建的是子类对象，则优先用子类方法 注意事项： 必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。 子类方法的返回值必须【小于等于】父类方法的返回值范围。 小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。 子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; (default) &gt; private备注：(default)不是关键字default，而是什么都不写，留空。 (其实多数情况这些范围权限都是相等的) 应用： 12345public class Phone &#123; public void show() &#123; System.out.println("显示号码"); &#125;&#125; 12345678910public class NewPhone extends Phone &#123; @Override public void show() &#123; super.show(); // 把父类的show方法拿过来重复利用 // 自己子类再来添加更多内容 System.out.println("显示姓名"); System.out.println("显示头像"); &#125;&#125; 1.4构造方法继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 12345678public class Fu &#123; public Fu() &#123; System.out.println("父类无参构造"); &#125; public Fu(int num) &#123; System.out.println("父类有参构造！"); &#125;&#125; 123456789101112public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println("子类构造方法！"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125; 总结：子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 super关键字用法总结： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 this关键字用法总结： super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意：A. this(…)调用也必须是构造方法的第一个语句，唯一一个。B. super和this两种构造调用，不能同时使用 super与this的内存图: 1.5 继承的特点 java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 Java支持多层继承(继承体系)。 子类和父类是一种相对的概念。 二、抽象类没有方法主体的方法称为抽象方法包含抽象方法的类就是抽象类 抽象方法概念图： 2.1 格式抽象类与抽象方法格式： 123456public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat();&#125; 2.2 使用使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 注意事项： 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。理解:子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类。理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 2.3 案例案例分析： 用户父类: 123456789101112131415161718192021222324252627282930public class User &#123; private String name; // 姓名 private int money; // 余额，也就是当前用户拥有的钱数 public User() &#123; &#125; public User(String name, int money) &#123; this.name = name; this.money = money; &#125; // 展示一下当前用户有多少钱 public void show() &#123; System.out.println("我叫：" + name + "，我有多少钱：" + money); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getMoney() &#123; return money; &#125; public void setMoney(int money) &#123; this.money = money; &#125;&#125; 群主子类： 123456789101112131415161718192021222324252627282930313233343536373839public class Manager extends User &#123; public Manager() &#123; &#125; public Manager(String name, int money) &#123; super(name, money); &#125; public ArrayList&lt;Integer&gt; send(int totalMoney, int count) &#123; // 首先需要一个集合，用来存储若干个红包的金额 ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;(); // 看一下群主自己有多少钱 int leftMoney = super.getMoney(); // 群主当前余额 if (totalMoney &gt; leftMoney) &#123; System.out.println("余额不足"); return redList; // 返回空集合 &#125; // 扣钱，其实就是重新设置余额 super.setMoney(leftMoney - totalMoney); // 发红包需要平均拆分成为count份 int avg = totalMoney / count; int mod = totalMoney % count; // 余数，也就是甩下的零头 // 除不开的零头，包在最后一个红包当中 // 下面把红包一个一个放到集合当中 for (int i = 0; i &lt; count - 1; i++) &#123; redList.add(avg); &#125; // 最后一个红包 int last = avg + mod; redList.add(last); return redList; &#125;&#125; 群成员子类： 1234567891011121314151617181920public class Member extends User &#123; public Member() &#123; &#125; public Member(String name, int money) &#123; super(name, money); &#125; public void receive(ArrayList&lt;Integer&gt; list) &#123; // 从多个红包当中随便抽取一个，给我自己。 // 随机获取一个集合当中的索引编号 int index = new Random().nextInt(list.size()); // 根据索引，从集合当中删除，并且得到被删除的红包，给我自己 int delta = list.remove(index); // 当前成员自己本来有多少钱： int money = super.getMoney(); // 加法，并且重新设置回去 super.setMoney(money + delta); &#125;&#125; 发红包： 123456789101112131415161718192021222324252627282930public class MainRedPacket &#123; public static void main(String[] args) &#123; Manager manager = new Manager("群主", 100); Member one = new Member("成员A", 0); Member two = new Member("成员B", 0); Member three = new Member("成员C", 0); manager.show(); // 100 one.show(); // 0 two.show(); // 0 three.show(); // 0 System.out.println("==============="); // 群主总共发20块钱，分成3个红包 ArrayList&lt;Integer&gt; redList = manager.send(20, 3); // 三个普通成员收红包 one.receive(redList); two.receive(redList); three.receive(redList); manager.show(); // 100-20=80 // 6、6、8，随机分给三个人 one.show(); two.show(); three.show(); &#125;&#125; 三、接口接口就是多个类的公共规范。 接口，是Java语言中一种引用类型，是方法的集合。如果说类的内部封装了成员变量、构造方法和成员方法，那么，接口的内部主要就是封装了方法，包含抽象方法(JDK 7及以前)，默认方法和静态方法(JDK 8)，私有方法 (JDK 9)。 3.1 格式 public interface 接口名称 {&emsp;&emsp;&emsp;&emsp;// 抽象方法&emsp;&emsp;&emsp;&emsp;// 默认方法&emsp;&emsp;&emsp;&emsp;// 静态方法&emsp;&emsp;&emsp;&emsp;// 私有方法} 3.2 实现（接口的使用）实现格式： public class 实现类名称 implements 接口名称 {&emsp;&emsp;&emsp;&emsp;// …} 接口不能直接使用，必须有一个“实现类”来“实现”该接口。 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号。 创建实现类的对象，进行使用。 接口 MyInterfaceAbstract 1234public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs()&#125; 实现类 MyInterfaceAbstractImpl 123456public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123; @Override public void methodAbs() &#123; System.out.println("这是一个方法！"); &#125;&#125; 接口实现 1234567891011public class Demo01Interface &#123; public static void main(String[] args) &#123; // 错误写法！不能直接new接口对象使用。// MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs() &#125;&#125; 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。 3.3 内部封装的方法抽象方法格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。（刚学，不推荐省略） 方法的三要素，可以随意定义 默认方法可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 格式： public default 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 备注：接口当中的默认方法，可以解决接口升级的问题 接口 1234567891011121314public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println("这是新添加的默认方法"); &#125;&#125; 实现类A（未重写） 123456public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println("实现了抽象方法，AAA"); &#125;&#125; 实现类B（重写） 1234567891011public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println("实现了抽象方法，BBB"); &#125; @Override public void methodDefault() &#123; System.out.println("实现类B覆盖重写了接口的默认方法"); &#125;&#125; 主代码 1234567891011121314151617public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println("=========="); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125; 静态方法格式： public static 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 只能使用接口名调用(直接在主代码中调用) 不可以通过实现类的类名或者实现类的对象调用 调用格式： 接口名称.静态方法名(参数); 私有方法问题描述：我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。 普通私有方法 解决多个默认方法之间重复代码问题格式： private 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 12345678910111213141516171819public interface MyInterfacePrivateA &#123; public default void methodDefault1() &#123; System.out.println("默认方法1"); methodCommon(); &#125; public default void methodDefault2() &#123; System.out.println("默认方法2"); methodCommon(); &#125; private void methodCommon() &#123; System.out.println("AAA"); System.out.println("BBB"); System.out.println("CCC"); &#125;&#125; 静态私有方法 解决多个静态方法之间重复代码问题格式： private static 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 3.4 常量接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰 从效果上看，这其实就是接口的常量 格式： public static final 数据类型 常量名称 = 数据值; 接口 123456public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 主代码 12345678public class Demo05Interface &#123; public static void main(String[] args) &#123; // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); &#125;&#125; 一旦使用final关键字进行修饰，说明不可改变。 注意事项： 接口当中的常量，可以省略public static final不写也一样。 接口当中的常量，必须赋值，不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 3.5 接口使用注意事项 接口是没有静态代码块或者构造方法的。 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式： public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {&emsp;&emsp;&emsp;&emsp;// 覆盖重写所有抽象方法} 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 一个类如果它的直接父类当中的方法，和接口当中的默认方法产生了冲突（重名），优先用父类当中的方法。 接口A： 1234567891011public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodabs(); public default void methodDefault()&#123; System.out.println("默认方法AAA"); &#125;&#125; 接口B： 12345678910public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodabs(); public default void methodDefault()&#123; System.out.println("默认方法BBB"); &#125;&#125; 实现类： 12345678910111213141516171819202122public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA, MyInterfaceB &#123; @Override public void methodA() &#123; System.out.println("覆盖重写了A方法"); &#125; @Override public void methodB() &#123; System.out.println("覆盖重写了B方法"); &#125; @Override public void methodAbs() &#123; System.out.println("覆盖重写了AB接口都有的抽象方法"); &#125; @Override public void methodDefault() &#123; System.out.println("对多个接口当中冲突的默认方法进行了覆盖重写"); &#125;&#125; 3.6 接口的多继承 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似 接口的继承使用 extends 关键字，子接口继承父接口的方法 如果父接口中的默认方法有重名的，那么子接口需要重写一次 四、多态多态是继封装、继承之后，面向对象的第三大特性。 多态: 是指同一行为，具有多个不同表现形式。 前提： 继承或者实现 方法的重写(意义体现:不重写，无意义) 父类引用指向子类对象 4.1 格式 父类名称 对象名 = new 子类名称(); 或者： 接口名称 对象名 = new 实现类名称(); 当使用多态方式调用方法时，首先检查父类中是否有该方法 如果没有，则编译错误 如果有，执行的是子类重写后方法 父类： 123public abstract class Animal &#123; public abstract void eat();&#125; 子类： 12345class Cat extends Animal &#123; public void eat() &#123; System.out.println("吃鱼"); &#125;&#125; 测试类 12345678public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Animal a = new Cat(); // 调用的是 Cat 的 eat a.eat(); &#125; &#125; 4.2 成员变量多态中成员变量的使用特点，与之前的笔记中一样。 访问成员变量的两种方式(Fu obj = new Zi())： 直接通过对象名称（obj.num)访问成员变量：看等号左边是谁，优先用谁，没有则向上找。(成员变量不能覆盖重写) 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 4.3 成员方法多态中，成员方法的访问规则(也和以前一样)：&emsp;&emsp;&emsp;看new的是谁，就优先用谁，没有则向上找。 特殊之处：编译看左边，运行看右边 对比一下： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边 4.4 使用多态的好处 多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 4.5 引用类型转型多态的转型分为向上转型与向下转型两种: 向上转型 当父类引用指向一个子类对象(接口、实现类)时，便是向上转型。 多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 格式（即多态）： 父类类型 变量名 = new 子类类型();如： Animal animal = new Cat(); 向上转型一定是安全的，没有问题的，正确的 但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 解决方案：用对象的向下转型【还原】 向下转型 一个已经向上转型的子类对象（实现类），将父类（接口）引用转为子类引用（还原），可以使用强制类型转换的格式，便是向下转型 格式： 子类类型 变量名 = (子类类型) 父类变量名;如：Cat cat = (Cat) animal instanceof关键字如何才能知道一个父类引用的对象，本来是什么子类？ 格式： 对象 instanceof 类名称 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例 1234567891011121314151617public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125;&#125; 4.5 接口多态综合案例笔记本电脑(laptop)通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口， 但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。 定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守 USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 分析：进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要实现USB接口，并具备点击的方法 键盘类，要实现USB接口，具备敲击的方法 USB: 1234567public interface USB &#123; public abstract void open(); // 打开设备 public abstract void close(); // 关闭设备&#125; 笔记本： 123456789101112131415161718192021222324public class Computer &#123; public void powerOn() &#123; System.out.println("笔记本电脑开机"); &#125; public void powerOff() &#123; System.out.println("笔记本电脑关机"); &#125; // 使用USB设备的方法，使用接口作为方法的参数 public void useDevice(USB usb) &#123; usb.open(); // 打开设备 if (usb instanceof Mouse) &#123; // 一定要先判断 Mouse mouse = (Mouse) usb; // 向下转型 mouse.click(); &#125; else if (usb instanceof Keyboard) &#123; // 先判断 Keyboard keyboard = (Keyboard) usb; // 向下转型 keyboard.type(); &#125; usb.close(); // 关闭设备 &#125;&#125; 鼠标： 12345678910111213141516// 鼠标就是一个USB设备public class Mouse implements USB &#123; @Override public void open() &#123; System.out.println("打开鼠标"); &#125; @Override public void close() &#123; System.out.println("关闭鼠标"); &#125; public void click() &#123; System.out.println("鼠标点击"); &#125;&#125; 键盘： 12345678910111213141516// 键盘就是一个USB设备public class Keyboard implements USB &#123; @Override public void open() &#123; System.out.println("打开键盘"); &#125; @Override public void close() &#123; System.out.println("关闭键盘"); &#125; public void type() &#123; System.out.println("键盘输入"); &#125;&#125; Main代码: 123456789101112131415161718192021222324252627public class DemoMain &#123; public static void main(String[] args) &#123; // 首先创建一个笔记本电脑 Computer computer = new Computer(); computer.powerOn(); // 准备一个鼠标，供电脑使用// Mouse mouse = new Mouse(); // 首先进行向上转型 USB usbMouse = new Mouse(); // 多态写法 // 参数是USB类型，我正好传递进去的就是USB鼠标 computer.useDevice(usbMouse); // 创建一个USB键盘 Keyboard keyboard = new Keyboard(); // 没有使用多态写法 // 方法参数是USB类型，传递进去的是实现类对象 computer.useDevice(keyboard); // 正确写法！也发生了向上转型 // 使用子类对象，匿名对象，也可以// computer.useDevice(new Keyboard()); // 也是正确写法 computer.powerOff(); System.out.println("=================="); &#125;&#125; 五、final关键字final: 不可改变。可以用于修饰类、方法和变量 类:被修饰的类，不能被继承 方法:被修饰的方法，不能被重写 变量:被修饰的变量，不能被重新赋值 5.1 修饰类格式： public final class 类名{&emsp;&emsp;&emsp;&emsp;//} 当前这个类不能有任何的子类 注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没子类） 5.2 修饰方法格式： 修饰符 final 返回值类型 方法名(参数列表){&emsp;&emsp;&emsp;&emsp;//方法体} 例如：public final void method(){//} 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 5.3 局部变量 基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 //未使用final Student stu1 = new Student("赵丽颖"); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student("霍建华"); System.out.println(stu1.getName()); // 霍建华 //使用final final Student stu2 = new Student("高圆圆"); // 错误写法！final的引用类型变量，其中的地址不可改变// stu2 = new Student("赵又廷"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName("高圆圆圆圆圆圆"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 &#125; 5.4 成员变量对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。 由于成员变量具有默认值，所以用了final之后必须手动赋值，用了final不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值 1234567891011121314151617181920public class Person &#123; private final String name/* = "鹿晗"*/;//直接赋值 public Person() &#123; name = "关晓彤"; //构造方法赋值 &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;// public void setName(String name) &#123;// this.name = name;// &#125;&#125; 六、内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 分为：成员内部类、局部内部类（包含匿名内部类) 6.1 成员内部类格式 修饰符 class 外部类名称 {&emsp;&emsp;&emsp;&emsp;修饰符 class 内部类名称 {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// …&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;// …} 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 使用成员内部类的方法： 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 类： 1234567891011121314151617181920212223242526272829public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println("心脏跳动：蹦蹦蹦！"); System.out.println("我叫：" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println("外部类的方法"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; main 代码： 1234567891011121314public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println("====================="); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125; 同名变量访问格式： 外部类名称.this.外部类成员变量名 格式举例： 123456789101112131415161718public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 6.2 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类 “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了 格式 修饰符 class 外部类名称 {&emsp;&emsp;&emsp;&emsp;修饰符 返回值类型 外部类方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;class 局部内部类名称 {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// …&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;}} 类： 123456789101112131415class Outer &#123; public void methodOuter() &#123; class Inner &#123; // 局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; main代码： 12345678public class DemoMain &#123; public static void main(String[] args) &#123; Outer obj = new Outer(); obj.methodOuter(); &#125;&#125; 权限修饰符定义一个类的时候，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 final问题局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的。 备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 比如： 12345678910111213public class MyOuter &#123; public void methodOuter() &#123; int num = 10; // 所在方法的局部变量 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125; 6.3 匿名内部类 匿名内部类：是内部类的简化写法。本质：带具体实现的 父类（父接口） 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类 缘由： 以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义实现类 重写接口中的方法 创建子类对象 调用重写后的方法 匿名内部类是对此的简化 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次比如多态情况MyInterface obj = new MyInterfaceImpl();那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类 格式 接口名称 对象名 = new 接口名称() {&emsp;&emsp;&emsp;&emsp;// 覆盖重写所有抽象方法}; 有点类似把实现类的内容拿出来了，把实现类的名字匿了 注意事项 匿名内部类，在创建对象的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，要么重复写两遍，要么就需要使用单独定义的实现类了。 匿名对象，在调用方法的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，要么重复写两遍，要么必须给对象起个名字。 匿名内部类是省略了实现类/子类名称，但是匿名对象是省略了对象名称强调：匿名内部类和匿名对象不是一回事！！！ 6.4 类作为成员变量英雄 123456789101112131415161718192021public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println("年龄为" + age + "的" + name + "用" + weapon.getCode() + "攻击敌方。"); &#125; // getter、setter省略&#125; 武器 12345678910111213public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; // getter、setter省略&#125; main 12345678910111213141516171819public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName("盖伦"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon("AK-47"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 6.5 接口作为成员变量英雄 1234567891011121314151617181920public class Hero &#123; private String name; // 英雄的名称 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println("我叫" + name + "，开始施放技能："); skill.use(); // 调用接口中的抽象方法 System.out.println("施放技能完成。"); &#125; // getter、setter省略&#125; 技能 12345public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; main 123456789101112131415161718192021222324252627282930public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName("艾希"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println("Pia~pia~pia~");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println("Biu~Pia~Biu~Pia~"); &#125; &#125;); hero.attack(); &#125;&#125; 接口还可以做方法的参数和返回值 6.6 案例 发红包（待整理）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>继承与多态</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_常用API]]></title>
    <url>%2F2019%2F07%2F04%2FJava_%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[API: API(Application Programming Interface)，应用程序编程接口Java API是一本程序员的字典是我们使用的类的说明文档 API帮助文档（中文版）：JDK_API_1_6_zh_CN.CHM 引用类: 一般步骤： 导包 import 包路径.类名称; 如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包（比如String），其他的包都需要import语句。 创建 类名称 对象名 = new 类名称(); 使用 对象名.成员方法名() 一、 Scanner类功能： 可以实现键盘输入数据，到程序当中 使用方法： 查看类 java.util.Scanner :该类需要import导入后使用。 查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 查看成员方法 public int nextInt() :将输入信息的下一个标记扫描为一个 int 值。 还有很多，比如next（），String值 使用Scanner类，完成接收键盘录入数据的操作，代码如下: 12345678910111213141516171819import java.util.Scanner;public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println("输入的int数字是：" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println("输入的字符串是：" + str); &#125;&#125; 练习题： 键盘输入三个int数字，然后求出其中的最大值 123456789101112131415161718192021import java.util.Scanner;public class Demo03ScannerMax &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入第一个数字："); int a = sc.nextInt(); System.out.println("请输入第二个数字："); int b = sc.nextInt(); System.out.println("请输入第三个数字："); int c = sc.nextInt(); // 首先得到前两个数字当中的最大值 int temp = a &gt; b ? a : b; int max = temp &gt; c ? temp : c; System.out.println("最大值是：" + max); &#125;&#125; 二、匿名对象匿名对象：没有变量名的对象 格式: new 类名(参数列表); 应用场景: 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。一旦调用两次方法，就是创建了两个对象，造成浪费 匿名对象可以作为方法的参数和返回值 作为参数 1234567891011121314class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125; &#125; 作为返回值 123456789101112131415class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125; 三、Random类Random类：用来生成随机数字 使用步骤： 导包 import java.util.Random; idea可以自动生成 创建 Random r = new Random(); // 小括号当中留空即可 使用 获取一个随机的int数字（范围是int所有范围，有正负两种）： int num = r.nextInt() 获取一个随机的int数字（参数代表了范围，左闭右开区间）： int num = r.nextInt(3) 实际上代表的含义是：[0,3)，也就是0~2 练习： 猜数字小游戏游戏开始，随机生成一个1-100之间的整数 number 。玩家猜测一个数字 guessNumber ，会与 number 作比较，系统提示大了或者小了，直到玩家猜中，游戏结束。 代码： 123456789101112131415161718192021public static void main(String[] args) &#123; Random r = new Random(); int randomNum = r.nextInt(100) + 1; //[1:100] Scanner sc = new Scanner(System.in); while (true)&#123; System.out.println("请输入你猜测的数字："); int guessNum = sc.nextInt(); if (guessNum &gt; randomNum)&#123; System.out.println("太大了，请重试"); &#125;else if (guessNum &lt; randomNum)&#123; System.out.println("太小了，请重试"); &#125;else &#123; System.out.println("恭喜你，猜中啦"); break; &#125; &#125; System.out.println("游戏结束");&#125; 四、ArrayList类对象数组： 数组类型选用对象，例如： 123456789101112public static void main(String[] args) &#123; // 首先创建一个长度为3的数组，里面用来存放Person类型的对象 Person[] array = new Person[3]; Person one = new Person("迪丽热巴", 18); // 将one当中的地址值赋值到数组的0号元素位置 array[0] = one; System.out.println(array[0]); // 地址值 System.out.println(array[0].getName()); // 迪丽热巴&#125; 而数组的长度是固定的，无法适应数据变化的需求 ArrayList类： 数组的长度不可以发生改变但是ArrayList集合的长度是可以随意变化的 4.1 查看类 java.util.ArrayList &lt;E&gt;:需要 import导入 &lt;E&gt; ，表示一种指定的数据类型，叫做泛型。 在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素 ArrayList&lt; String&gt;，ArrayList&lt; Student&gt; 4.2 格式(查看构造方法)基本格式: ArrayList&lt; String&gt; list = new ArrayList&lt; String&gt;(); 在JDK 1.7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。 简化格式: ArrayList&lt; String&gt; list = new ArrayList&lt;&gt;(); 注意：对于ArrayList集合来说，未添加数据直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号：[] 4.3 常用方法及遍历对于元素的操作,基本体现在——增、删、查。常用的方法有: public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（后面会有）来说，add添加动作不一定成功。 public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。 public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。 public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数 举例： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 向集合中添加元素：add boolean success = list.add("柳岩"); System.out.println(list); // [柳岩] System.out.println("添加的动作是否成功：" + success); // true list.add("高圆圆"); list.add("赵又廷"); list.add("李小璐"); list.add("贾乃亮"); System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮] // 从集合中获取元素：get。索引值从0开始 String name = list.get(2); System.out.println("第2号索引位置：" + name); // 赵又廷 // 从集合中删除元素：remove。索引值从0开始。 String whoRemoved = list.remove(3); System.out.println("被删除的人是：" + whoRemoved); // 李小璐 System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 贾乃亮] // 获取集合的长度尺寸，也就是其中元素的个数 int size = list.size(); System.out.println("集合的长度是：" + size); //遍历 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //idea中，list.fori可以自动生成这个循环&#125; 4.4 存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt; int&gt; 不能写，但是存储基本数据类型对应的包装类型是可以的。 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 4.5 练习 生成6个1~33之间的随机整数,添加到集合,并遍历 12345678910111213141516171819public class Test01ArrayList &#123; public static void main(String[] args) &#123; // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对象 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) &#123; int r = random.nextInt(33) + 1; list.add(r); &#125; // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125; &#125; 自定义2个学生对象，添加到集合，并遍历 123456789101112131415161718public class Demo02ArrayListStudent &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); Student one = new Student("洪七公", 20); Student two = new Student("欧阳锋", 21); list.add(one); list.add(two); // 遍历集合 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); System.out.println("姓名：" + stu.getName() + "，年龄" + stu.getAge()); &#125; &#125;&#125; 对象可以作为集合元素 定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用{}扩起集合，使用@分隔每个元素。格式参照 {元素@元素@元素} 1234567891011121314151617181920212223242526public class Demo05ArrayListPrint &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("张三丰"); list.add("宋远桥"); list.add("张无忌"); list.add("李连杰"); System.out.println(list); printArrayList(list); &#125; public static void printArrayList(ArrayList&lt;String&gt; list)&#123; System.out.print("&#123;"); for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); if (i == list.size() - 1)&#123; System.out.println(name + "&#125;"); &#125;else&#123; System.out.print(name + "@"); &#125; &#125; &#125;&#125; 用一个大集合存入20个随机数字(1~100)，然后筛选其中的偶数元素，放到小集合当中。要求使用自定义的方法来实现筛选 1234567891011121314151617181920212223242526272829303132public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(100) + 1; // 1~100 bigList.add(num); &#125; ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println("偶数总共有多少个：" + smallList.size()); for (int i = 0; i &lt; smallList.size(); i++) &#123; System.out.println(smallList.get(i)); &#125; &#125; // 这个方法，接收大集合参数，返回小集合结果 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; // 创建一个小集合，用来装偶数结果 ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bigList.size(); i++) &#123; int num = bigList.get(i); if (num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125; ArrayList类型作为返回值 五、String类java.lang.String类代表字符串程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。） 特点： 字符串的内容永不可变。 正是因为字符串不可改变，所以字符串是可以共享使用的。 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[]字节数组。 5.1 构造方法创建字符串的常见3+1种方式。 三种构造方法： public String()：创建一个空白字符串，不含有任何内容。 public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。 代码： 12345678910 // 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;; String str3 = new String(bytes);//打印输出是'a','b','c' 一种直接创建： String str = &quot;Hello&quot;; // 右边直接用双引号 注意：直接写上双引号，就是字符串对象。 5.2 字符串的常量池 字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中 对于基本类型来说，==是进行 数值 的比较 对于引用类型来说，==是进行 地址值 的比较 1234567891011public static void main(String[] args) &#123; String str1 = "abc"; String str2 = "abc"; char[] charArray = &#123;'a', 'b', 'c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false&#125; 5.3 比较方法==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法： public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。 注意事项： 任何对象都能用Object进行接收。 equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：”abc”.equals(str)不推荐：str.equals(“abc”) public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。 5.4 获取方法 String当中与获取相关的常用方法有： public int length()：获取字符串长度。 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。 public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。） public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 12345678910111213141516171819202122public static void main(String[] args) &#123; // 获取字符串的长度 int length = "asdasfeutrvauevbueyvb".length(); // 拼接字符串 String str1 = "Hello"; String str2 = "World"; String str3 = str1.concat(str2); System.out.println(str3); // HelloWorld，新的字符串 // 获取指定索引位置的单个字符 char ch = "Hello".charAt(1); System.out.println("在1号索引位置的字符是：" + ch); // 查找参数字符串在本来字符串当中出现的第一次索引位置 // 如果根本没有，返回-1值 String original = "HelloWorldHelloWorld"; int index = original.indexOf("llo"); System.out.println("第一次索引值是：" + index); // 2 System.out.println("HelloWorld".indexOf("abc")); // -1&#125; 5.5 截取方法字符串的截取方法： public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边 123456String str1 = "HelloWorld";String str2 = str1.substring(5);System.out.println(str2); // World，新字符串String str3 = str1.substring(4, 7);System.out.println(str3); // oWo 5.6 转换方法String当中与转换相关的常用方法有： public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。 public byte[] getBytes()：获得当前字符串底层的字节数组。 public String replace(CharSequence oldString, CharSequence newString)： 将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。备注：CharSequence意思就是说可以接受字符串类型 1234567891011121314// 转换成为字符数组char[] chars = "Hello".toCharArray();System.out.println(chars[0]); // H// 转换成为字节数组byte[] bytes = "abc".getBytes();for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.println(bytes[i]);&#125;// 字符串的内容替换String str1 = "How do you do?";String str2 = str1.replace("o", "*");System.out.println(str2); // H*w d* y*u d*? 5.7 分割方法分割字符串的方法：public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。 12345String str1 = "aaa,bbb,ccc";String[] array1 = str1.split(",");for (int i = 0; i &lt; array1.length; i++) &#123; System.out.println(array1[i]);&#125; 注意事项：split方法的参数其实是一个“正则表达式”，后面学习。此处注意：如果按照英文句点“.”进行切分，必须写”\.”（两个反斜杠） 六、static关键字static关键字：它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 6.1 类变量（静态变量）（修饰成员变量）当static修饰成员变量时，该变量称为 类变量 该类的每个对象都共享同一个类变量的值 任何对象都可以更改该类变量的值 但也可以在不创建该类的对象的情况下对类变量进行操作。 举例： 每新来一个同学，id自动+1 学生类： 12345678910111213141516171819202122232425262728293031323334353637public class Student &#123; private int id; // 学号 private String name; // 姓名 private int age; // 年龄 static String room; // 所在教室 private static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++ public Student() &#123; this.id = ++idCounter; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 代码： 1234567891011121314151617public class Demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student("郭靖", 19); one.room = "101教室";//后面会说，不推荐这么写 System.out.println("姓名：" + one.getName() + "，年龄：" + one.getAge() + "，教室：" + one.room + "，学号：" + one.getId()); Student two = new Student("黄蓉", 16); System.out.println("姓名：" + two.getName() + "，年龄：" + two.getAge() + "，教室：" + two.room + "，学号：" + two.getId()); &#125;&#125; 输出： 姓名：郭靖，年龄：19，教室：101教室，学号：1姓名：黄蓉，年龄：16，教室：101教室，学号：2 6.2 静态方法（类方法）（修饰成员方法）一旦使用static修饰成员方法，那么这就成为了 静态方法。静态方法不属于对象，而是属于 类 的。 如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。 如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 注意事项： 静态不能直接访问非静态原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容“先人不知道后人，但是后人知道先人。” 静态方法当中不能用this原因：this代表当前对象，通过谁调用的方法，谁就是当前对象 MyClass类： 1234567891011121314151617181920212223242526272829public class MyClass &#123; int num; // 成员变量 static int numStatic; // 静态变量 // 成员方法 public void method() &#123; System.out.println("这是一个成员方法。"); // 成员方法可以访问成员变量 System.out.println(num); // 成员方法可以访问静态变量 System.out.println(numStatic); &#125; // 静态方法 public static void methodStatic() &#123; System.out.println("这是一个静态方法。"); // 静态方法可以访问静态变量 System.out.println(numStatic); // 静态不能直接访问非静态【重点】// System.out.println(num); // 错误写法！ // 静态方法中不能使用this关键字。// System.out.println(this); // 错误写法！ &#125;&#125; 代码： 12345678910111213141516171819202122public class Demo02StaticMethod &#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); // 首先创建对象 // 然后才能使用没有static关键字的内容 obj.method(); // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名” MyClass.methodStatic(); // 正确，推荐 // 对于本类当中的静态方法，可以省略类名称 myMethod(); Demo02StaticMethod.myMethod(); // 完全等效 &#125; public static void myMethod() &#123; System.out.println("自己的方法！"); &#125;&#125; 6.3静态代码块格式： public class 类名称 {&emsp;&emsp;&emsp;&emsp;static {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// 静态代码块的内容&emsp;&emsp;&emsp;&emsp;}} 特点： 当第一次用到本类时，静态代码块执行唯一的一次。 静态内容总是优先于非静态，所以静态代码块比构造方法先执行。 典型用途： 用来一次性地对静态成员变量进行赋值。 Person类： 123456789public class Person &#123; static &#123; System.out.println("静态代码块执行！"); &#125; public Person() &#123; System.out.println("构造方法执行！"); &#125;&#125; 代码： 1234public static void main(String[] args) &#123; Person one = new Person(); Person two = new Person();&#125; 输出结果： 静态代码块执行！构造方法执行！构造方法执行！ 七、Arrays类java.util.Arrays此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 常用方法： public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]） public static void sort(数组)：按照默认升序（从小到大）对 数组 的元素进行排序。 如果是数值，sort默认按照升序从小到大 如果是字符串，sort默认按照字母升序 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习） 123String[] array2 = &#123;"bbb", "aaa", "ccc"&#125;;Arrays.sort(array2);System.out.println(Arrays.toString(array2)); // [aaa, bbb, ccc] 练习： 请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。（涉及到倒序遍历） 1234567891011121314public static void main(String[] args) &#123; String str = "asv76agfqwdfvasdfvjh"; // 如何进行升序排列：sort // 必须是一个数组，才能用Arrays.sort方法 // String --&gt; 数组，用toCharArray char[] chars = str.toCharArray(); Arrays.sort(chars); // 对字符数组进行升序排列 // 需要倒序遍历(此处idea快捷键：chars.forr) for (int i = chars.length - 1; i &gt;= 0; i--) &#123; System.out.println(chars[i]); &#125;&#125; 八、Math类java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 基本运算方法： public static double abs(double num)：获取绝对值。有多种重载。 public static double ceil(double num)：向上取整。 public static double floor(double num)：向下取整。 public static long round(double num)：四舍五入。 Math.PI代表近似的圆周率常量（double） 1234567double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.ceil(3.3); //d2的值为 4.0double d3 = Math.floor(3.3); //d3的值为3.0long d4 = Math.round(5.5); //d4的值为6.0]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>常用API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础_3]]></title>
    <url>%2F2019%2F07%2F04%2FJava%E5%9F%BA%E7%A1%80_3%2F</url>
    <content type="text"><![CDATA[第一章 类与对象类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 1.1 类的定义格式： public class ClassName {&emsp;&emsp;&emsp;&emsp;//成员变量(属性)&emsp;&emsp;&emsp;&emsp;//成员方法(行为)} 成员变量:和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法:和以前定义方法几乎是一样的。只不过把static去掉。 举例： 1234567891011121314 public class Student &#123; //成员变量 String name;//姓名 int age;//年龄 //成员方法 //学习的方法 public void study() &#123; System.out.println("好好学习，天天向上"); &#125; //吃饭的方法 public void eat() &#123; System.out.println("学习饿了要吃饭"); &#125;&#125; 1.2 对象的使用格式： 导包 import 包名称.类名称； （属于同一个包可以不写） 创建对象 类名 对象名 = new 类名(); 使用对象访问类中的成员 对象名.成员变量;对象名.成员方法(); 成员变量的默认值 数据类型 默认值 基本类型 整数(byte，short，int，long) 0 浮点数(float，double) 0.0 字符(char) ‘\u0000’ 布尔(boolean) false 引用类型 数组，类，接口 null 类与对象举例： 定义手机类: 123456789101112131415public class Phone &#123; // 成员变量 String brand; //品牌 int price; //价格 String color; //颜色 // 成员方法 //打电话 public void call(String name) &#123; System.out.println("给"+name+"打电话"); &#125; //发短信 public void sendMessage() &#123; System.out.println("群发短信"); &#125;&#125; 定义测试类: 1234567891011121314151617181920212223242526public class Test02Phone &#123; public static void main(String[] args) &#123; //创建对象 Phone p = new Phone(); //输出成员变量值 System.out.println("品牌:"+p.brand);//null System.out.println("价格:"+p.price);//0 System.out.println("颜色:"+p.color);//null System.out.println("‐‐‐‐‐‐‐‐‐‐‐‐"); //给成员变量赋值 p.brand = "锤子"; p.price = 2999; p.color = "棕色"; //再次输出成员变量值 System.out.println("品牌:"+p.brand);//锤子 System.out.println("价格:"+p.price);//2999 System.out.println("颜色:"+p.color);//棕色 System.out.println("‐‐‐‐‐‐‐‐‐‐‐‐"); //调用成员方法 p.call("紫霞"); p.sendMessage(); &#125; &#125; 成员变量和局部变量区别 在类中的位置不同 成员变量:类中，方法外 局部变量:方法中或者方法声明上(形式参数) 作用范围不一样 成员变量:类中 局部变量:方法中 初始化值的不同 成员变量:有默认值 局部变量:没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 成员变量:堆内存 局部变量:栈内存 生命周期不同 成员变量:随着对象的创建而存在，随着对象的消失而消失 局部变量:随着方法的调用而存在，随着方法的调用完毕而消失 第二章 封装封装 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 方法就是一种封装 关键字private也是 2.1 封装步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对getXxx方法 、setXxx方法。 2.2 封装的操作——private关键字private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 使用格式 private 数据类型 变量名 ; 使用 private 修饰成员变量，代码如下: 1234public class Student &#123; private String name; private int age;&#125; 提供 getXxx 方法 / setXxx 方法，可以访问成员变量 代码如下: 123456789101112131415161718public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; &#125; set方法，用于向age设置数据 get方法，用于获取age的数据 可以用set约束设置的数据 注意： 对于基本类型中的boolean值，getter方法要写成isxxx，而setxxx规则不变 第三章 封装优化3.1 this关键字上一章中，setXxx 方法中形参名字并不符合见名知意的规定如果修改与成员变量名一致，代码如下: 1234567891011public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125; &#125; 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量如果需要访问本类当中的成员变量，需要使用this关键字通过谁调用的方法，谁就是this 格式： this.成员变量名; 使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下: 12345678910public class Person &#123; String name; // 我自己的名字 // 参数name是对方的名字 // 成员变量name是自己的名字 public void sayHello(String name) &#123; System.out.println(name + "，你好。我是" + this.name); System.out.println(this); &#125;&#125; 12345678910public class Demo01Person &#123; public static void main(String[] args) &#123; Person person = new Person(); // 设置我自己的名字 person.name = "王健林"; person.sayHello("王思聪"); System.out.println(person); // 地址值 &#125;&#125; 输出结果： 王思聪，你好。我是王健林cn.itcast.day06.demo04.Person@7852e922cn.itcast.day06.demo04.Person@7852e922 3.2 构造方法构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。格式： public 类名称(参数类型 参数名称) {&emsp;&emsp;&emsp;&emsp;方法体} 注意事项： 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样 构造方法不要写返回值类型，连void都不写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。public Student() {} 一旦编写了至少一个构造方法，那么编译器将不再赠送。 构造方法也是可以进行重载的。 使用构造方法后，代码如下: 12345678910111213public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 全参数构造方法，方便我们在创建对象的时候把数据直接通过参数的形式设置进来，省去多次调用setget方法 但是当修改对象内容时set方法还是有用的。 获取数据时还是要用get方法 要写全参数构造方法时，需要把无参数也写上，因为系统不会赠送了。 3.3 标准代码——JavaBean一个标准的类通常要拥有下面四个组成部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 编写符合 JavaBean 规范的类，以学生类为例，标准代码如下: 12345678910111213141516171819202122232425262728public class Student &#123; //成员变量 private String name; // 姓名 private int age; // 年龄 //构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; 成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 测试类，代码如下： 1234567891011121314public class TestStudent &#123; public static void main(String[] args) &#123; //无参构造使用 Student s= new Student(); s.setName("柳岩"); s.setAge(18); System.out.println(s.getName()+"‐‐‐"+s.getAge()); //带参构造使用 Student s2= new Student("赵丽颖",18); System.out.println(s2.getName()+"‐‐‐"+s2.getAge()); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础_2]]></title>
    <url>%2F2019%2F07%2F03%2FJava%E5%9F%BA%E7%A1%80_2%2F</url>
    <content type="text"><![CDATA[第一章 方法方法: 就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 1.1 定义 修饰符 返回值类型 方法名 (参数列表){&emsp;&emsp;&emsp;&emsp;代码…&emsp;&emsp;&emsp;&emsp;return 返回值;} 定义格式解释: 修饰符: 目前固定写法 public static 返回值类型: 没有返回值时为&ensp;void 方法名:满足标识符的规范，用来调用方法。 参数列表: 参数 return:方法结束。返回值类型是void，方法大括号内的return可以不写，有返回值时返回给调用者。 举例： 123 public static void methodName() &#123; System.out.println("这是一个方法");&#125; 方法定义注意事项: 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 1.2 方法的调用12345678 public static void main(String[] args) &#123; //调用定义的方法method method();&#125;//定义方法，被main方法调用 public static void method() &#123; System.out.println("自己定义的方法，需要被main调用运行"); &#125; 上面方法为直接调用，有参数时括号内写入参数 还可以输出语句调用: 在输出语句中调用方法， System.out.println(方法名()) 。 不能用输出语句调用 void 类型的方法 1.3 方法重载 方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。 参数列表不同：个数不同，数据类型不同，顺序不同。 重载方法调用：JVM通过方法的参数列表，调用不同的方法。 重载练习比较两个数据是否相等。参数类型分别为两个 byte 类型，两个 short 类型，两个 int 类型，两个 long 类型，并在 main 方法中进行测试。 123456789101112131415161718192021222324252627282930313233343536373839public class Method_Demo6 &#123; public static void main(String[] args) &#123; //定义不同数据类型的变量 byte a = 10; byte b = 20; short c = 10; short d = 20; int e = 10; int f = 10; long g = 10; long h = 20; // 调用 System.out.println(compare(a, b)); System.out.println(compare(c, d)); System.out.println(compare(e, f)); System.out.println(compare(g, h)); &#125; // 两个byte类型的 public static boolean compare(byte a, byte b) &#123; System.out.println("byte"); return a == b; &#125; // 两个short类型的 public static boolean compare(short a, short b) &#123; System.out.println("short"); return a == b; &#125; // 两个int类型的 public static boolean compare(int a, int b) &#123; System.out.println("int"); return a == b; &#125; // 两个long类型的 public static boolean compare(long a, long b) &#123; System.out.println("long"); return a == b; &#125;&#125; 1.4 权限修饰符public:公共的protected:受保护的default:默认的（不写）private:私有的 public protected default(空的) private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 第二章 数组数组: 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 数组的特点： 数组是一种引用数据类型 数组当中的多个数据，类型必须统一 数组的长度在程序运行期间不可改变 2.1 定义数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 两种常见的初始化方式： 动态初始化（指定长度） 静态初始化（指定内容） 动态初始化数组 格式： 数据类型[] 数组名称 = new 数据类型[数组长度]; 解析含义： 数据类型：数组当中数据的统一类型[]：代表我是一个数组new：代表创建数组的动作数组长度：指定长度 举例： 1int[] arr = new int[3]; 静态初始化 标准格式： 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 省略格式： 数据类型[] 数组名称 = { 元素1, 元素2, … } 举例： 123int[] arrA = new int[]&#123;1,2,3,4,5&#125;;int[] arrB = &#123;1,2,3,4,5&#125;; 注意： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度 静态初始化标准格式、动态初始化，可以拆分成为两个步骤 静态初始化省略格式不能拆分成为两个步骤 12int[] arrayB;arrayB = new int[] &#123; 11, 21, 31 &#125;; 2.2 数组的访问索引：从0开始，通过数组的索引访问到数组中的元素格式： 数组名[索引] 数组长度获得数组长度语句：数组名.length数组的最大索引值为：数组名.length-1 索引访问数组中的元素: 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，获取出数组中的元素 2.3 数组内存原理Java虚拟机的内存划分 一个数组内存图 两个独立数组内存图 两个变量指向同一个数组内存图 2.4 数组遍历123456public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 2.5 数组获得最大值元素123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++)&#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println("数组最大值是: " + max); &#125; 2.6 数组反转数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 实现思想：数组最远端的元素互换位置。 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引–，再次交换位置 最小索引超过了最大索引，数组反转操作结束 12345678910111213141516public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 2.7 数组作为方法参数和返回值 数组作为方法参数传递，传递的参数是数组内存的地址 数组作为方法的返回值，返回的是数组的内存地址 方法的参数为基本类型时，传递的是数据值。为引用类型时，传递的是地址值。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop安装与伪分布式搭建]]></title>
    <url>%2F2019%2F06%2F29%2Fhadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建Hadoop用户 创建新用户用户名为hadoop，使用/bin/bash作为shellsudo useradd -m hadoop -s /bin/bash 修改密码 1234$ sudo passwd hadoopEnter new UNIX password: Retype new UNIX password: passwd: password updated successfully 为hadoop用户添加管理员权限sudo adduser hadoop sudo 安装jdk1.7首先在oracle官网下载,接下来进行安装与环境变量配置，根据个人电脑系统选择对应版本，我选的是jdk-8u211-linux-x64.tar.gz 12345$ mkdir /usr/lib/jvm #创建jvm文件夹$ sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/lib/jvm #/ 解压到/usr/lib/jvm目录下$ cd /usr/lib/jvm #进入该目录$ mv jdk1.8.0_211 java #重命名为java$ vim ~/.bashrc #给JDK配置环境变量 在.bashrc文件添加如下指令： 1234export JAVA_HOME=/usr/lib/jvm/javaexport JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 在文件修改完毕以后，输入代码：$ source ~/.bashrc #使新配置的环境变量生效$ java -version #检测是否安装成功，查看java版本 安装SSH服务端 安装$ sudo apt-get install openssh-server 登录localhost$ ssh localhost之后会在~/文件夹下发现一个.ssh文件 设置为无密码登录123$ cd ~/.ssh/$ ssh-keygen -t rsa #出现提示直接按enter$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys #加入授权 此时就直接使用$ ssh localhost，无密码登录了。 安装Hadoop本文采用伪分布式模式：存储采用分布式文件系统HDFS，但是HDFS的节点和数据节点都在同一节点。 下载安装下载安装包后解压即可使用：1234$ sudo tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local$ cd /usr/local/$ sudo mv ./hadoop-2.7.1/ ./hadoop # 将文件夹名改为hadoop$ sudo chown -R hadoop ./hadoop # 修改文件权限 查看Hadoop版本信息： 12$ cd /usr/local/hadoop/bin$ ./hadoop version &lt;img src=”hadoop安装与伪分布式搭建/2.png&gt; 伪分布式模式配置修改配置文件:需要修改/usr/local/hadoop/etc/hadoop/文件夹下的core-site.xml和hdfs-site.xml文件。core-site.xml文件:将12&lt;configuration&gt;&lt;/configuration&gt; 修改为： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml文件修改如下： 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将/hadoop/etc/hadoop/hadoop-env.sh文件的JAVA_HOME改为绝对路径。将export JAVA_HOME=$JAVA_HOME改为export JAVA_HOME=/usr/lib/jvm/default-java 注意：Hadoop的运行方式是由配置文件决定的，如果想从伪分布式模式切换回单机模式，只需删除core-site.xml文件中的配置项即可 执行名称节点格式化执行如下命令：12$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format 出现如下错误 原因应该是权限不够无法再目录内新建文件。解决方案是：先输入命令：sudo su转为root身份输入命令：sudo chmod -R a+w /opt/hadoop-1.2.1/注意修改自己的安装路径。输入命令exit回到用户身份 再执行格式化成功。如果出现/usr/local/hadoop/tmp/dfs/name has been successfully formatted.和 Exiting with status 0，表示格式化成功。 启动Hadoop12$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh 用jps命令查看Hadoop是否启动成功，如果出现DataNode、NameNode、SecondaryNameNode的进程说明启动成功。 使用浏览器查看HDFS信息在浏览器中打开链接：http://localhost:50070/dfshealth.html#tab-overview即可查看 关闭Hadoop使用命令：./sbin/stop-dfs.sh下次启动时不需要再执行节点格式化命令（否则会报错），只需要直接运行start-dfs.sh命令即可。]]></content>
      <categories>
        <category>大数据环境搭建</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础_1]]></title>
    <url>%2F2019%2F06%2F29%2FJava%E5%9F%BA%E7%A1%80_1%2F</url>
    <content type="text"><![CDATA[第一章 入门1.1 HelloWorld入门程序Java程序开发三步骤:编写、编译、运行。 编写Java源程序 创建HelloWorld.java文件，代码如下： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 编译Java源文件 在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。命令: javac Java源文件名.后缀名 举例: 1javac HelloWorld.java 译成功后，产生一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 运行Java程序 在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。命令: java 类名字 举例： 1java HelloWolrd 入门程序说明 main方法： 称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释： 单行注释以 //开头 换行结束多行注释以 /*开头 以*/结束 关键字： 是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母。 标识符： 是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 HelloWorld案例中，出现的标识符有类名字 HelloWorld 。 命名规则： 硬性要求标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $(美元符号) 和 _(下划线) 。标识符不能以数字开头。标识符不能是关键字。软性要求类名规范:首字母大写，后面每个单词首字母大写(大驼峰式)。方法名规范: 首字母小写，后面每个单词首字母大写(小驼峰式)。变量名规范:全部小写 1.2 常量变量常量 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’，’’， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值 true ， false 空常量 只有一个值 null 变量 Java的数据类型分为两大类: 基本数据类型:包括 整数、浮点数、字符、布尔。 引用数据类型:包括 类 、 数组 、 接口 。 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int(默认) 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double(默认) 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false 变量定义 格式： 数据类型 变量名 = 数据值; 1.3 数据类型转换、运算符Java程序中要求参与的计算的数据，必须要保证数据类型的一致性（比如进行加法运算），如果数据类型不一致将发生类型的转换。 自动转换将 取值范围小的类型 自动提升为 取值范围大的类型 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 将 取值范围大的类型 强制转换成 取值范围小的类型 。 自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 转换格式： 数据类型 变量名 = (数据类型)被转数据值; 注意： 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 ASCII编码表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 1234567public static void main(String[] args) &#123; //字符类型变量 char c = 'a'; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98 &#125; 运算符算数运算符 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 注意：变量在独立运算时， 前++ 和 后++ 没有区别 ；和其他变量放在一起， 前++ 和 后++ 就产生了不同（+1后赋值、赋值后+1）。 三元运算符 格式： 数据类型 变量名 = 布尔类型表达式?结果1:结果2 计算方式:布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125; 第二章 判断、选择、循环语句2.1 判断语句 if 123if(关系表达式)&#123; 语句体;&#125; if…else 12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; if…else if…else 12345678910if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n; &#125; else &#123; 执行语句n+1; &#125; 注意：在某些简单的应用中，if语句是可以和三元运算符互换使用的。 1234567891011public static void main(String[] args) &#123; int a = 10; int b = 20; //定义变量，保存a和b的较大值 int c; if(a &gt; b) &#123; c = a; &#125; else &#123; c = b; &#125; //上述功能可以改写为三元运算符形式 c = a &gt; b ? a:b; &#125; 2.2 选择语句 switch 123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; switch语句中，表达式的数据类型，可以是byte，short，int，char，enum(枚举)，JDK7后可以接收字符串 注意：case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 2.3 循环语句 for循环 for(初始化表达式1; 布尔表达式2; 步进表达式4){ 循环体3} 执行顺序:1234&gt;234&gt;234…2不满足为止。 while循环 初始化表达式1 while(布尔表达式2){&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4} 执行顺序:1234&gt;234&gt;234…2不满足为止。 do…while循环 初始化表达式1 do{&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4}while(布尔表达式2); 执行顺序:134&gt;234&gt;234…2不满足为止。 for 和 while 的小区别: 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 2.4跳出语句break使用场景:终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景:结束本次循环，继续下一次的循环 嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo markdown]]></title>
    <url>%2F2019%2F06%2F28%2Fhexo-markdown%2F</url>
    <content type="text"><![CDATA[一些markdown记录 &lt; br&gt; 换行 两个空格+回车：换行 两个回车：换段落 空格+-，下一行-，会产生缩进序列 &amp;emsp ; 空一个汉字格数 &amp;ensp ; 空一个格]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客搭建]]></title>
    <url>%2F2019%2F06%2F28%2Fhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建流程&emsp;&emsp;1. 安装node.js 打开nodejs.org下载安装包，直接点开安装包安装。 查看安装版本 node -v npm -v &emsp;&emsp;2. 安装hexo框架（以下若权限不足sudo） npm install -g hexo-cli hexo -v 查看hexo版本 &emsp;&emsp;3. 建立blog空文件夹（在用户文件夹中建立即可（位置随意）） mkdir blog 后续如果出现什么问题，把blog文件夹删除重新来即可。 cd blog &emsp;&emsp;4. 初始化博客 sudo hexo init &emsp;&emsp;5. 启动博客 hexo s 浏览器打开localhost:4000，可以看到默认创建的博客 &emsp;&emsp;6. 创建自己的博客 sudo hexo new &quot;测试&quot; cd source/_posts/ 编辑测试.md即可更改博客内容（markdown） cd ../..退回到blog目录下 &emsp;&emsp;7. 本地查看博客总结 hexo clean 清理一下 hexo g 生成一下 hexo s 启动一下 &emsp;&emsp;8. 建repository（为了博客部署到github上公开使用） 登陆自己的github账户，右上角+点开 New repositoryrepository name 必须是 ：昵称（前面的Owner）.github.io 点击greate，出现一个空仓库，保留页面 &emsp;&emsp;9. 安装部署插件 sudo npm install --save hexo-deployer-git 更改_config.yml文件 sudo vim _config.yml 到达文件最底部更改增加如下： 1234deploy: type: git repo: https://github.com/mangosTeeN96/mangosTeeN96.github.io.git branch: master 其中repo地址为刚刚创建的仓库页面的地址（注意冒号后面的空格） &emsp;&emsp;10. 部署到远端 hexo d 中途需要输入GitHub的账户密码 此时访问 mangosteen96.github.io 即可看到自己的博客 到此博客的基本部署就完成了 &emsp;&emsp;11. 更换博客主题 以yilia主题为例 sudo git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 此时themes文件夹中出现yilia文件夹，更改站点配置文件 找到theme：xxx 改为theme：yilia hexo clean hexo g hexo s 4000端口即可看到更改 hexo d 推到远端，mangosteen96.github.io 可以看到（主题更换可能要等一下下） Hexo博客导入图片方法1 站点配置文件_config.yml 里的post_asset_folder:这个选项设置为true npm install hexo-asset-image --save 安装一个可以上传本地图片的插件 安装插件后hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片复制到xxxx这个文件夹中，在xxxx.md中按照markdown的格式引入图片(此处为了不被识别为图片就先这么写了)： 感叹号+[]括号内可输入替代文字+(xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看，html标签内的语句是img src=”2017/02/26/xxxx/图片名.jpg”，必须要有日期。 其它方法 本地source中建立img文件夹&lt;&gt; 内 img src=”img/图片名.jpg（此方法未详细试验） 图床 所遇问题 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理链接时出现路径错误，没有年月，无法显示图片。可直接安装已经修改过得插件npm install https://github.com/7ym0n/hexo-asset-image --save 由于title中有一些符号（比如（）、–等）用hexo new命令创建博客时，出现文件名称与文章title不符的情况在博客中没有图片时，并不产生影响，但当要插入图片时，在路径正确的情况下，依然显示不出图片解决办法暂时只是把 1.文件夹名称、2.md文件名称、3.title 这三者统一]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
