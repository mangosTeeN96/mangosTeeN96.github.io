<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java_Collection集合、泛型]]></title>
    <url>%2F2019%2F08%2F29%2FJava_Collection%E9%9B%86%E5%90%88%E3%80%81%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[第一章 Collection集合前面使用过集合ArrayList 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组都是容器，它们的区别： 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map 1.1 集合框架Collection： 单列集合类的根接口，用于存储一系列符合某种规则的元素。它有两个重要的子接口，分别是java.util.List和java.util.Set。 List的特点是元素有序、元素可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList。 Set的特点是元素无序，而且不可重复。Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.2 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式，接口指向实现类 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); //打印coll为[]，重写了toString方法 // 使用方法 // 添加功能 boolean add(String s) coll.add("小李广"); coll.add("扫地僧"); coll.add("石破天"); //无需接受返回值，返回值一般为true System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 扫地僧 是否在集合中"+coll.contains("扫地僧")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除石破天："+coll.remove("石破天")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。 Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 迭代： 即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 获取迭代器： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 Iterator接口的常用方法： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 迭代器的使用步骤(重点): 使用集合中的方法iterator()获取迭代器的实现类对象,使用Iterator接口接收(多态) 使用Iterator接口中的方法hasNext判断还有没有下一个元素 使用Iterator接口中的方法next取出集合中的下一个元素 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("串串星人"); coll.add("吐槽星人"); coll.add("汪星人"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 迭代器的实现原理 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.2 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("小河神"); coll.add("老河神"); coll.add("神婆"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述集合中可以存放任意对象，只要把对象存储集合后，他们都会被提升成Object类型。当我们取出每一个对象，并且进行相应的操作时，必须采用类型转换。 创建集合对象,不使用泛型 好处:集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据 弊端:不安全,会引发异常 12345678910111213141516171819202122 private static void show01() &#123; ArrayList list = new ArrayList(); list.add("abc"); list.add(1); //使用迭代器遍历list集合 //获取迭代器 Iterator it = list.iterator(); //使用迭代器中的方法hasNext和next遍历集合 while(it.hasNext())&#123; //取出元素也是Object类型 Object obj = it.next(); System.out.println(obj); //想要使用String类特有的方法,length获取字符串的长度;不能使用 多态 Object obj = "abc"; //需要向下转型 //会抛出ClassCastException类型转换异常,不能把Integer类型转换为String类型 String s = (String)obj; System.out.println(s.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时ClassCastException。Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处 创建集合对象,使用泛型 好处: 1.避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型2.把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错) 弊端:泛型是什么类型,只能存储什么类型的数 1234567891011121314151617public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用在集合中会大量使用到泛型 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型的数据类型 在创建对象的时候确定泛型的数据类型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 自定义泛型类： 定义： 123456789101112public class MyGenericClass&lt;MVP&gt; &#123; //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) &#123; this.mvp = mvp; &#125; public MVP getMVP() &#123; return mvp; &#125;&#125; 使用: 123456789101112131415public class GenericClassDemo &#123; public static void main(String[] args) &#123; // 创建一个泛型为String的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用setMVP my.setMVP("大胡子登登"); // 调用getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为Integer的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); &#125;&#125; 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 1234567891011public class GenericMethod &#123; //定义一个含有泛型的方法 public &lt;M&gt; void method01(M m)&#123; System.out.println(m); &#125; //定义一个含有泛型的静态方法 public static &lt;S&gt; void method02(S s)&#123; System.out.println(s); &#125;&#125; 使用格式：调用方法时，确定泛型的类型 123456789101112131415161718192021public class Demo03GenericMethod &#123; public static void main(String[] args) &#123; //创建GenericMethod对象 GenericMethod gm = new GenericMethod(); /* 调用含有泛型的方法method01 传递什么类型,泛型就是什么类型 */ gm.method01(10); gm.method01("abc"); gm.method01(8.8); gm.method01(true); gm.method02("静态方法,不建议创建对象使用"); //静态方法,通过类名.方法名(参数)可以直接使用 GenericMethod.method02("静态方法"); GenericMethod.method02(1); &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式： 定义类时确定泛型的类型 定义接口的实现类,实现接口,指定接口的泛型 实现类： 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型，然后main程序按照string正常使用。 始终不确定泛型的类型，直到创建对象时，确定泛型的类型 接口使用什么泛型,实现类就使用什么泛型,类跟着接口走就相当于定义了一个含有泛型的类,创建对象的时候确定泛型的类型 实现类： 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; main，创建对象，确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add("aa"); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符：不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 举例理解使用即可： 1234567891011121314151617public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list1); getElement(list2);&#125;public static void getElement((ArrayList&lt;?&gt; list)&#123; //使用迭代器遍历集合 Iterator&lt;?&gt; it = list.iterator(); while(it.hasNext())&#123; //it.next()方法,取出的元素是Object,可以接收任意的数据类型 Object o = it.next(); System.out.println(o); &#125;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类其中类与类之间的继承关系:Integer extends Number extends ObjectString extends Objec 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itheima.demo04.Test;import java.util.ArrayList;import java.util.Collections;/* 斗地主综合案例: 1.准备牌 2.洗牌 3.发牌 4.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //定义一个存储54张牌的ArrayList集合,泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组,一个数组存储牌的花色,一个数组存储牌的序号 String[] colors = &#123;"♠","♥","♣","♦"&#125;; String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //先把大王和小王存储到poker集合中 poker.add("大王"); poker.add("小王"); //循环嵌套遍历两个数组,组装52张牌 for(String number : numbers)&#123; for (String color : colors) &#123; //System.out.println(color+number); //把组装好的牌存储到poker集合中 poker.add(color+number); &#125; &#125; //System.out.println(poker); /* 2.洗牌 使用集合的工具类Collections中的方法 static void shuffle(List&lt;?&gt; list) 使用默认随机源对指定列表进行置换。 */ Collections.shuffle(poker); //System.out.println(poker); /* 3.发牌 */ //定义4个集合,存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; diPai = new ArrayList&lt;&gt;(); /* 遍历poker集合,获取每一张牌 使用poker集合的索引%3给3个玩家轮流发牌 剩余3张牌给底牌 注意: 先判断底牌(i&gt;=51),否则牌就发没了 */ for (int i = 0; i &lt; poker.size() ; i++) &#123; //获取每一张牌 String p = poker.get(i); //轮流发牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(p); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(p); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(p); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(p); &#125; &#125; //4.看牌 System.out.println("刘德华:"+player01); System.out.println("周润发:"+player02); System.out.println("周星驰:"+player03); System.out.println("底牌:"+diPai); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_Object类、常用API]]></title>
    <url>%2F2019%2F08%2F27%2FJava_Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[第一章 Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类,那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。 1.1 toString方法 public String toString()：返回该对象的字符串表示： 类型+@+内存地址值 。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键^+N，点击toString()选项。选择需要包含的成员变量并确定。 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.2 equals方法 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 equals方法源码: 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 参数: Object obj:可以传递任意的对象 == 比较运算符,返回的是一个布尔值 true false 基本数据类型:比较的是值 引用数据类型:比价的是两个对象的地址值 12345678910public static void main(String[] args) &#123; Person p1 = new Person("迪丽热巴",18); Person p2 = new Person("古力娜扎",19); System.out.println("p1:"+p1);//p1:com.itheima.demo01.Object.Person@58ceff1 System.out.println("p2:"+p2);//p2:com.itheima.demo01.Object.Person@7c30a502 boolean b = p1.equals(p1); System.out.println(b); &#125; 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。 问题:隐含着一个多态多态的弊端:无法使用子类特有的内容(属性和方法)Object obj = p2 = new Person(“古力娜扎”,19);解决:可以使用向下转型(强转)把obj类型转换为Person IDEA中，可以快捷键^ + N，并选择equals() and hashCode()进行自动代码生成。 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; tips：Object类当中的hashCode等其他方法，今后学习。 1.3 Objects类在IDEA自动重写equals代码中，使用到了java.util.Objects类 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成 这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的） 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 源码： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 第二章 日期时间类2.1 Date类 java.util.Date类 表示特定的瞬间，精确到毫秒 毫秒:千分之一秒 1000毫秒=1秒 特定的瞬间:一个时间点,一刹那时间2088-08-08 09:55:33:333 瞬间 毫秒值的作用:&emsp;可以对时间和日期进行计算 2099-01-03 到 2088-01-01 中间一共有多少天可以日期转换为毫秒进行计算,计算完毕,在把毫秒转换为日期 把日期转换为毫秒: 当前的日期:2088-01-01 时间原点(0毫秒):1970 年 1 月 1 日 00:00:00(英国格林威治) 就是计算当前日期到时间原点之间一共经历了多少毫秒 123public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis());//获取当前系统时间到1970 年 1 月 1 日 00:00:00经历了多少毫秒&#125; 注意:中国属于东八区,会把时间增加8个小时–1970 年 1 月 1 日 08:00:00 把毫秒转换为日期: 1 天 = 24 × 60 × 60 = 86400 秒 = 86400 x 1000 = 86400000毫秒 构造方法 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910111213141516import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; /* Date类的空参数构造方法 Date() 获取当前系统的日期和时间 */ System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 /* Date类的带参数构造方法 Date(long date) :传递毫秒值,把毫秒值转换为Date日期 */ System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用成员方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值相当于System.currentTimeMillis()方法 12345private static void demo03() &#123; Date date = new Date(); long time = date.getTime(); System.out.println(time);//3742777636267&#125; 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法DateFormat为抽象类，不能直接使用，需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //字母不能改变，连接符号可以改变 &#125; &#125; 常用成员方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = "2018年12月11日"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 使用Scanner类中的方法next,获取出生日期 使用DateFormat类中的方法parse,把字符串的出生日期,解析为Date格式的出生日期 把Date格式的出生日期转换为毫秒值 获取当前的日期,转换为毫秒值 使用当前日期的毫秒值-出生日期的毫秒值 把毫秒差值转换为天(s/1000/60/60/24) 代码实现： 123456789101112131415161718192021public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); // 获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); // 将字符串日期,转成Date对象 // 创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // 调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); // 获取今天的日期对象 Date todayDate = new Date(); // 将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if (secone &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else &#123; System.out.println(secone/1000/60/60/24); &#125;&#125; 2.4 Calendar类java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。 日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用成员方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH / DATE 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 123456789101112131415import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + "年" + month + "月" + dayOfMonth + "日");//2019年7月14日 &#125; &#125; 12345678910111213import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); //年月日的输出int设置省略了 System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2020年1月17日 //同时设置年月日,可以使用set的重载方法 cal.set(8888,8,8); &#125;&#125; add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 12345678910111213import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + "年" + month + "月" + dayOfMonth + "日"); // 2015年1月18日; &#125;&#125; getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 日历转换为日期 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习验证for循环打印数字1-9999所需要使用的时间（毫秒） 12345678910public class SystemTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println("共耗时毫秒：" + (end - start)); &#125;&#125; 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = "Hello"; s += "World"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWorld 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容，可以提高字符串的效率。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器，其初始容量为 16 个字符。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder("itcast"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 1234567891011121314151617181920212223242526public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append("hello"); //对比一下 System.out.println("builder:"+builder);//hello System.out.println("builder2:"+builder2);//hello System.out.println(builder == builder2); //true，地址相同 // 可以添加 任何类型 // 使用append方法无需接收返回值 builder.append("hello"); builder.append("world"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append("hello").append("world").append(true).append(100); System.out.println("builder:"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder("Hello").append("World").append("Java"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类（本部分前面提到过）Java提供了两个类型系统，基本类型与引用类型。 使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能。 如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.1 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—&gt;包装对象 12Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 1int num = i.intValue(); 5.2 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式 基本类型直接与””相连接即可；如：34+””(简单常用) 包装类的静态方法toString(参数),不是Object类的toString() 重载static String toString(int i) 返回一个表示指定整数的 String 对象。 String类的静态方法valueOf(参数)static String valueOf(int i) 返回 int 参数的字符串表示形式 123456789int i1 = 100;String s1 = i1+"";System.out.println(s1+200);//100200String s2 = Integer.toString(100);System.out.println(s2+200);//100200String s3 = String.valueOf(100);System.out.println(s3+200);//10020 String转换成对应的基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：short基本类型。 public static int parseInt(String s)：int基本类型。 public static long parseLong(String s)：long基本类型。 public static float parseFloat(String s)：float基本类型。 public static double parseDouble(String s)：double基本类型。 public static boolean parseBoolean(String s)：boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt("100"); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>常用API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim基本命令]]></title>
    <url>%2F2019%2F08%2F25%2FVim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vim命令 代码操作 命令 作用 yy 复制 光标所在的这一行 4yy 复制 光标所在的行开始向下的4行 p 粘贴 dd 剪切 光标所在行 4dd 向下4行 D 从光标开始剪切，一直到行末 d0 从光标开始剪切，一直到行首 dw 删除这个单词 x 删除当前光标，每次只删除一个 X 删除当前光标前面的那个，每次只删除一个 u 撤销刚刚操作(可多次） ctrl+r 反撤销 . 重复执行上一次命令 定位操作 命令 作用 h，j，k，l 命令下的光标 左，下，上，右 H，M，L 当前屏幕的 上方，中间，下方 ctrl+f 向下翻一页代码 ctrl+b 向上翻一页代码 20G 快速定位到第20行代码 G 快速回到整个代码的最后一行 gg 快速回到整个代码的第一行 w 向后跳一个单词的长度，即下一个单词的开始 b 向前 移动替换 命令 作用 { 按段移动，上移 } 按段移动，下移 v 选中（配合上下左右可以选中一片）光标在哪选到哪 V 选中，光标所在行都选中 &gt; 整体向右移动代码 &lt; 向左 r 替换当前字符(输入r后输入替换后的字符） R 替换当前行光标后的字符 查找替换、保存退出 命令 作用 / 查找（搜不存在的可去掉颜色） n下一个搜索到的 N上一个 %s///g(：末行模式下） /被替换/替换/ 11,16s///g 替换11到16行 vim 4.py vim下 创建or进入4.py vi (似乎更方便，再次进入的时候） ：w （末行模式） 保存 ：q 直接退出（没保存的话会提示） ：q！ 不保存退出 ：wq或者x 保存并退出 shift+zz 相当于末行模式的wq ctrl+N查看已经定义的变量]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux以及命令.md]]></title>
    <url>%2F2019%2F08%2F25%2FLinux%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux操作系统命令： 命令 作用 command + 调大字体 - 调小 ls 当前路径下所有文件夹和名字 pwd 目前处在的路径，第一个/为根目录 cd 切换路径 clear 清屏 命令基本格式:命令 选项 参数选项的格式为:-选项 命令 作用 ls -a 创建的文件的名字以.开头，则为隐藏文件，ls命令看不见。此时运行ls -a，则能看见 ls -l 以列表方式显示 ls -l -h 显示列表的时候会给数字显示一个合适的单位 可以ls -a -l -h一起使用，顺序无所谓，ls -alh 查看帮助文档 命令 作用 命令 –help man 命令 （进入后不能输入命令，按q退出，f向下翻一屏，b向上） man 2 命令 查看c语言下的帮助文档 history 查看历史命令 对文件（夹）的操作 命令 作用 tab键 文件名补全 touch 新建文件 mkdir 创建文件夹 rmdir 删除文件夹（非空删除不了） open 打开并编辑文件 cat 查看文件 cat 123.txt 234.txt 会同时显示两个文件的内容 cat 123.txt 234.txt &gt; xxx.txt 合并两个文件的内容到一个文件xxx.txt more 查看文件（适合大文件，不会全显示出来，显示一页，按f键翻页，q退出) 可以结合ls命令：ls -ahl /bin ` rm 删除命令 可以删除非空文件夹：rm -r 文件夹名。不想一直询问，直接删除-rf mv 123.txt 789.txt 重命名，原文件名 新文件名 mv 789.txt A 剪切文件到A文件夹 cp 复制粘贴 不让copy文件夹，加-r，遇到文件夹不让动的，多数可以加-r解决（-r：递归） 文件中查找操作 命令 作用 grep “s” xxx.txt 在xxx.txt中查找s grep -n “s” xxx.txt 搜索显示前面会带有在哪一行 grep -n “s” xxx.txt 查找不包含s的 grep “^s” xxx.txt 查找以s开头的 grep “s$” xxx.txt 查找以s结尾的 通配符 命令 作用 ls 2* 只查看以2开头的文件 ls *.txt 只查看.txt文件 *代表的位数可以为0到n位（不只可以与ls合用，与rm等也可以一起） ls 2？ 查看以2开头且只有两位 几个？则几位 ls 2？3 .txt ls 2[12345]3.txt 查看213到253之间到文件（可以写成1-5） 重定向 命令 作用 ls -ahl &gt; xxx.txt 创建了xxx.txt文件，并且把命令ls -ahl应该显示的内容存放进去 &gt;&gt; 追加，会在原来的末尾把当前内容追加进去 如果只&gt;，会把原来的删除。如果原来没有这个文件，&gt;&gt;也会创建文件。 路径 相对路径 从当前路径算起 绝对路径 从根目录算起 cd时不知道下一层文件夹名字，可以按两次tab键，会把能补全的文件夹名字全显示出来 cd A 跳转到（当前路径的）A文件夹 cd ./A 跳转到当前路径的A文件夹 cd .. 跳转到上一层文件夹 cd ../.. 上上层 跳转文件距离根目录近，用绝对路径，距离当前文件近，用相对路径。 cd - 跳转到上一次操作所在路径（最多只能记忆一次，再次使用就跳回来了） cd ~ 回到家目录 链接 命令 作用 ln -s 789.txt 789-softlink.txt 创建软链接文件（快捷方式） 原文件删除，软链接文件没有用了 ln 789.txt 789-hardlink.txt 创建硬链接文件（快捷方式） 硬链接文件相当于给原文件重新起名，原文件删除，硬链接文件数据仍然在。 如果写完一行命令不想执行，按control+C，则直接换行。 文件查找操作 命令 作用 find 在一个路径里找东西 find / -name “” 在根目录里按名字找，名字里带双引号里的 如果有没有权限的，在find前加sudo find ./ 在当前目录查找 按照文件名查找 find / -name httpd.conf 在根目录下查找文件httpd.conf，表示在整个硬盘查找 find /etc -name httpd.conf 在/etc目录下文件httpd.conf find /etc -name ‘srm‘ 使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 find . -name ‘srm*’ 表示当前目录下查找文件名开头是字符串‘srm’的文件 -size 按大小找 2M 大小等于 +2M 大小大于2M的文件 归档管理 tar tar -cvf test.tar *.py 将*.py的文件打包为test.tar tar -xvf test.tar 将test.tar解压到当前文件夹，压缩包不删 打包不压缩 tar -zcvf test.tar.gz *.py 压缩 tar -zxvf 解压缩 tar -jcvf test.tar.bz2 *.py 另一种压缩方式 tar -jxvf 解 tar 在命令后面加-C，加指定路径 解压到指定路径 一般用上面这两种压缩 zip test.zip *.py 压缩为zip文件（压缩效果不好） unzip test.zip 解 一些其它命令 命令 作用 links … 打开网页 which 查看用的命令在哪个路径下的文件 cal 日历 cal -y 2008 date 日期时间 ps aux ; top 查看当前运行情况（任务管理器） kill PID码 结束那个进程 kill后加-9 强制结束 reboot 重启 shutdown -h now 立刻关机 +10 10分钟后关机 20:20 df df -h 查看硬盘使用情况 du -h 当前路径使用情况 ifconfig 查看当前电脑上的网卡信息 ping +IP地址 测试远程电脑联通情况，能否通信 useradd shuaige -m 添加用户 sudo（没有权限） passwd shuaige 更改密码 su shuaige 切换账户 exit 退出 whoami 当前用户是谁 userdel shuaige 删除账户 userdel -r shuaige 同时删除家目录 sudo 拥有超级管理员的权限 sudo -s 变成超级管理员(root) groupadd shuaige 创建组 groupdel 删除 cat /etc/group 查看所有组 ls -alf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_继承与多态]]></title>
    <url>%2F2019%2F07%2F09%2FJava_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一、继承多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那一个类称为父类、超类(superclass)或者基类。 继承描述的是事物之间的所属关系，这种关系是: is-a 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 定义： 继承:就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 1.1 格式123456public class 父类 &#123; ...&#125;public class 子类 extends 父类 &#123; ...&#125; 1.2 成员变量访问在父子类的继承关系当中，如果成员变量重名，则： 直接通过子类对象访问成员变量： 等号左边是谁，就优先用谁，没有则向上找。 - 间接通过成员方法访问成员变量： - 该方法属于谁，就优先用谁，没有则向上找 三种变量写法整理： 局部变量：&emsp;&emsp;&emsp; 直接写成员变量名 本类的成员变量： this.成员变量名 父类的成员变量： super.成员变量 父类： 123public class Fu &#123; int num = 10;&#125; 子类： 1234567891011public class Zi extends Fu &#123; int num = 20; public void method() &#123; int num = 30; System.out.println(num); // 30，局部变量 System.out.println(this.num); // 20，本类的成员变量 System.out.println(super.num); // 10，父类的成员变量 &#125;&#125; 1.3 成员方法 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。 注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的 重写（覆盖重写）– 成员方法重名方法重写 :子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 特点：创建的是子类对象，则优先用子类方法 注意事项： 必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。 子类方法的返回值必须【小于等于】父类方法的返回值范围。 小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。 子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; (default) &gt; private备注：(default)不是关键字default，而是什么都不写，留空。 (其实多数情况这些范围权限都是相等的) 应用： 12345public class Phone &#123; public void show() &#123; System.out.println("显示号码"); &#125;&#125; 12345678910public class NewPhone extends Phone &#123; @Override public void show() &#123; super.show(); // 把父类的show方法拿过来重复利用 // 自己子类再来添加更多内容 System.out.println("显示姓名"); System.out.println("显示头像"); &#125;&#125; 1.4构造方法继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 12345678public class Fu &#123; public Fu() &#123; System.out.println("父类无参构造"); &#125; public Fu(int num) &#123; System.out.println("父类有参构造！"); &#125;&#125; 123456789101112public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println("子类构造方法！"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125; 总结：子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 super关键字用法总结： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 this关键字用法总结： super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意：A. this(…)调用也必须是构造方法的第一个语句，唯一一个。B. super和this两种构造调用，不能同时使用 super与this的内存图: 1.5 继承的特点 java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 Java支持多层继承(继承体系)。 子类和父类是一种相对的概念。 二、抽象类没有方法主体的方法称为抽象方法包含抽象方法的类就是抽象类 抽象方法概念图： 2.1 格式抽象类与抽象方法格式： 123456public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat();&#125; 2.2 使用使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 注意事项： 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。理解:子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类。理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 2.3 案例案例分析： 用户父类: 123456789101112131415161718192021222324252627282930public class User &#123; private String name; // 姓名 private int money; // 余额，也就是当前用户拥有的钱数 public User() &#123; &#125; public User(String name, int money) &#123; this.name = name; this.money = money; &#125; // 展示一下当前用户有多少钱 public void show() &#123; System.out.println("我叫：" + name + "，我有多少钱：" + money); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getMoney() &#123; return money; &#125; public void setMoney(int money) &#123; this.money = money; &#125;&#125; 群主子类： 123456789101112131415161718192021222324252627282930313233343536373839public class Manager extends User &#123; public Manager() &#123; &#125; public Manager(String name, int money) &#123; super(name, money); &#125; public ArrayList&lt;Integer&gt; send(int totalMoney, int count) &#123; // 首先需要一个集合，用来存储若干个红包的金额 ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;(); // 看一下群主自己有多少钱 int leftMoney = super.getMoney(); // 群主当前余额 if (totalMoney &gt; leftMoney) &#123; System.out.println("余额不足"); return redList; // 返回空集合 &#125; // 扣钱，其实就是重新设置余额 super.setMoney(leftMoney - totalMoney); // 发红包需要平均拆分成为count份 int avg = totalMoney / count; int mod = totalMoney % count; // 余数，也就是甩下的零头 // 除不开的零头，包在最后一个红包当中 // 下面把红包一个一个放到集合当中 for (int i = 0; i &lt; count - 1; i++) &#123; redList.add(avg); &#125; // 最后一个红包 int last = avg + mod; redList.add(last); return redList; &#125;&#125; 群成员子类： 1234567891011121314151617181920public class Member extends User &#123; public Member() &#123; &#125; public Member(String name, int money) &#123; super(name, money); &#125; public void receive(ArrayList&lt;Integer&gt; list) &#123; // 从多个红包当中随便抽取一个，给我自己。 // 随机获取一个集合当中的索引编号 int index = new Random().nextInt(list.size()); // 根据索引，从集合当中删除，并且得到被删除的红包，给我自己 int delta = list.remove(index); // 当前成员自己本来有多少钱： int money = super.getMoney(); // 加法，并且重新设置回去 super.setMoney(money + delta); &#125;&#125; 发红包： 123456789101112131415161718192021222324252627282930public class MainRedPacket &#123; public static void main(String[] args) &#123; Manager manager = new Manager("群主", 100); Member one = new Member("成员A", 0); Member two = new Member("成员B", 0); Member three = new Member("成员C", 0); manager.show(); // 100 one.show(); // 0 two.show(); // 0 three.show(); // 0 System.out.println("==============="); // 群主总共发20块钱，分成3个红包 ArrayList&lt;Integer&gt; redList = manager.send(20, 3); // 三个普通成员收红包 one.receive(redList); two.receive(redList); three.receive(redList); manager.show(); // 100-20=80 // 6、6、8，随机分给三个人 one.show(); two.show(); three.show(); &#125;&#125; 三、接口接口就是多个类的公共规范。 接口，是Java语言中一种引用类型，是方法的集合。如果说类的内部封装了成员变量、构造方法和成员方法，那么，接口的内部主要就是封装了方法，包含抽象方法(JDK 7及以前)，默认方法和静态方法(JDK 8)，私有方法 (JDK 9)。 3.1 格式 public interface 接口名称 {&emsp;&emsp;&emsp;&emsp;// 抽象方法&emsp;&emsp;&emsp;&emsp;// 默认方法&emsp;&emsp;&emsp;&emsp;// 静态方法&emsp;&emsp;&emsp;&emsp;// 私有方法} 3.2 实现（接口的使用）实现格式： public class 实现类名称 implements 接口名称 {&emsp;&emsp;&emsp;&emsp;// …} 接口不能直接使用，必须有一个“实现类”来“实现”该接口。 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号。 创建实现类的对象，进行使用。 接口 MyInterfaceAbstract 1234public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs()&#125; 实现类 MyInterfaceAbstractImpl 123456public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123; @Override public void methodAbs() &#123; System.out.println("这是一个方法！"); &#125;&#125; 接口实现 1234567891011public class Demo01Interface &#123; public static void main(String[] args) &#123; // 错误写法！不能直接new接口对象使用。// MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs() &#125;&#125; 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。 3.3 内部封装的方法抽象方法格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。（刚学，不推荐省略） 方法的三要素，可以随意定义 默认方法可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 格式： public default 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 备注：接口当中的默认方法，可以解决接口升级的问题 接口 1234567891011121314public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println("这是新添加的默认方法"); &#125;&#125; 实现类A（未重写） 123456public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println("实现了抽象方法，AAA"); &#125;&#125; 实现类B（重写） 1234567891011public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println("实现了抽象方法，BBB"); &#125; @Override public void methodDefault() &#123; System.out.println("实现类B覆盖重写了接口的默认方法"); &#125;&#125; 主代码 1234567891011121314151617public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println("=========="); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125; 静态方法格式： public static 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 只能使用接口名调用(直接在主代码中调用) 不可以通过实现类的类名或者实现类的对象调用 调用格式： 接口名称.静态方法名(参数); 私有方法问题描述：我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。 普通私有方法 解决多个默认方法之间重复代码问题格式： private 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 12345678910111213141516171819public interface MyInterfacePrivateA &#123; public default void methodDefault1() &#123; System.out.println("默认方法1"); methodCommon(); &#125; public default void methodDefault2() &#123; System.out.println("默认方法2"); methodCommon(); &#125; private void methodCommon() &#123; System.out.println("AAA"); System.out.println("BBB"); System.out.println("CCC"); &#125;&#125; 静态私有方法 解决多个静态方法之间重复代码问题格式： private static 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 3.4 常量接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰 从效果上看，这其实就是接口的常量 格式： public static final 数据类型 常量名称 = 数据值; 接口 123456public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 主代码 12345678public class Demo05Interface &#123; public static void main(String[] args) &#123; // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); &#125;&#125; 一旦使用final关键字进行修饰，说明不可改变。 注意事项： 接口当中的常量，可以省略public static final不写也一样。 接口当中的常量，必须赋值，不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 3.5 接口使用注意事项 接口是没有静态代码块或者构造方法的。 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式： public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {&emsp;&emsp;&emsp;&emsp;// 覆盖重写所有抽象方法} 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 一个类如果它的直接父类当中的方法，和接口当中的默认方法产生了冲突（重名），优先用父类当中的方法。 接口A： 1234567891011public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodabs(); public default void methodDefault()&#123; System.out.println("默认方法AAA"); &#125;&#125; 接口B： 12345678910public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodabs(); public default void methodDefault()&#123; System.out.println("默认方法BBB"); &#125;&#125; 实现类： 12345678910111213141516171819202122public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA, MyInterfaceB &#123; @Override public void methodA() &#123; System.out.println("覆盖重写了A方法"); &#125; @Override public void methodB() &#123; System.out.println("覆盖重写了B方法"); &#125; @Override public void methodAbs() &#123; System.out.println("覆盖重写了AB接口都有的抽象方法"); &#125; @Override public void methodDefault() &#123; System.out.println("对多个接口当中冲突的默认方法进行了覆盖重写"); &#125;&#125; 3.6 接口的多继承 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似 接口的继承使用 extends 关键字，子接口继承父接口的方法 如果父接口中的默认方法有重名的，那么子接口需要重写一次 四、多态多态是继封装、继承之后，面向对象的第三大特性。 多态: 是指同一行为，具有多个不同表现形式。 前提： 继承或者实现 方法的重写(意义体现:不重写，无意义) 父类引用指向子类对象 4.1 格式 父类名称 对象名 = new 子类名称(); 或者： 接口名称 对象名 = new 实现类名称(); 当使用多态方式调用方法时，首先检查父类中是否有该方法 如果没有，则编译错误 如果有，执行的是子类重写后方法 父类： 123public abstract class Animal &#123; public abstract void eat();&#125; 子类： 12345class Cat extends Animal &#123; public void eat() &#123; System.out.println("吃鱼"); &#125;&#125; 测试类 12345678public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Animal a = new Cat(); // 调用的是 Cat 的 eat a.eat(); &#125; &#125; 4.2 成员变量多态中成员变量的使用特点，与之前的笔记中一样。 访问成员变量的两种方式(Fu obj = new Zi())： 直接通过对象名称（obj.num)访问成员变量：看等号左边是谁，优先用谁，没有则向上找。(成员变量不能覆盖重写) 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 4.3 成员方法多态中，成员方法的访问规则(也和以前一样)：&emsp;&emsp;&emsp;看new的是谁，就优先用谁，没有则向上找。 特殊之处：编译看左边，运行看右边 对比一下： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边 4.4 使用多态的好处 多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 4.5 引用类型转型多态的转型分为向上转型与向下转型两种: 向上转型 当父类引用指向一个子类对象(接口、实现类)时，便是向上转型。 多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 格式（即多态）： 父类类型 变量名 = new 子类类型();如： Animal animal = new Cat(); 向上转型一定是安全的，没有问题的，正确的 但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 解决方案：用对象的向下转型【还原】 向下转型 一个已经向上转型的子类对象（实现类），将父类（接口）引用转为子类引用（还原），可以使用强制类型转换的格式，便是向下转型 格式： 子类类型 变量名 = (子类类型) 父类变量名;如：Cat cat = (Cat) animal instanceof关键字如何才能知道一个父类引用的对象，本来是什么子类？ 格式： 对象 instanceof 类名称 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例 1234567891011121314151617public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125;&#125; 4.5 接口多态综合案例笔记本电脑(laptop)通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口， 但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。 定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守 USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 分析：进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要实现USB接口，并具备点击的方法 键盘类，要实现USB接口，具备敲击的方法 USB: 1234567public interface USB &#123; public abstract void open(); // 打开设备 public abstract void close(); // 关闭设备&#125; 笔记本： 123456789101112131415161718192021222324public class Computer &#123; public void powerOn() &#123; System.out.println("笔记本电脑开机"); &#125; public void powerOff() &#123; System.out.println("笔记本电脑关机"); &#125; // 使用USB设备的方法，使用接口作为方法的参数 public void useDevice(USB usb) &#123; usb.open(); // 打开设备 if (usb instanceof Mouse) &#123; // 一定要先判断 Mouse mouse = (Mouse) usb; // 向下转型 mouse.click(); &#125; else if (usb instanceof Keyboard) &#123; // 先判断 Keyboard keyboard = (Keyboard) usb; // 向下转型 keyboard.type(); &#125; usb.close(); // 关闭设备 &#125;&#125; 鼠标： 12345678910111213141516// 鼠标就是一个USB设备public class Mouse implements USB &#123; @Override public void open() &#123; System.out.println("打开鼠标"); &#125; @Override public void close() &#123; System.out.println("关闭鼠标"); &#125; public void click() &#123; System.out.println("鼠标点击"); &#125;&#125; 键盘： 12345678910111213141516// 键盘就是一个USB设备public class Keyboard implements USB &#123; @Override public void open() &#123; System.out.println("打开键盘"); &#125; @Override public void close() &#123; System.out.println("关闭键盘"); &#125; public void type() &#123; System.out.println("键盘输入"); &#125;&#125; Main代码: 123456789101112131415161718192021222324252627public class DemoMain &#123; public static void main(String[] args) &#123; // 首先创建一个笔记本电脑 Computer computer = new Computer(); computer.powerOn(); // 准备一个鼠标，供电脑使用// Mouse mouse = new Mouse(); // 首先进行向上转型 USB usbMouse = new Mouse(); // 多态写法 // 参数是USB类型，我正好传递进去的就是USB鼠标 computer.useDevice(usbMouse); // 创建一个USB键盘 Keyboard keyboard = new Keyboard(); // 没有使用多态写法 // 方法参数是USB类型，传递进去的是实现类对象 computer.useDevice(keyboard); // 正确写法！也发生了向上转型 // 使用子类对象，匿名对象，也可以// computer.useDevice(new Keyboard()); // 也是正确写法 computer.powerOff(); System.out.println("=================="); &#125;&#125; 五、final关键字final: 不可改变。可以用于修饰类、方法和变量 类:被修饰的类，不能被继承 方法:被修饰的方法，不能被重写 变量:被修饰的变量，不能被重新赋值 5.1 修饰类格式： public final class 类名{&emsp;&emsp;&emsp;&emsp;//} 当前这个类不能有任何的子类 注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没子类） 5.2 修饰方法格式： 修饰符 final 返回值类型 方法名(参数列表){&emsp;&emsp;&emsp;&emsp;//方法体} 例如：public final void method(){//} 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 5.3 局部变量 基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 //未使用final Student stu1 = new Student("赵丽颖"); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student("霍建华"); System.out.println(stu1.getName()); // 霍建华 //使用final final Student stu2 = new Student("高圆圆"); // 错误写法！final的引用类型变量，其中的地址不可改变// stu2 = new Student("赵又廷"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName("高圆圆圆圆圆圆"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 &#125; 5.4 成员变量对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。 由于成员变量具有默认值，所以用了final之后必须手动赋值，用了final不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值 1234567891011121314151617181920public class Person &#123; private final String name/* = "鹿晗"*/;//直接赋值 public Person() &#123; name = "关晓彤"; //构造方法赋值 &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;// public void setName(String name) &#123;// this.name = name;// &#125;&#125; 六、内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 分为：成员内部类、局部内部类（包含匿名内部类) 6.1 成员内部类格式 修饰符 class 外部类名称 {&emsp;&emsp;&emsp;&emsp;修饰符 class 内部类名称 {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// …&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;// …} 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 使用成员内部类的方法： 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 类： 1234567891011121314151617181920212223242526272829public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println("心脏跳动：蹦蹦蹦！"); System.out.println("我叫：" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println("外部类的方法"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; main 代码： 1234567891011121314public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println("====================="); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125; 同名变量访问格式： 外部类名称.this.外部类成员变量名 格式举例： 123456789101112131415161718public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 6.2 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类 “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了 格式 修饰符 class 外部类名称 {&emsp;&emsp;&emsp;&emsp;修饰符 返回值类型 外部类方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;class 局部内部类名称 {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// …&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;}} 类： 123456789101112131415class Outer &#123; public void methodOuter() &#123; class Inner &#123; // 局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; main代码： 12345678public class DemoMain &#123; public static void main(String[] args) &#123; Outer obj = new Outer(); obj.methodOuter(); &#125;&#125; 权限修饰符定义一个类的时候，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 final问题局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的。 备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 比如： 12345678910111213public class MyOuter &#123; public void methodOuter() &#123; int num = 10; // 所在方法的局部变量 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125; 6.3 匿名内部类 匿名内部类：是内部类的简化写法。本质：带具体实现的 父类（父接口） 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类 缘由： 以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义实现类 重写接口中的方法 创建子类对象 调用重写后的方法 匿名内部类是对此的简化 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次比如多态情况MyInterface obj = new MyInterfaceImpl();那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类 格式 接口名称 对象名 = new 接口名称() {&emsp;&emsp;&emsp;&emsp;// 覆盖重写所有抽象方法}; 有点类似把实现类的内容拿出来了，把实现类的名字匿了 注意事项 匿名内部类，在创建对象的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，要么重复写两遍，要么就需要使用单独定义的实现类了。 匿名对象，在调用方法的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，要么重复写两遍，要么必须给对象起个名字。 匿名内部类是省略了实现类/子类名称，但是匿名对象是省略了对象名称强调：匿名内部类和匿名对象不是一回事！！！ 6.4 类作为成员变量英雄 123456789101112131415161718192021public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println("年龄为" + age + "的" + name + "用" + weapon.getCode() + "攻击敌方。"); &#125; // getter、setter省略&#125; 武器 12345678910111213public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; // getter、setter省略&#125; main 12345678910111213141516171819public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName("盖伦"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon("AK-47"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 6.5 接口作为成员变量英雄 1234567891011121314151617181920public class Hero &#123; private String name; // 英雄的名称 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println("我叫" + name + "，开始施放技能："); skill.use(); // 调用接口中的抽象方法 System.out.println("施放技能完成。"); &#125; // getter、setter省略&#125; 技能 12345public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; main 123456789101112131415161718192021222324252627282930public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName("艾希"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println("Pia~pia~pia~");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println("Biu~Pia~Biu~Pia~"); &#125; &#125;); hero.attack(); &#125;&#125; 接口还可以做方法的参数和返回值 6.6 案例 发红包（待整理）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>继承与多态</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_常用API]]></title>
    <url>%2F2019%2F07%2F04%2FJava_%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[API: API(Application Programming Interface)，应用程序编程接口Java API是一本程序员的字典是我们使用的类的说明文档 API帮助文档（中文版）：JDK_API_1_6_zh_CN.CHM 引用类: 一般步骤： 导包 import 包路径.类名称; 如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包（比如String），其他的包都需要import语句。 创建 类名称 对象名 = new 类名称(); 使用 对象名.成员方法名() 一、 Scanner类功能： 可以实现键盘输入数据，到程序当中 使用方法： 查看类 java.util.Scanner :该类需要import导入后使用。 查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 查看成员方法 public int nextInt() :将输入信息的下一个标记扫描为一个 int 值。 还有很多，比如next（），String值 使用Scanner类，完成接收键盘录入数据的操作，代码如下: 12345678910111213141516171819import java.util.Scanner;public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println("输入的int数字是：" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println("输入的字符串是：" + str); &#125;&#125; 练习题： 键盘输入三个int数字，然后求出其中的最大值 123456789101112131415161718192021import java.util.Scanner;public class Demo03ScannerMax &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入第一个数字："); int a = sc.nextInt(); System.out.println("请输入第二个数字："); int b = sc.nextInt(); System.out.println("请输入第三个数字："); int c = sc.nextInt(); // 首先得到前两个数字当中的最大值 int temp = a &gt; b ? a : b; int max = temp &gt; c ? temp : c; System.out.println("最大值是：" + max); &#125;&#125; 二、匿名对象匿名对象：没有变量名的对象 格式: new 类名(参数列表); 应用场景: 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。一旦调用两次方法，就是创建了两个对象，造成浪费 匿名对象可以作为方法的参数和返回值 作为参数 1234567891011121314class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125; &#125; 作为返回值 123456789101112131415class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125; 三、Random类Random类：用来生成随机数字 使用步骤： 导包 import java.util.Random; idea可以自动生成 创建 Random r = new Random(); // 小括号当中留空即可 使用 获取一个随机的int数字（范围是int所有范围，有正负两种）： int num = r.nextInt() 获取一个随机的int数字（参数代表了范围，左闭右开区间）： int num = r.nextInt(3) 实际上代表的含义是：[0,3)，也就是0~2 练习： 猜数字小游戏游戏开始，随机生成一个1-100之间的整数 number 。玩家猜测一个数字 guessNumber ，会与 number 作比较，系统提示大了或者小了，直到玩家猜中，游戏结束。 代码： 123456789101112131415161718192021public static void main(String[] args) &#123; Random r = new Random(); int randomNum = r.nextInt(100) + 1; //[1:100] Scanner sc = new Scanner(System.in); while (true)&#123; System.out.println("请输入你猜测的数字："); int guessNum = sc.nextInt(); if (guessNum &gt; randomNum)&#123; System.out.println("太大了，请重试"); &#125;else if (guessNum &lt; randomNum)&#123; System.out.println("太小了，请重试"); &#125;else &#123; System.out.println("恭喜你，猜中啦"); break; &#125; &#125; System.out.println("游戏结束");&#125; 四、ArrayList类对象数组： 数组类型选用对象，例如： 123456789101112public static void main(String[] args) &#123; // 首先创建一个长度为3的数组，里面用来存放Person类型的对象 Person[] array = new Person[3]; Person one = new Person("迪丽热巴", 18); // 将one当中的地址值赋值到数组的0号元素位置 array[0] = one; System.out.println(array[0]); // 地址值 System.out.println(array[0].getName()); // 迪丽热巴&#125; 而数组的长度是固定的，无法适应数据变化的需求 ArrayList类： 数组的长度不可以发生改变但是ArrayList集合的长度是可以随意变化的 4.1 查看类 java.util.ArrayList &lt;E&gt;:需要 import导入 &lt;E&gt; ，表示一种指定的数据类型，叫做泛型。 在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素 ArrayList&lt; String&gt;，ArrayList&lt; Student&gt; 4.2 格式(查看构造方法)基本格式: ArrayList&lt; String&gt; list = new ArrayList&lt; String&gt;(); 在JDK 1.7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。 简化格式: ArrayList&lt; String&gt; list = new ArrayList&lt;&gt;(); 注意：对于ArrayList集合来说，未添加数据直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号：[] 4.3 常用方法及遍历对于元素的操作,基本体现在——增、删、查。常用的方法有: public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（后面会有）来说，add添加动作不一定成功。 public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。 public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。 public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数 举例： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 向集合中添加元素：add boolean success = list.add("柳岩"); System.out.println(list); // [柳岩] System.out.println("添加的动作是否成功：" + success); // true list.add("高圆圆"); list.add("赵又廷"); list.add("李小璐"); list.add("贾乃亮"); System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮] // 从集合中获取元素：get。索引值从0开始 String name = list.get(2); System.out.println("第2号索引位置：" + name); // 赵又廷 // 从集合中删除元素：remove。索引值从0开始。 String whoRemoved = list.remove(3); System.out.println("被删除的人是：" + whoRemoved); // 李小璐 System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 贾乃亮] // 获取集合的长度尺寸，也就是其中元素的个数 int size = list.size(); System.out.println("集合的长度是：" + size); //遍历 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //idea中，list.fori可以自动生成这个循环&#125; 4.4 存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt; int&gt; 不能写，但是存储基本数据类型对应的包装类型是可以的。 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 4.5 练习 生成6个1~33之间的随机整数,添加到集合,并遍历 12345678910111213141516171819public class Test01ArrayList &#123; public static void main(String[] args) &#123; // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对象 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) &#123; int r = random.nextInt(33) + 1; list.add(r); &#125; // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125; &#125; 自定义2个学生对象，添加到集合，并遍历 123456789101112131415161718public class Demo02ArrayListStudent &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); Student one = new Student("洪七公", 20); Student two = new Student("欧阳锋", 21); list.add(one); list.add(two); // 遍历集合 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); System.out.println("姓名：" + stu.getName() + "，年龄" + stu.getAge()); &#125; &#125;&#125; 对象可以作为集合元素 定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用{}扩起集合，使用@分隔每个元素。格式参照 {元素@元素@元素} 1234567891011121314151617181920212223242526public class Demo05ArrayListPrint &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("张三丰"); list.add("宋远桥"); list.add("张无忌"); list.add("李连杰"); System.out.println(list); printArrayList(list); &#125; public static void printArrayList(ArrayList&lt;String&gt; list)&#123; System.out.print("&#123;"); for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); if (i == list.size() - 1)&#123; System.out.println(name + "&#125;"); &#125;else&#123; System.out.print(name + "@"); &#125; &#125; &#125;&#125; 用一个大集合存入20个随机数字(1~100)，然后筛选其中的偶数元素，放到小集合当中。要求使用自定义的方法来实现筛选 1234567891011121314151617181920212223242526272829303132public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(100) + 1; // 1~100 bigList.add(num); &#125; ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println("偶数总共有多少个：" + smallList.size()); for (int i = 0; i &lt; smallList.size(); i++) &#123; System.out.println(smallList.get(i)); &#125; &#125; // 这个方法，接收大集合参数，返回小集合结果 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; // 创建一个小集合，用来装偶数结果 ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bigList.size(); i++) &#123; int num = bigList.get(i); if (num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125; ArrayList类型作为返回值 五、String类java.lang.String类代表字符串程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。） 特点： 字符串的内容永不可变。 正是因为字符串不可改变，所以字符串是可以共享使用的。 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[]字节数组。 5.1 构造方法创建字符串的常见3+1种方式。 三种构造方法： public String()：创建一个空白字符串，不含有任何内容。 public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。 代码： 12345678910 // 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;; String str3 = new String(bytes);//打印输出是'a','b','c' 一种直接创建： String str = &quot;Hello&quot;; // 右边直接用双引号 注意：直接写上双引号，就是字符串对象。 5.2 字符串的常量池 字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中 对于基本类型来说，==是进行 数值 的比较 对于引用类型来说，==是进行 地址值 的比较 1234567891011public static void main(String[] args) &#123; String str1 = "abc"; String str2 = "abc"; char[] charArray = &#123;'a', 'b', 'c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false&#125; 5.3 比较方法==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法： public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。 注意事项： 任何对象都能用Object进行接收。 equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：”abc”.equals(str)不推荐：str.equals(“abc”) public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。 5.4 获取方法 String当中与获取相关的常用方法有： public int length()：获取字符串长度。 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。 public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。） public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 12345678910111213141516171819202122public static void main(String[] args) &#123; // 获取字符串的长度 int length = "asdasfeutrvauevbueyvb".length(); // 拼接字符串 String str1 = "Hello"; String str2 = "World"; String str3 = str1.concat(str2); System.out.println(str3); // HelloWorld，新的字符串 // 获取指定索引位置的单个字符 char ch = "Hello".charAt(1); System.out.println("在1号索引位置的字符是：" + ch); // 查找参数字符串在本来字符串当中出现的第一次索引位置 // 如果根本没有，返回-1值 String original = "HelloWorldHelloWorld"; int index = original.indexOf("llo"); System.out.println("第一次索引值是：" + index); // 2 System.out.println("HelloWorld".indexOf("abc")); // -1&#125; 5.5 截取方法字符串的截取方法： public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边 123456String str1 = "HelloWorld";String str2 = str1.substring(5);System.out.println(str2); // World，新字符串String str3 = str1.substring(4, 7);System.out.println(str3); // oWo 5.6 转换方法String当中与转换相关的常用方法有： public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。 public byte[] getBytes()：获得当前字符串底层的字节数组。 public String replace(CharSequence oldString, CharSequence newString)： 将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。备注：CharSequence意思就是说可以接受字符串类型 1234567891011121314// 转换成为字符数组char[] chars = "Hello".toCharArray();System.out.println(chars[0]); // H// 转换成为字节数组byte[] bytes = "abc".getBytes();for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.println(bytes[i]);&#125;// 字符串的内容替换String str1 = "How do you do?";String str2 = str1.replace("o", "*");System.out.println(str2); // H*w d* y*u d*? 5.7 分割方法分割字符串的方法：public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。 12345String str1 = "aaa,bbb,ccc";String[] array1 = str1.split(",");for (int i = 0; i &lt; array1.length; i++) &#123; System.out.println(array1[i]);&#125; 注意事项：split方法的参数其实是一个“正则表达式”，后面学习。此处注意：如果按照英文句点“.”进行切分，必须写”\.”（两个反斜杠） 六、static关键字static关键字：它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 6.1 类变量（静态变量）（修饰成员变量）当static修饰成员变量时，该变量称为 类变量 该类的每个对象都共享同一个类变量的值 任何对象都可以更改该类变量的值 但也可以在不创建该类的对象的情况下对类变量进行操作。 举例： 每新来一个同学，id自动+1 学生类： 12345678910111213141516171819202122232425262728293031323334353637public class Student &#123; private int id; // 学号 private String name; // 姓名 private int age; // 年龄 static String room; // 所在教室 private static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++ public Student() &#123; this.id = ++idCounter; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 代码： 1234567891011121314151617public class Demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student("郭靖", 19); one.room = "101教室";//后面会说，不推荐这么写 System.out.println("姓名：" + one.getName() + "，年龄：" + one.getAge() + "，教室：" + one.room + "，学号：" + one.getId()); Student two = new Student("黄蓉", 16); System.out.println("姓名：" + two.getName() + "，年龄：" + two.getAge() + "，教室：" + two.room + "，学号：" + two.getId()); &#125;&#125; 输出： 姓名：郭靖，年龄：19，教室：101教室，学号：1姓名：黄蓉，年龄：16，教室：101教室，学号：2 6.2 静态方法（类方法）（修饰成员方法）一旦使用static修饰成员方法，那么这就成为了 静态方法。静态方法不属于对象，而是属于 类 的。 如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。 如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 注意事项： 静态不能直接访问非静态原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容“先人不知道后人，但是后人知道先人。” 静态方法当中不能用this原因：this代表当前对象，通过谁调用的方法，谁就是当前对象 MyClass类： 1234567891011121314151617181920212223242526272829public class MyClass &#123; int num; // 成员变量 static int numStatic; // 静态变量 // 成员方法 public void method() &#123; System.out.println("这是一个成员方法。"); // 成员方法可以访问成员变量 System.out.println(num); // 成员方法可以访问静态变量 System.out.println(numStatic); &#125; // 静态方法 public static void methodStatic() &#123; System.out.println("这是一个静态方法。"); // 静态方法可以访问静态变量 System.out.println(numStatic); // 静态不能直接访问非静态【重点】// System.out.println(num); // 错误写法！ // 静态方法中不能使用this关键字。// System.out.println(this); // 错误写法！ &#125;&#125; 代码： 12345678910111213141516171819202122public class Demo02StaticMethod &#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); // 首先创建对象 // 然后才能使用没有static关键字的内容 obj.method(); // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名” MyClass.methodStatic(); // 正确，推荐 // 对于本类当中的静态方法，可以省略类名称 myMethod(); Demo02StaticMethod.myMethod(); // 完全等效 &#125; public static void myMethod() &#123; System.out.println("自己的方法！"); &#125;&#125; 6.3静态代码块格式： public class 类名称 {&emsp;&emsp;&emsp;&emsp;static {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// 静态代码块的内容&emsp;&emsp;&emsp;&emsp;}} 特点： 当第一次用到本类时，静态代码块执行唯一的一次。 静态内容总是优先于非静态，所以静态代码块比构造方法先执行。 典型用途： 用来一次性地对静态成员变量进行赋值。 Person类： 123456789public class Person &#123; static &#123; System.out.println("静态代码块执行！"); &#125; public Person() &#123; System.out.println("构造方法执行！"); &#125;&#125; 代码： 1234public static void main(String[] args) &#123; Person one = new Person(); Person two = new Person();&#125; 输出结果： 静态代码块执行！构造方法执行！构造方法执行！ 七、Arrays类java.util.Arrays此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 常用方法： public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]） public static void sort(数组)：按照默认升序（从小到大）对 数组 的元素进行排序。 如果是数值，sort默认按照升序从小到大 如果是字符串，sort默认按照字母升序 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习） 123String[] array2 = &#123;"bbb", "aaa", "ccc"&#125;;Arrays.sort(array2);System.out.println(Arrays.toString(array2)); // [aaa, bbb, ccc] 练习： 请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。（涉及到倒序遍历） 1234567891011121314public static void main(String[] args) &#123; String str = "asv76agfqwdfvasdfvjh"; // 如何进行升序排列：sort // 必须是一个数组，才能用Arrays.sort方法 // String --&gt; 数组，用toCharArray char[] chars = str.toCharArray(); Arrays.sort(chars); // 对字符数组进行升序排列 // 需要倒序遍历(此处idea快捷键：chars.forr) for (int i = chars.length - 1; i &gt;= 0; i--) &#123; System.out.println(chars[i]); &#125;&#125; 八、Math类java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 基本运算方法： public static double abs(double num)：获取绝对值。有多种重载。 public static double ceil(double num)：向上取整。 public static double floor(double num)：向下取整。 public static long round(double num)：四舍五入。 Math.PI代表近似的圆周率常量（double） 1234567double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.ceil(3.3); //d2的值为 4.0double d3 = Math.floor(3.3); //d3的值为3.0long d4 = Math.round(5.5); //d4的值为6.0]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>常用API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础_3]]></title>
    <url>%2F2019%2F07%2F04%2FJava%E5%9F%BA%E7%A1%80_3%2F</url>
    <content type="text"><![CDATA[第一章 类与对象类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 1.1 类的定义格式： public class ClassName {&emsp;&emsp;&emsp;&emsp;//成员变量(属性)&emsp;&emsp;&emsp;&emsp;//成员方法(行为)} 成员变量:和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法:和以前定义方法几乎是一样的。只不过把static去掉。 举例： 1234567891011121314 public class Student &#123; //成员变量 String name;//姓名 int age;//年龄 //成员方法 //学习的方法 public void study() &#123; System.out.println("好好学习，天天向上"); &#125; //吃饭的方法 public void eat() &#123; System.out.println("学习饿了要吃饭"); &#125;&#125; 1.2 对象的使用格式： 导包 import 包名称.类名称； （属于同一个包可以不写） 创建对象 类名 对象名 = new 类名(); 使用对象访问类中的成员 对象名.成员变量;对象名.成员方法(); 成员变量的默认值 数据类型 默认值 基本类型 整数(byte，short，int，long) 0 浮点数(float，double) 0.0 字符(char) ‘\u0000’ 布尔(boolean) false 引用类型 数组，类，接口 null 类与对象举例： 定义手机类: 123456789101112131415public class Phone &#123; // 成员变量 String brand; //品牌 int price; //价格 String color; //颜色 // 成员方法 //打电话 public void call(String name) &#123; System.out.println("给"+name+"打电话"); &#125; //发短信 public void sendMessage() &#123; System.out.println("群发短信"); &#125;&#125; 定义测试类: 1234567891011121314151617181920212223242526public class Test02Phone &#123; public static void main(String[] args) &#123; //创建对象 Phone p = new Phone(); //输出成员变量值 System.out.println("品牌:"+p.brand);//null System.out.println("价格:"+p.price);//0 System.out.println("颜色:"+p.color);//null System.out.println("‐‐‐‐‐‐‐‐‐‐‐‐"); //给成员变量赋值 p.brand = "锤子"; p.price = 2999; p.color = "棕色"; //再次输出成员变量值 System.out.println("品牌:"+p.brand);//锤子 System.out.println("价格:"+p.price);//2999 System.out.println("颜色:"+p.color);//棕色 System.out.println("‐‐‐‐‐‐‐‐‐‐‐‐"); //调用成员方法 p.call("紫霞"); p.sendMessage(); &#125; &#125; 成员变量和局部变量区别 在类中的位置不同 成员变量:类中，方法外 局部变量:方法中或者方法声明上(形式参数) 作用范围不一样 成员变量:类中 局部变量:方法中 初始化值的不同 成员变量:有默认值 局部变量:没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 成员变量:堆内存 局部变量:栈内存 生命周期不同 成员变量:随着对象的创建而存在，随着对象的消失而消失 局部变量:随着方法的调用而存在，随着方法的调用完毕而消失 第二章 封装封装 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 方法就是一种封装 关键字private也是 2.1 封装步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对getXxx方法 、setXxx方法。 2.2 封装的操作——private关键字private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 使用格式 private 数据类型 变量名 ; 使用 private 修饰成员变量，代码如下: 1234public class Student &#123; private String name; private int age;&#125; 提供 getXxx 方法 / setXxx 方法，可以访问成员变量 代码如下: 123456789101112131415161718public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; &#125; set方法，用于向age设置数据 get方法，用于获取age的数据 可以用set约束设置的数据 注意： 对于基本类型中的boolean值，getter方法要写成isxxx，而setxxx规则不变 第三章 封装优化3.1 this关键字上一章中，setXxx 方法中形参名字并不符合见名知意的规定如果修改与成员变量名一致，代码如下: 1234567891011public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125; &#125; 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量如果需要访问本类当中的成员变量，需要使用this关键字通过谁调用的方法，谁就是this 格式： this.成员变量名; 使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下: 12345678910public class Person &#123; String name; // 我自己的名字 // 参数name是对方的名字 // 成员变量name是自己的名字 public void sayHello(String name) &#123; System.out.println(name + "，你好。我是" + this.name); System.out.println(this); &#125;&#125; 12345678910public class Demo01Person &#123; public static void main(String[] args) &#123; Person person = new Person(); // 设置我自己的名字 person.name = "王健林"; person.sayHello("王思聪"); System.out.println(person); // 地址值 &#125;&#125; 输出结果： 王思聪，你好。我是王健林cn.itcast.day06.demo04.Person@7852e922cn.itcast.day06.demo04.Person@7852e922 3.2 构造方法构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。格式： public 类名称(参数类型 参数名称) {&emsp;&emsp;&emsp;&emsp;方法体} 注意事项： 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样 构造方法不要写返回值类型，连void都不写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。public Student() {} 一旦编写了至少一个构造方法，那么编译器将不再赠送。 构造方法也是可以进行重载的。 使用构造方法后，代码如下: 12345678910111213public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 全参数构造方法，方便我们在创建对象的时候把数据直接通过参数的形式设置进来，省去多次调用setget方法 但是当修改对象内容时set方法还是有用的。 获取数据时还是要用get方法 要写全参数构造方法时，需要把无参数也写上，因为系统不会赠送了。 3.3 标准代码——JavaBean一个标准的类通常要拥有下面四个组成部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 编写符合 JavaBean 规范的类，以学生类为例，标准代码如下: 12345678910111213141516171819202122232425262728public class Student &#123; //成员变量 private String name; // 姓名 private int age; // 年龄 //构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; 成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 测试类，代码如下： 1234567891011121314public class TestStudent &#123; public static void main(String[] args) &#123; //无参构造使用 Student s= new Student(); s.setName("柳岩"); s.setAge(18); System.out.println(s.getName()+"‐‐‐"+s.getAge()); //带参构造使用 Student s2= new Student("赵丽颖",18); System.out.println(s2.getName()+"‐‐‐"+s2.getAge()); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础_2]]></title>
    <url>%2F2019%2F07%2F03%2FJava%E5%9F%BA%E7%A1%80_2%2F</url>
    <content type="text"><![CDATA[第一章 方法方法: 就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 1.1 定义 修饰符 返回值类型 方法名 (参数列表){&emsp;&emsp;&emsp;&emsp;代码…&emsp;&emsp;&emsp;&emsp;return 返回值;} 定义格式解释: 修饰符: 目前固定写法 public static 返回值类型: 没有返回值时为&ensp;void 方法名:满足标识符的规范，用来调用方法。 参数列表: 参数 return:方法结束。返回值类型是void，方法大括号内的return可以不写，有返回值时返回给调用者。 举例： 123 public static void methodName() &#123; System.out.println("这是一个方法");&#125; 方法定义注意事项: 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 1.2 方法的调用12345678 public static void main(String[] args) &#123; //调用定义的方法method method();&#125;//定义方法，被main方法调用 public static void method() &#123; System.out.println("自己定义的方法，需要被main调用运行"); &#125; 上面方法为直接调用，有参数时括号内写入参数 还可以输出语句调用: 在输出语句中调用方法， System.out.println(方法名()) 。 不能用输出语句调用 void 类型的方法 1.3 方法重载 方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。 参数列表不同：个数不同，数据类型不同，顺序不同。 重载方法调用：JVM通过方法的参数列表，调用不同的方法。 重载练习比较两个数据是否相等。参数类型分别为两个 byte 类型，两个 short 类型，两个 int 类型，两个 long 类型，并在 main 方法中进行测试。 123456789101112131415161718192021222324252627282930313233343536373839public class Method_Demo6 &#123; public static void main(String[] args) &#123; //定义不同数据类型的变量 byte a = 10; byte b = 20; short c = 10; short d = 20; int e = 10; int f = 10; long g = 10; long h = 20; // 调用 System.out.println(compare(a, b)); System.out.println(compare(c, d)); System.out.println(compare(e, f)); System.out.println(compare(g, h)); &#125; // 两个byte类型的 public static boolean compare(byte a, byte b) &#123; System.out.println("byte"); return a == b; &#125; // 两个short类型的 public static boolean compare(short a, short b) &#123; System.out.println("short"); return a == b; &#125; // 两个int类型的 public static boolean compare(int a, int b) &#123; System.out.println("int"); return a == b; &#125; // 两个long类型的 public static boolean compare(long a, long b) &#123; System.out.println("long"); return a == b; &#125;&#125; 1.4 权限修饰符public:公共的protected:受保护的default:默认的（不写）private:私有的 public protected default(空的) private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 第二章 数组数组: 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 数组的特点： 数组是一种引用数据类型 数组当中的多个数据，类型必须统一 数组的长度在程序运行期间不可改变 2.1 定义数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 两种常见的初始化方式： 动态初始化（指定长度） 静态初始化（指定内容） 动态初始化数组 格式： 数据类型[] 数组名称 = new 数据类型[数组长度]; 解析含义： 数据类型：数组当中数据的统一类型[]：代表我是一个数组new：代表创建数组的动作数组长度：指定长度 举例： 1int[] arr = new int[3]; 静态初始化 标准格式： 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 省略格式： 数据类型[] 数组名称 = { 元素1, 元素2, … } 举例： 123int[] arrA = new int[]&#123;1,2,3,4,5&#125;;int[] arrB = &#123;1,2,3,4,5&#125;; 注意： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度 静态初始化标准格式、动态初始化，可以拆分成为两个步骤 静态初始化省略格式不能拆分成为两个步骤 12int[] arrayB;arrayB = new int[] &#123; 11, 21, 31 &#125;; 2.2 数组的访问索引：从0开始，通过数组的索引访问到数组中的元素格式： 数组名[索引] 数组长度获得数组长度语句：数组名.length数组的最大索引值为：数组名.length-1 索引访问数组中的元素: 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，获取出数组中的元素 2.3 数组内存原理Java虚拟机的内存划分 一个数组内存图 两个独立数组内存图 两个变量指向同一个数组内存图 2.4 数组遍历123456public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 2.5 数组获得最大值元素123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++)&#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println("数组最大值是: " + max); &#125; 2.6 数组反转数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 实现思想：数组最远端的元素互换位置。 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引–，再次交换位置 最小索引超过了最大索引，数组反转操作结束 12345678910111213141516public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 2.7 数组作为方法参数和返回值 数组作为方法参数传递，传递的参数是数组内存的地址 数组作为方法的返回值，返回的是数组的内存地址 方法的参数为基本类型时，传递的是数据值。为引用类型时，传递的是地址值。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop安装与伪分布式搭建]]></title>
    <url>%2F2019%2F06%2F29%2Fhadoop%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建Hadoop用户 创建新用户用户名为hadoop，使用/bin/bash作为shellsudo useradd -m hadoop -s /bin/bash 修改密码 1234$ sudo passwd hadoopEnter new UNIX password: Retype new UNIX password: passwd: password updated successfully 为hadoop用户添加管理员权限sudo adduser hadoop sudo 安装jdk1.7首先在oracle官网下载,接下来进行安装与环境变量配置，根据个人电脑系统选择对应版本，我选的是jdk-8u211-linux-x64.tar.gz 12345$ mkdir /usr/lib/jvm #创建jvm文件夹$ sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/lib/jvm #/ 解压到/usr/lib/jvm目录下$ cd /usr/lib/jvm #进入该目录$ mv jdk1.8.0_211 java #重命名为java$ vim ~/.bashrc #给JDK配置环境变量 在.bashrc文件添加如下指令： 1234export JAVA_HOME=/usr/lib/jvm/javaexport JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 在文件修改完毕以后，输入代码：$ source ~/.bashrc #使新配置的环境变量生效$ java -version #检测是否安装成功，查看java版本 安装SSH服务端 安装$ sudo apt-get install openssh-server 登录localhost$ ssh localhost之后会在~/文件夹下发现一个.ssh文件 设置为无密码登录123$ cd ~/.ssh/$ ssh-keygen -t rsa #出现提示直接按enter$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys #加入授权 此时就直接使用$ ssh localhost，无密码登录了。 安装Hadoop本文采用伪分布式模式：存储采用分布式文件系统HDFS，但是HDFS的节点和数据节点都在同一节点。 下载安装下载安装包后解压即可使用：1234$ sudo tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local$ cd /usr/local/$ sudo mv ./hadoop-2.7.1/ ./hadoop # 将文件夹名改为hadoop$ sudo chown -R hadoop ./hadoop # 修改文件权限 查看Hadoop版本信息： 12$ cd /usr/local/hadoop/bin$ ./hadoop version &lt;img src=”hadoop安装与伪分布式搭建/2.png&gt; 伪分布式模式配置修改配置文件:需要修改/usr/local/hadoop/etc/hadoop/文件夹下的core-site.xml和hdfs-site.xml文件。core-site.xml文件:将12&lt;configuration&gt;&lt;/configuration&gt; 修改为： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml文件修改如下： 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将/hadoop/etc/hadoop/hadoop-env.sh文件的JAVA_HOME改为绝对路径。将export JAVA_HOME=$JAVA_HOME改为export JAVA_HOME=/usr/lib/jvm/default-java 注意：Hadoop的运行方式是由配置文件决定的，如果想从伪分布式模式切换回单机模式，只需删除core-site.xml文件中的配置项即可 执行名称节点格式化执行如下命令：12$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format 出现如下错误 原因应该是权限不够无法再目录内新建文件。解决方案是：先输入命令：sudo su转为root身份输入命令：sudo chmod -R a+w /opt/hadoop-1.2.1/注意修改自己的安装路径。输入命令exit回到用户身份 再执行格式化成功。如果出现/usr/local/hadoop/tmp/dfs/name has been successfully formatted.和 Exiting with status 0，表示格式化成功。 启动Hadoop12$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh 用jps命令查看Hadoop是否启动成功，如果出现DataNode、NameNode、SecondaryNameNode的进程说明启动成功。 使用浏览器查看HDFS信息在浏览器中打开链接：http://localhost:50070/dfshealth.html#tab-overview即可查看 关闭Hadoop使用命令：./sbin/stop-dfs.sh下次启动时不需要再执行节点格式化命令（否则会报错），只需要直接运行start-dfs.sh命令即可。]]></content>
      <categories>
        <category>大数据环境搭建</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础_1]]></title>
    <url>%2F2019%2F06%2F29%2FJava%E5%9F%BA%E7%A1%80_1%2F</url>
    <content type="text"><![CDATA[第一章 入门1.1 HelloWorld入门程序Java程序开发三步骤:编写、编译、运行。 编写Java源程序 创建HelloWorld.java文件，代码如下： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 编译Java源文件 在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。命令: javac Java源文件名.后缀名 举例: 1javac HelloWorld.java 译成功后，产生一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 运行Java程序 在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。命令: java 类名字 举例： 1java HelloWolrd 入门程序说明 main方法： 称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释： 单行注释以 //开头 换行结束多行注释以 /*开头 以*/结束 关键字： 是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母。 标识符： 是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 HelloWorld案例中，出现的标识符有类名字 HelloWorld 。 命名规则： 硬性要求标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $(美元符号) 和 _(下划线) 。标识符不能以数字开头。标识符不能是关键字。软性要求类名规范:首字母大写，后面每个单词首字母大写(大驼峰式)。方法名规范: 首字母小写，后面每个单词首字母大写(小驼峰式)。变量名规范:全部小写 1.2 常量变量常量 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’，’’， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值 true ， false 空常量 只有一个值 null 变量 Java的数据类型分为两大类: 基本数据类型:包括 整数、浮点数、字符、布尔。 引用数据类型:包括 类 、 数组 、 接口 。 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int(默认) 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double(默认) 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false 变量定义 格式： 数据类型 变量名 = 数据值; 1.3 数据类型转换、运算符Java程序中要求参与的计算的数据，必须要保证数据类型的一致性（比如进行加法运算），如果数据类型不一致将发生类型的转换。 自动转换将 取值范围小的类型 自动提升为 取值范围大的类型 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 将 取值范围大的类型 强制转换成 取值范围小的类型 。 自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 转换格式： 数据类型 变量名 = (数据类型)被转数据值; 注意： 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 ASCII编码表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 1234567public static void main(String[] args) &#123; //字符类型变量 char c = 'a'; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98 &#125; 运算符算数运算符 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 注意：变量在独立运算时， 前++ 和 后++ 没有区别 ；和其他变量放在一起， 前++ 和 后++ 就产生了不同（+1后赋值、赋值后+1）。 三元运算符 格式： 数据类型 变量名 = 布尔类型表达式?结果1:结果2 计算方式:布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125; 第二章 判断、选择、循环语句2.1 判断语句 if 123if(关系表达式)&#123; 语句体;&#125; if…else 12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; if…else if…else 12345678910if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n; &#125; else &#123; 执行语句n+1; &#125; 注意：在某些简单的应用中，if语句是可以和三元运算符互换使用的。 1234567891011public static void main(String[] args) &#123; int a = 10; int b = 20; //定义变量，保存a和b的较大值 int c; if(a &gt; b) &#123; c = a; &#125; else &#123; c = b; &#125; //上述功能可以改写为三元运算符形式 c = a &gt; b ? a:b; &#125; 2.2 选择语句 switch 123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; switch语句中，表达式的数据类型，可以是byte，short，int，char，enum(枚举)，JDK7后可以接收字符串 注意：case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 2.3 循环语句 for循环 for(初始化表达式1; 布尔表达式2; 步进表达式4){ 循环体3} 执行顺序:1234&gt;234&gt;234…2不满足为止。 while循环 初始化表达式1 while(布尔表达式2){&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4} 执行顺序:1234&gt;234&gt;234…2不满足为止。 do…while循环 初始化表达式1 do{&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4}while(布尔表达式2); 执行顺序:134&gt;234&gt;234…2不满足为止。 for 和 while 的小区别: 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 2.4跳出语句break使用场景:终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景:结束本次循环，继续下一次的循环 嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo markdown]]></title>
    <url>%2F2019%2F06%2F28%2Fhexo-markdown%2F</url>
    <content type="text"><![CDATA[一些markdown记录 &lt; br&gt; 换行 两个空格+回车：换行 两个回车：换段落 空格+-，下一行-，会产生缩进序列 &amp;emsp ; 空一个汉字格数 &amp;ensp ; 空一个格]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客搭建]]></title>
    <url>%2F2019%2F06%2F28%2Fhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建流程&emsp;&emsp;1. 安装node.js 打开nodejs.org下载安装包，直接点开安装包安装。 查看安装版本 node -v npm -v &emsp;&emsp;2. 安装hexo框架（以下若权限不足sudo） npm install -g hexo-cli hexo -v 查看hexo版本 &emsp;&emsp;3. 建立blog空文件夹（在用户文件夹中建立即可（位置随意）） mkdir blog 后续如果出现什么问题，把blog文件夹删除重新来即可。 cd blog &emsp;&emsp;4. 初始化博客 sudo hexo init &emsp;&emsp;5. 启动博客 hexo s 浏览器打开localhost:4000，可以看到默认创建的博客 &emsp;&emsp;6. 创建自己的博客 sudo hexo new &quot;测试&quot; cd source/_posts/ 编辑测试.md即可更改博客内容（markdown） cd ../..退回到blog目录下 &emsp;&emsp;7. 本地查看博客总结 hexo clean 清理一下 hexo g 生成一下 hexo s 启动一下 &emsp;&emsp;8. 建repository（为了博客部署到github上公开使用） 登陆自己的github账户，右上角+点开 New repositoryrepository name 必须是 ：昵称（前面的Owner）.github.io 点击greate，出现一个空仓库，保留页面 &emsp;&emsp;9. 安装部署插件 sudo npm install --save hexo-deployer-git 更改_config.yml文件 sudo vim _config.yml 到达文件最底部更改增加如下： 1234deploy: type: git repo: https://github.com/mangosTeeN96/mangosTeeN96.github.io.git branch: master 其中repo地址为刚刚创建的仓库页面的地址（注意冒号后面的空格） &emsp;&emsp;10. 部署到远端 hexo d 中途需要输入GitHub的账户密码 此时访问 mangosteen96.github.io 即可看到自己的博客 到此博客的基本部署就完成了 &emsp;&emsp;11. 更换博客主题 以yilia主题为例 sudo git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 此时themes文件夹中出现yilia文件夹，更改站点配置文件 找到theme：xxx 改为theme：yilia hexo clean hexo g hexo s 4000端口即可看到更改 hexo d 推到远端，mangosteen96.github.io 可以看到（主题更换可能要等一下下） Hexo博客导入图片方法1 站点配置文件_config.yml 里的post_asset_folder:这个选项设置为true npm install hexo-asset-image --save 安装一个可以上传本地图片的插件 安装插件后hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片复制到xxxx这个文件夹中，在xxxx.md中按照markdown的格式引入图片(此处为了不被识别为图片就先这么写了)： 感叹号+[]括号内可输入替代文字+(xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看，html标签内的语句是img src=”2017/02/26/xxxx/图片名.jpg”，必须要有日期。 其它方法 本地source中建立img文件夹&lt;&gt; 内 img src=”img/图片名.jpg（此方法未详细试验） 图床 所遇问题 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理链接时出现路径错误，没有年月，无法显示图片。可直接安装已经修改过得插件npm install https://github.com/7ym0n/hexo-asset-image --save 由于title中有一些符号（比如（）、–等）用hexo new命令创建博客时，出现文件名称与文章title不符的情况在博客中没有图片时，并不产生影响，但当要插入图片时，在路径正确的情况下，依然显示不出图片解决办法暂时只是把 1.文件夹名称、2.md文件名称、3.title 这三者统一]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
