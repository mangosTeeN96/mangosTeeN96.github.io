{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://mangosTeeN96.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-06-28T05:09:08.005Z","updated":"2019-06-27T03:19:17.750Z","comments":false,"path":"categories/index.html","permalink":"http://mangosTeeN96.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-28T05:09:08.017Z","updated":"2019-06-27T03:19:17.750Z","comments":true,"path":"links/index.html","permalink":"http://mangosTeeN96.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-06-28T05:09:08.031Z","updated":"2019-06-27T03:19:17.751Z","comments":false,"path":"tags/index.html","permalink":"http://mangosTeeN96.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"(Java)继承与多态--1.继承","slug":"(Java)继承与多态--1.继承","date":"2019-07-09T03:16:06.000Z","updated":"2019-07-09T04:58:30.749Z","comments":true,"path":"2019/07/09/(Java)继承与多态--1.继承/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/09/(Java)继承与多态--1.继承/","excerpt":"","text":"多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那一个类称为父类、超类(superclass)或者基类。 继承描述的是事物之间的所属关系，这种关系是: is-a 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 定义： 继承:就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 格式123456public class 父类 &#123; ...&#125;public class 子类 extends 父类 &#123; ...&#125; 成员变量访问在父子类的继承关系当中，如果成员变量重名，则： 直接通过子类对象访问成员变量： 等号左边是谁，就优先用谁，没有则向上找。 间接通过成员方法访问成员变量： 该方法属于谁，就优先用谁，没有则向上找 三种变量写法整理： 局部变量：&emsp;&emsp;&emsp; 直接写成员变量名 本类的成员变量： this.成员变量名 父类的成员变量： super.成员变量 父类： 123public class Fu &#123; int num = 10;&#125; 子类： 1234567891011public class Zi extends Fu &#123; int num = 20; public void method() &#123; int num = 30; System.out.println(num); // 30，局部变量 System.out.println(this.num); // 20，本类的成员变量 System.out.println(super.num); // 10，父类的成员变量 &#125;&#125; 成员方法 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。 注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的 重写（覆盖重写）– 成员方法重名方法重写 :子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 特点：创建的是子类对象，则优先用子类方法 注意事项： 必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。 子类方法的返回值必须【小于等于】父类方法的返回值范围。 小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。 子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; (default) &gt; private备注：(default)不是关键字default，而是什么都不写，留空。 (其实多数情况这些范围权限都是相等的) 应用： 12345public class Phone &#123; public void show() &#123; System.out.println(\"显示号码\"); &#125;&#125; 12345678910public class NewPhone extends Phone &#123; @Override public void show() &#123; super.show(); // 把父类的show方法拿过来重复利用 // 自己子类再来添加更多内容 System.out.println(\"显示姓名\"); System.out.println(\"显示头像\"); &#125;&#125; 构造方法继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 12345678public class Fu &#123; public Fu() &#123; System.out.println(\"父类无参构造\"); &#125; public Fu(int num) &#123; System.out.println(\"父类有参构造！\"); &#125;&#125; 123456789101112public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println(\"子类构造方法！\"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125; 总结：子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 super关键字用法总结： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 this关键字用法总结： super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意：A. this(…)调用也必须是构造方法的第一个语句，唯一一个。B. super和this两种构造调用，不能同时使用 super与this的内存图:","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"继承与多态","slug":"继承与多态","permalink":"http://mangosTeeN96.github.io/tags/继承与多态/"}]},{"title":"(Java)常用API--8.Math类","slug":"Java-常用API-8-Math类","date":"2019-07-08T08:47:15.000Z","updated":"2019-07-08T10:47:43.391Z","comments":true,"path":"2019/07/08/Java-常用API-8-Math类/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/08/Java-常用API-8-Math类/","excerpt":"","text":"java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 基本运算方法 public static double abs(double num)：获取绝对值。有多种重载。 public static double ceil(double num)：向上取整。 public static double floor(double num)：向下取整。 public static long round(double num)：四舍五入。 Math.PI代表近似的圆周率常量（double） 1234567double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.ceil(3.3); //d2的值为 4.0double d3 = Math.floor(3.3); //d3的值为3.0long d4 = Math.round(5.5); //d4的值为6.0","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--7.Arrays类","slug":"Java-常用API-7-Arrays类","date":"2019-07-08T08:24:13.000Z","updated":"2019-07-08T08:46:39.616Z","comments":true,"path":"2019/07/08/Java-常用API-7-Arrays类/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/08/Java-常用API-7-Arrays类/","excerpt":"","text":"java.util.Arrays此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 常用方法： public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]） public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。 如果是数值，sort默认按照升序从小到大 如果是字符串，sort默认按照字母升序 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习） 123String[] array2 = &#123;\"bbb\", \"aaa\", \"ccc\"&#125;;Arrays.sort(array2);System.out.println(Arrays.toString(array2)); // [aaa, bbb, ccc] 练习： 请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。（涉及到倒序遍历） 1234567891011121314public static void main(String[] args) &#123; String str = \"asv76agfqwdfvasdfvjh\"; // 如何进行升序排列：sort // 必须是一个数组，才能用Arrays.sort方法 // String --&gt; 数组，用toCharArray char[] chars = str.toCharArray(); Arrays.sort(chars); // 对字符数组进行升序排列 // 需要倒序遍历(此处idea快捷键：chars.forr) for (int i = chars.length - 1; i &gt;= 0; i--) &#123; System.out.println(chars[i]); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--6.static关键字","slug":"(Java)常用API--6.static关键字","date":"2019-07-08T07:16:54.000Z","updated":"2019-07-08T08:05:59.315Z","comments":true,"path":"2019/07/08/(Java)常用API--6.static关键字/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/08/(Java)常用API--6.static关键字/","excerpt":"","text":"static关键字：它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 类变量（修饰成员变量） 当static修饰成员变量时，该变量称为类变量 该类的每个对象都共享同一个类变量的值 任何对象都可以更改该类变量的值 但也可以在不创建该类的对象的情况下对类变量进行操作。 举例： 每新来一个同学，id自动+1 学生类： 12345678910111213141516171819202122232425262728293031323334353637public class Student &#123; private int id; // 学号 private String name; // 姓名 private int age; // 年龄 static String room; // 所在教室 private static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++ public Student() &#123; this.id = ++idCounter; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 代码： 1234567891011121314151617public class Demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student(\"郭靖\", 19); one.room = \"101教室\";//后面会说，不推荐这么写 System.out.println(\"姓名：\" + one.getName() + \"，年龄：\" + one.getAge() + \"，教室：\" + one.room + \"，学号：\" + one.getId()); Student two = new Student(\"黄蓉\", 16); System.out.println(\"姓名：\" + two.getName() + \"，年龄：\" + two.getAge() + \"，教室：\" + two.room + \"，学号：\" + two.getId()); &#125;&#125; 输出： 姓名：郭靖，年龄：19，教室：101教室，学号：1姓名：黄蓉，年龄：16，教室：101教室，学号：2 静态方法（类方法）（修饰成员方法） 一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。 如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。 如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 注意事项： 静态不能直接访问非静态原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容“先人不知道后人，但是后人知道先人。” 静态方法当中不能用this原因：this代表当前对象，通过谁调用的方法，谁就是当前对象 MyClass类： 1234567891011121314151617181920212223242526272829public class MyClass &#123; int num; // 成员变量 static int numStatic; // 静态变量 // 成员方法 public void method() &#123; System.out.println(\"这是一个成员方法。\"); // 成员方法可以访问成员变量 System.out.println(num); // 成员方法可以访问静态变量 System.out.println(numStatic); &#125; // 静态方法 public static void methodStatic() &#123; System.out.println(\"这是一个静态方法。\"); // 静态方法可以访问静态变量 System.out.println(numStatic); // 静态不能直接访问非静态【重点】// System.out.println(num); // 错误写法！ // 静态方法中不能使用this关键字。// System.out.println(this); // 错误写法！ &#125;&#125; 代码： 12345678910111213141516171819202122public class Demo02StaticMethod &#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); // 首先创建对象 // 然后才能使用没有static关键字的内容 obj.method(); // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名” MyClass.methodStatic(); // 正确，推荐 // 对于本来当中的静态方法，可以省略类名称 myMethod(); Demo02StaticMethod.myMethod(); // 完全等效 &#125; public static void myMethod() &#123; System.out.println(\"自己的方法！\"); &#125;&#125; 静态代码块格式： public class 类名称 {&emsp;&emsp;&emsp;&emsp;static {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// 静态代码块的内容&emsp;&emsp;&emsp;&emsp;}} 特点： 当第一次用到本类时，静态代码块执行唯一的一次。 静态内容总是优先于非静态，所以静态代码块比构造方法先执行。 典型用途： 用来一次性地对静态成员变量进行赋值。 Person类： 123456789public class Person &#123; static &#123; System.out.println(\"静态代码块执行！\"); &#125; public Person() &#123; System.out.println(\"构造方法执行！\"); &#125;&#125; 代码： 1234public static void main(String[] args) &#123; Person one = new Person(); Person two = new Person();&#125; 输出结果： 静态代码块执行！构造方法执行！构造方法执行！","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--5.String类","slug":"(Java)常用API--5.String类","date":"2019-07-08T05:33:30.000Z","updated":"2019-07-08T07:17:04.731Z","comments":true,"path":"2019/07/08/(Java)常用API--5.String类/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/08/(Java)常用API--5.String类/","excerpt":"","text":"java.lang.String类代表字符串程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。） 特点： 字符串的内容永不可变。 正是因为字符串不可改变，所以字符串是可以共享使用的。 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[]字节数组。 构造方法创建字符串的常见3+1种方式。 三种构造方法： public String()：创建一个空白字符串，不含有任何内容。 public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。 代码： 12345678910 // 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;; String str3 = new String(bytes);//打印输出是'a','b','c' 一种直接创建： String str = &quot;Hello&quot;; // 右边直接用双引号 注意：直接写上双引号，就是字符串对象。 字符串的常量池 字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中 对于基本类型来说，==是进行 数值 的比较 对于引用类型来说，==是进行 地址值 的比较 1234567891011public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a', 'b', 'c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false&#125; 比较方法==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法： public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。 注意事项： 任何对象都能用Object进行接收。 equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：”abc”.equals(str)不推荐：str.equals(“abc”) public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。 获取方法 String当中与获取相关的常用方法有： public int length()：获取字符串长度。 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。 public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。） public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 12345678910111213141516171819202122public static void main(String[] args) &#123; // 获取字符串的长度 int length = \"asdasfeutrvauevbueyvb\".length(); // 拼接字符串 String str1 = \"Hello\"; String str2 = \"World\"; String str3 = str1.concat(str2); System.out.println(str3); // HelloWorld，新的字符串 // 获取指定索引位置的单个字符 char ch = \"Hello\".charAt(1); System.out.println(\"在1号索引位置的字符是：\" + ch); // 查找参数字符串在本来字符串当中出现的第一次索引位置 // 如果根本没有，返回-1值 String original = \"HelloWorldHelloWorld\"; int index = original.indexOf(\"llo\"); System.out.println(\"第一次索引值是：\" + index); // 2 System.out.println(\"HelloWorld\".indexOf(\"abc\")); // -1&#125; 截取方法 字符串的截取方法： public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边 123456String str1 = \"HelloWorld\";String str2 = str1.substring(5);System.out.println(str2); // World，新字符串String str3 = str1.substring(4, 7);System.out.println(str3); // oWo 转换方法 String当中与转换相关的常用方法有： public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。 public byte[] getBytes()：获得当前字符串底层的字节数组。 public String replace(CharSequence oldString, CharSequence newString)： 将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。备注：CharSequence意思就是说可以接受字符串类型 1234567891011121314// 转换成为字符数组char[] chars = \"Hello\".toCharArray();System.out.println(chars[0]); // H// 转换成为字节数组byte[] bytes = \"abc\".getBytes();for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.println(bytes[i]);&#125;// 字符串的内容替换String str1 = \"How do you do?\";String str2 = str1.replace(\"o\", \"*\");System.out.println(str2); // H*w d* y*u d*? 分割方法分割字符串的方法：public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。 12345String str1 = \"aaa,bbb,ccc\";String[] array1 = str1.split(\",\");for (int i = 0; i &lt; array1.length; i++) &#123; System.out.println(array1[i]);&#125; 注意事项：split方法的参数其实是一个“正则表达式”，今后学习。今天要注意：如果按照英文句点“.”进行切分，必须写”\\.”（两个反斜杠）","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--4.ArrayList类","slug":"Java-常用API-4-ArrayList类","date":"2019-07-04T11:58:43.000Z","updated":"2019-07-08T05:33:40.262Z","comments":true,"path":"2019/07/04/Java-常用API-4-ArrayList类/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java-常用API-4-ArrayList类/","excerpt":"","text":"对象数组数组类型选用对象，例如： 123456789101112public static void main(String[] args) &#123; // 首先创建一个长度为3的数组，里面用来存放Person类型的对象 Person[] array = new Person[3]; Person one = new Person(\"迪丽热巴\", 18); // 将one当中的地址值赋值到数组的0号元素位置 array[0] = one; System.out.println(array[0]); // 地址值 System.out.println(array[0].getName()); // 迪丽热巴&#125; 而数组的长度是固定的，无法适应数据变化的需求 ArrayList类数组的长度不可以发生改变但是ArrayList集合的长度是可以随意变化的 查看类 java.util.ArrayList &lt;E&gt;:需要 import导入 &lt;E&gt; ，表示一种指定的数据类型，叫做泛型。 在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素 ArrayList，ArrayList 格式(查看构造方法)基本格式: ArrayList&lt; String&gt; list = new ArrayList&lt; String&gt;(); 在JDK 1.7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式: ArrayList&lt; String&gt; list = new ArrayList&lt;&gt;(); 注意：对于ArrayList集合来说，未添加数据直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号：[] 常用方法及遍历 对于元素的操作,基本体现在——增、删、查。常用的方法有: public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（后面会有）来说，add添加动作不一定成功。 public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。 public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。 public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数 举例： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 向集合中添加元素：add boolean success = list.add(\"柳岩\"); System.out.println(list); // [柳岩] System.out.println(\"添加的动作是否成功：\" + success); // true list.add(\"高圆圆\"); list.add(\"赵又廷\"); list.add(\"李小璐\"); list.add(\"贾乃亮\"); System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮] // 从集合中获取元素：get。索引值从0开始 String name = list.get(2); System.out.println(\"第2号索引位置：\" + name); // 赵又廷 // 从集合中删除元素：remove。索引值从0开始。 String whoRemoved = list.remove(3); System.out.println(\"被删除的人是：\" + whoRemoved); // 李小璐 System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 贾乃亮] // 获取集合的长度尺寸，也就是其中元素的个数 int size = list.size(); System.out.println(\"集合的长度是：\" + size); //遍历 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //idea中，list.fori可以自动生成这个循环&#125; 存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt; int&gt; 不能写，但是存储基本数据类型对应的 包装类型是可以的。 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 练习： 生成6个1~33之间的随机整数,添加到集合,并遍历 1234567891011121314151617public class Test01ArrayList &#123; public static void main(String[] args) &#123; // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对象 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) &#123; int r = random.nextInt(33) + 1; list.add(r); &#125; // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125; &#125; 自定义2个学生对象，添加到集合，并遍历 123456789101112131415161718public class Demo02ArrayListStudent &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); Student one = new Student(\"洪七公\", 20); Student two = new Student(\"欧阳锋\", 21); list.add(one); list.add(two); // 遍历集合 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); System.out.println(\"姓名：\" + stu.getName() + \"，年龄\" + stu.getAge()); &#125; &#125;&#125; 对象可以作为集合元素 定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用{}扩起集合，使用@分隔每个元素。格式参照 {元素@元素@元素} 12345678910111213141516171819202122232425public class Demo05ArrayListPrint &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"宋远桥\"); list.add(\"张无忌\"); list.add(\"李连杰\"); System.out.println(list); printArrayList(list); &#125; public static void printArrayList(ArrayList&lt;String&gt; list)&#123; System.out.print(\"&#123;\"); for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); if (i == list.size() - 1)&#123; System.out.println(name + \"&#125;\"); &#125;else&#123; System.out.print(name + \"@\"); &#125; &#125; &#125;&#125; 用一个大集合存入20个随机数字(1~100)，然后筛选其中的偶数元素，放到小集合当中。要求使用自定义的方法来实现筛选 1234567891011121314151617181920212223242526272829303132public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(100) + 1; // 1~100 bigList.add(num); &#125; ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println(\"偶数总共有多少个：\" + smallList.size()); for (int i = 0; i &lt; smallList.size(); i++) &#123; System.out.println(smallList.get(i)); &#125; &#125; // 这个方法，接收大集合参数，返回小集合结果 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; // 创建一个小集合，用来装偶数结果 ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bigList.size(); i++) &#123; int num = bigList.get(i); if (num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125; ArrayList类型作为返回值","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--3.Random类","slug":"Java-常用API-3-Random类","date":"2019-07-04T11:35:57.000Z","updated":"2019-07-04T12:49:20.764Z","comments":true,"path":"2019/07/04/Java-常用API-3-Random类/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java-常用API-3-Random类/","excerpt":"","text":"Random类：用来生成随机数字 使用步骤： 导包 import java.util.Random; idea可以自动生成 创建 Random r = new Random(); // 小括号当中留空即可 使用 获取一个随机的int数字（范围是int所有范围，有正负两种）： int num = r.nextInt() 获取一个随机的int数字（参数代表了范围，左闭右开区间）： int num = r.nextInt(3) 实际上代表的含义是：[0,3)，也就是0~2 练习： 猜数字小游戏游戏开始，随机生成一个1-100之间的整数 number 。玩家猜测一个数字 guessNumber ，会与 number 作比较，系统提示大了或者小了，直到玩家猜中，游戏结束。 代码： 123456789101112131415161718192021public static void main(String[] args) &#123; Random r = new Random(); int randomNum = r.nextInt(100) + 1; //[1:100] Scanner sc = new Scanner(System.in); while (true)&#123; System.out.println(\"请输入你猜测的数字：\"); int guessNum = sc.nextInt(); if (guessNum &gt; randomNum)&#123; System.out.println(\"太大了，请重试\"); &#125;else if (guessNum &lt; randomNum)&#123; System.out.println(\"太小了，请重试\"); &#125;else &#123; System.out.println(\"恭喜你，猜中啦\"); break; &#125; &#125; System.out.println(\"游戏结束\");&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--2.匿名对象","slug":"Java-常用API-2-匿名对象","date":"2019-07-04T10:53:42.000Z","updated":"2019-07-04T12:49:05.981Z","comments":true,"path":"2019/07/04/Java-常用API-2-匿名对象/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java-常用API-2-匿名对象/","excerpt":"","text":"匿名对象：没有变量名的对象 格式: new 类名(参数列表); 应用场景: 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。一旦调用两次方法，就是创建了两个对象，造成浪费 匿名对象可以作为方法的参数和返回值 作为参数 12345678910111213class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125; &#125; 作为返回值 123456789101112131415class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"(Java)常用API--1.Scanner类","slug":"Java-常用API-1-Scanner类","date":"2019-07-04T07:35:24.000Z","updated":"2019-07-04T12:48:49.804Z","comments":true,"path":"2019/07/04/Java-常用API-1-Scanner类/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java-常用API-1-Scanner类/","excerpt":"","text":"APIAPI(Application Programming Interface)，应用程序编程接口Java API是一本程序员的字典是我们使用的类的说明文档 API帮助文档（中文版）：JDK_API_1_6_zh_CN.CHM 引用类一般步骤： 导包 import 包路径.类名称; 如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包（比如String），其他的包都需要import语句。 创建 类名称 对象名 = new 类名称(); 使用 对象名.成员方法名() Scanner类 Scanner类的功能：可以实现键盘输入数据，到程序当中 使用方法： 查看类 java.util.Scanner :该类需要import导入后使用。 查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 查看成员方法 public int nextInt() :将输入信息的下一个标记扫描为一个 int 值。 还有很多，比如next（），String值 使用Scanner类，完成接收键盘录入数据的操作，代码如下: 12345678910111213141516171819import java.util.Scanner; public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println(\"输入的int数字是：\" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println(\"输入的字符串是：\" + str); &#125; &#125; 练习题： 键盘输入三个int数字，然后求出其中的最大值```javaimport java.util.Scanner; public class Demo03ScannerMax { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入第一个数字：&quot;); int a = sc.nextInt(); System.out.println(&quot;请输入第二个数字：&quot;); int b = sc.nextInt(); System.out.println(&quot;请输入第三个数字：&quot;); int c = sc.nextInt(); // 首先得到前两个数字当中的最大值 int temp = a &gt; b ? a : b; int max = temp &gt; c ? temp : c; System.out.println(&quot;最大值是：&quot; + max); }}","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"Java基础--10.封装优化","slug":"Java基础-10-封装优化","date":"2019-07-04T06:01:09.000Z","updated":"2019-07-04T12:52:03.114Z","comments":true,"path":"2019/07/04/Java基础-10-封装优化/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java基础-10-封装优化/","excerpt":"","text":"this关键字上一篇笔记中，setXxx 方法中形参名字并不符合见名知意的规定如果修改与成员变量名一致，代码如下: 1234567891011public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125; &#125; 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量如果需要访问本类当中的成员变量，需要使用this关键字通过谁调用的方法，谁就是this 格式： this.成员变量名; 使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下: 12345678910public class Person &#123; String name; // 我自己的名字 // 参数name是对方的名字 // 成员变量name是自己的名字 public void sayHello(String name) &#123; System.out.println(name + \"，你好。我是\" + this.name); System.out.println(this); &#125;&#125; 12345678910public class Demo01Person &#123; public static void main(String[] args) &#123; Person person = new Person(); // 设置我自己的名字 person.name = \"王健林\"; person.sayHello(\"王思聪\"); System.out.println(person); // 地址值 &#125;&#125; 输出结果： 王思聪，你好。我是王健林cn.itcast.day06.demo04.Person@7852e922cn.itcast.day06.demo04.Person@7852e922 构造方法构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。格式： public 类名称(参数类型 参数名称) {&emsp;&emsp;&emsp;&emsp;方法体} 注意事项： 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样 构造方法不要写返回值类型，连void都不写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。public Student() {} 一旦编写了至少一个构造方法，那么编译器将不再赠送。 构造方法也是可以进行重载的。 使用构造方法后，代码如下: 12345678910111213public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 全参数构造方法，方便我们在创建对象的把数据直接通过参数的形式设置进来，省去多次调用setget方法 但是当修改对象内容时set方法还是有用的。 获取数据时还是要用get方法 要写全参数构造方法时，需要把无参数也写上，因为系统不会赠送了。 标准代码——JavaBean一个标准的类通常要拥有下面四个组成部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 编写符合 JavaBean 规范的类，以学生类为例，标准代码如下: 12345678910111213141516171819202122232425262728public class Student &#123; //成员变量 private String name; // 姓名 private int age; // 年龄 //构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; 成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 测试类，代码如下： 1234567891011121314public class TestStudent &#123; public static void main(String[] args) &#123; //无参构造使用 Student s= new Student(); s.setName(\"柳岩\"); s.setAge(18); System.out.println(s.getName()+\"‐‐‐\"+s.getAge()); //带参构造使用 Student s2= new Student(\"赵丽颖\",18); System.out.println(s2.getName()+\"‐‐‐\"+s2.getAge()); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--9.封装","slug":"Java基础-9-封装","date":"2019-07-04T05:26:52.000Z","updated":"2019-07-04T12:51:34.441Z","comments":true,"path":"2019/07/04/Java基础-9-封装/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java基础-9-封装/","excerpt":"","text":"封装封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 方法就是一种封装 关键字private也是 封装步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对getXxx方法 、setXxx方法。 封装的操作——private关键字 private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 使用格式 private 数据类型 变量名 ; 使用 private 修饰成员变量，代码如下: 1234public class Student &#123; private String name; private int age;&#125; 提供 getXxx 方法 / setXxx 方法，可以访问成员变量 代码如下: 123456789101112131415161718public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; &#125; set方法，用于向age设置数据 get方法，用于获取age的数据 可以用set约束设置的数据 注意： 对于基本类型中的boolean值，getter方法要写成isxxx，而setxxx规则不变","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--8.类与对象","slug":"Java基础-8-类与对象","date":"2019-07-04T04:48:39.000Z","updated":"2019-07-04T12:51:13.639Z","comments":true,"path":"2019/07/04/Java基础-8-类与对象/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java基础-8-类与对象/","excerpt":"","text":"类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 类的定义格式： public class ClassName {&emsp;&emsp;&emsp;&emsp;//成员变量(属性)&emsp;&emsp;&emsp;&emsp;//成员方法(行为)} 成员变量:和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法:和以前定义方法几乎是一样的。只不过把static去掉。 举例： 1234567891011121314 public class Student &#123; //成员变量 String name;//姓名 int age;//年龄 //成员方法 //学习的方法 public void study() &#123; System.out.println(\"好好学习，天天向上\"); &#125; //吃饭的方法 public void eat() &#123; System.out.println(\"学习饿了要吃饭\"); &#125;&#125; 对象的使用格式： 导包 import 包名称.类名称； （属于同一个包可以不写） 创建对象 类名 对象名 = new 类名(); 使用对象访问类中的成员 对象名.成员变量;对象名.成员方法(); 成员变量的默认值 数据类型 默认值 基本类型 整数(byte，short，int，long) 0 浮点数(float，double) 0.0 字符(char) ‘\\u0000’ 布尔(boolean) false 引用类型 数组，类，接口 null 类与对象举例： 定义手机类: 123456789101112131415public class Phone &#123; // 成员变量 String brand; //品牌 int price; //价格 String color; //颜色 // 成员方法 //打电话 public void call(String name) &#123; System.out.println(\"给\"+name+\"打电话\"); &#125; //发短信 public void sendMessage() &#123; System.out.println(\"群发短信\"); &#125;&#125; 定义测试类: 1234567891011121314151617181920212223242526public class Test02Phone &#123; public static void main(String[] args) &#123; //创建对象 Phone p = new Phone(); //输出成员变量值 System.out.println(\"品牌:\"+p.brand);//null System.out.println(\"价格:\"+p.price);//0 System.out.println(\"颜色:\"+p.color);//null System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐\"); //给成员变量赋值 p.brand = \"锤子\"; p.price = 2999; p.color = \"棕色\"; //再次输出成员变量值 System.out.println(\"品牌:\"+p.brand);//锤子 System.out.println(\"价格:\"+p.price);//2999 System.out.println(\"颜色:\"+p.color);//棕色 System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐\"); //调用成员方法 p.call(\"紫霞\"); p.sendMessage(); &#125; &#125; 成员变量和局部变量区别 在类中的位置不同 成员变量:类中，方法外 局部变量:方法中或者方法声明上(形式参数) 作用范围不一样 成员变量:类中 局部变量:方法中 初始化值的不同 成员变量:有默认值 局部变量:没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 成员变量:堆内存 局部变量:栈内存 生命周期不同 成员变量:随着对象的创建而存在，随着对象的消失而消失 局部变量:随着方法的调用而存在，随着方法的调用完毕而消失","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--7.数组-二","slug":"Java基础-7-数组-二","date":"2019-07-03T11:43:45.000Z","updated":"2019-07-04T12:50:52.354Z","comments":true,"path":"2019/07/03/Java基础-7-数组-二/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础-7-数组-二/","excerpt":"","text":"数组遍历123456public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 数组获得最大值元素123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++)&#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println(\"数组最大值是: \" + max); &#125; 数组反转数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 实现思想:数组最远端的元素互换位置。 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引–，再次交换位置 最小索引超过了最大索引，数组反转操作结束 12345678910111213141516public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 数组作为方法参数和返回值 数组作为方法参数传递，传递的参数是数组内存的地址 数组作为方法的返回值，返回的是数组的内存地址 方法的参数为基本类型时，传递的是数据值。为引用类型时，传递的是地址值。","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--6.数组","slug":"Java基础--6.数组","date":"2019-07-03T10:14:36.000Z","updated":"2019-07-04T12:50:36.781Z","comments":true,"path":"2019/07/03/Java基础--6.数组/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础--6.数组/","excerpt":"","text":"数组: 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 数组的特点： 数组是一种引用数据类型 数组当中的多个数据，类型必须统一 数组的长度在程序运行期间不可改变 定义数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 两种常见的初始化方式： 动态初始化（指定长度） 静态初始化（指定内容） 动态初始化数组 格式： 数据类型[] 数组名称 = new 数据类型[数组长度]; 解析含义：数据类型：数组当中数据的统一类型[]：代表我是一个数组new：代表创建数组的动作数组长度：指定长度 举例： 1int[] arr = new int[3]; 静态初始化 标准格式： 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 省略格式： 数据类型[] 数组名称 = { 元素1, 元素2, … } 举例： 123int[] arrA = new int[]&#123;1,2,3,4,5&#125;;int[] arrB = &#123;1,2,3,4,5&#125;; 注意： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度 静态初始化标准格式、动态初始化，可以拆分成为两个步骤 静态初始化省略格式不能拆分成为两个步骤 12int[] arrayB;arrayB = new int[] &#123; 11, 21, 31 &#125;; 数组的访问索引：从0开始，通过数组的索引访问到数组中的元素格式： 数组名[索引] 数组长度获得数组长度语句：数组名.length数组的最大索引值为：数组名.length-1 索引访问数组中的元素: 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，获取出数组中的元素 数组内存原理Java虚拟机的内存划分 一个数组内存图 两个独立数组内存图 两个变量指向同一个数组内存图","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--5.方法","slug":"Java基础--5.方法","date":"2019-07-03T08:32:38.000Z","updated":"2019-07-04T12:50:15.681Z","comments":true,"path":"2019/07/03/Java基础--5.方法/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础--5.方法/","excerpt":"","text":"方法: 就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 定义 修饰符 返回值类型 方法名 (参数列表){&emsp;&emsp;&emsp;&emsp;代码…&emsp;&emsp;&emsp;&emsp;return 返回值;} 定义格式解释: 修饰符: 目前固定写法 public static 返回值类型: 没有返回值时为&ensp;void 方法名:满足标识符的规范，用来调用方法。 参数列表: 参数 return:方法结束。返回值类型是void，方法大括号内的return可以不写，有返回值时返回给调用者。 举例： 123 public static void methodName() &#123; System.out.println(\"这是一个方法\");&#125; 方法定义注意事项: 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 方法的调用12345678 public static void main(String[] args) &#123; //调用定义的方法method method();&#125;//定义方法，被main方法调用 public static void method() &#123; System.out.println(\"自己定义的方法，需要被main调用运行\"); &#125; 上面方法为直接调用，有参数时括号内写入参数 还可以输出语句调用: 在输出语句中调用方法， System.out.println(方法名()) 。 不能用输出语句调用 void 类型的方法 方法重载 方法重载:指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。 参数列表:个数不同，数据类型不同，顺序不同。 重载方法调用:JVM通过方法的参数列表，调用不同的方法。 重载练习比较两个数据是否相等。参数类型分别为两个 byte 类型，两个 short 类型，两个 int 类型，两个 long 类型，并在 main 方法中进行测试。 123456789101112131415161718192021222324252627282930313233343536373839public class Method_Demo6 &#123; public static void main(String[] args) &#123; //定义不同数据类型的变量 byte a = 10; byte b = 20; short c = 10; short d = 20; int e = 10; int f = 10; long g = 10; long h = 20; // 调用 System.out.println(compare(a, b)); System.out.println(compare(c, d)); System.out.println(compare(e, f)); System.out.println(compare(g, h)); &#125; // 两个byte类型的 public static boolean compare(byte a, byte b) &#123; System.out.println(\"byte\"); return a == b; &#125; // 两个short类型的 public static boolean compare(short a, short b) &#123; System.out.println(\"short\"); return a == b; &#125; // 两个int类型的 public static boolean compare(int a, int b) &#123; System.out.println(\"int\"); return a == b; &#125; // 两个long类型的 public static boolean compare(long a, long b) &#123; System.out.println(\"long\"); return a == b; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--4.判断、选择、循环语句","slug":"Java基础--4.判断、选择、循环语句","date":"2019-07-03T07:38:22.000Z","updated":"2019-07-03T07:53:22.147Z","comments":true,"path":"2019/07/03/Java基础--4.判断、选择、循环语句/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础--4.判断、选择、循环语句/","excerpt":"","text":"判断语句 if 123if(关系表达式)&#123; 语句体;&#125; if…else 12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; if…else if…else 12345678910if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n; &#125; else &#123; 执行语句n+1; &#125; 注意：在某些简单的应用中，if语句是可以和三元运算符互换使用的。 1234567891011public static void main(String[] args) &#123; int a = 10; int b = 20; //定义变量，保存a和b的较大值 int c; if(a &gt; b) &#123; c = a; &#125; else &#123; c = b; &#125; //上述功能可以改写为三元运算符形式 c = a &gt; b ? a:b; &#125; 选择语句 switch 123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; switch语句中，表达式的数据类型，可以是byte，short，int，char，enum(枚举)，JDK7后可以接收字符串 注意：case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 循环语句 for循环 for(初始化表达式1; 布尔表达式2; 步进表达式4){ 循环体3} 执行顺序:1234&gt;234&gt;234…2不满足为止。 while循环 初始化表达式1 while(布尔表达式2){&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4} 执行顺序:1234&gt;234&gt;234…2不满足为止。 do…while循环 初始化表达式1 do{&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4}while(布尔表达式2); 执行顺序:134&gt;234&gt;234…2不满足为止。 for 和 while 的小区别: 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 跳出语句break -使用场景:终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景:结束本次循环，继续下一次的循环 嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Hexo博客导入图片","slug":"Hexo博客导入图片","date":"2019-07-03T07:13:20.000Z","updated":"2019-07-08T06:07:00.595Z","comments":true,"path":"2019/07/03/Hexo博客导入图片/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Hexo博客导入图片/","excerpt":"","text":"方法1 站点配置文件_config.yml 里的post_asset_folder:这个选项设置为true npm install hexo-asset-image --save 安装一个可以上传本地图片的插件 安装插件后hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片复制到xxxx这个文件夹中，在xxxx.md中按照markdown的格式引入图片(此处为了不被识别为图片就先这么写了)： 感叹号+[]括号内可输入替代文字+(xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看，html标签内的语句是img src=”2017/02/26/xxxx/图片名.jpg”，必须要有日期。 其它方法 本地source中建立img文件夹&lt;&gt; 内 img src=”img/图片名.jpg（此方法未详细试验） 图床 所遇问题 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理链接时出现路径错误，没有年月，无法显示图片。可直接安装已经修改过得插件npm install https://github.com/7ym0n/hexo-asset-image --save 由于title中有一些符号（比如（）、–等）用hexo new命令创建博客时，出现文件名称与文章title不符的情况在博客中没有图片时，并不产生影响，但当要插入图片时，在路径正确的情况下，依然显示不出图片解决办法暂时只是把 1.文件夹名称、2.md文件名称、3.title 这三者统一","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"}]},{"title":"hadoop安装与伪分布式搭建","slug":"hadoop安装与伪分布式搭建","date":"2019-06-29T09:30:52.000Z","updated":"2019-07-04T12:47:55.604Z","comments":true,"path":"2019/06/29/hadoop安装与伪分布式搭建/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/hadoop安装与伪分布式搭建/","excerpt":"","text":"创建Hadoop用户 创建新用户用户名为hadoop，使用/bin/bash作为shellsudo useradd -m hadoop -s /bin/bash 修改密码 1234$ sudo passwd hadoopEnter new UNIX password: Retype new UNIX password: passwd: password updated successfully 为hadoop用户添加管理员权限sudo adduser hadoop sudo 安装jdk1.7首先在oracle官网下载,接下来进行安装与环境变量配置，根据个人电脑系统选择对应版本，我选的是jdk-8u211-linux-x64.tar.gz 12345$ mkdir /usr/lib/jvm #创建jvm文件夹$ sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/lib/jvm #/ 解压到/usr/lib/jvm目录下$ cd /usr/lib/jvm #进入该目录$ mv jdk1.8.0_211 java #重命名为java$ vim ~/.bashrc #给JDK配置环境变量 在.bashrc文件添加如下指令： 1234export JAVA_HOME=/usr/lib/jvm/javaexport JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 在文件修改完毕以后，输入代码：$ source ~/.bashrc #使新配置的环境变量生效$ java -version #检测是否安装成功，查看java版本 安装SSH服务端 安装$ sudo apt-get install openssh-server 登录localhost$ ssh localhost之后会在~/文件夹下发现一个.ssh文件 设置为无密码登录123$ cd ~/.ssh/$ ssh-keygen -t rsa #出现提示直接按enter$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys #加入授权 此时就直接使用$ ssh localhost，无密码登录了。 安装Hadoop本文采用伪分布式模式：存储采用分布式文件系统HDFS，但是HDFS的节点和数据节点都在同一节点。 下载安装下载安装包后解压即可使用：1234$ sudo tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local$ cd /usr/local/$ sudo mv ./hadoop-2.7.1/ ./hadoop # 将文件夹名改为hadoop$ sudo chown -R hadoop ./hadoop # 修改文件权限 查看Hadoop版本信息： 12$ cd /usr/local/hadoop/bin$ ./hadoop version &lt;img src=”hadoop安装与伪分布式搭建/2.png&gt; 伪分布式模式配置修改配置文件:需要修改/usr/local/hadoop/etc/hadoop/文件夹下的core-site.xml和hdfs-site.xml文件。core-site.xml文件:将12&lt;configuration&gt;&lt;/configuration&gt; 修改为： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml文件修改如下： 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将/hadoop/etc/hadoop/hadoop-env.sh文件的JAVA_HOME改为绝对路径。将export JAVA_HOME=$JAVA_HOME改为export JAVA_HOME=/usr/lib/jvm/default-java 注意：Hadoop的运行方式是由配置文件决定的，如果想从伪分布式模式切换回单机模式，只需删除core-site.xml文件中的配置项即可 执行名称节点格式化执行如下命令：12$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format 出现如下错误 原因应该是权限不够无法再目录内新建文件。解决方案是：先输入命令：sudo su转为root身份输入命令：sudo chmod -R a+w /opt/hadoop-1.2.1/注意修改自己的安装路径。输入命令exit回到用户身份 再执行格式化成功。如果出现/usr/local/hadoop/tmp/dfs/name has been successfully formatted.和 Exiting with status 0，表示格式化成功。 启动Hadoop12$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh 用jps命令查看Hadoop是否启动成功，如果出现DataNode、NameNode、SecondaryNameNode的进程说明启动成功。 使用浏览器查看HDFS信息在浏览器中打开链接：http://localhost:50070/dfshealth.html#tab-overview即可查看 关闭Hadoop使用命令：./sbin/stop-dfs.sh下次启动时不需要再执行节点格式化命令（否则会报错），只需要直接运行start-dfs.sh命令即可。","categories":[{"name":"大数据环境搭建","slug":"大数据环境搭建","permalink":"http://mangosTeeN96.github.io/categories/大数据环境搭建/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://mangosTeeN96.github.io/tags/hadoop/"}]},{"title":"Java基础--3.数据类型转换、运算符","slug":"Java基础--3.数据类型转换、运算符","date":"2019-06-29T05:40:35.000Z","updated":"2019-06-29T08:51:36.966Z","comments":true,"path":"2019/06/29/Java基础--3.数据类型转换、运算符/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础--3.数据类型转换、运算符/","excerpt":"","text":"Java程序中要求参与的计算的数据，必须要保证数据类型的一致性（比如进行加法运算），如果数据类型不一致将发生类型的转换。 自动转换将 取值范围小的类型 自动提升为 取值范围大的类型 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 将 取值范围大的类型 强制转换成 取值范围小的类型 。 自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 转换格式： 数据类型 变量名 = (数据类型)被转数据值; 注意： 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 ASCII编码表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 1234567public static void main(String[] args) &#123; //字符类型变量 char c = 'a'; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98 &#125; 算数运算符 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 注意：变量在独立运算时， 前++ 和 后++ 没有区别 ；和其他变量放在一起， 前++ 和 后++ 就产生了不同（+1后赋值、赋值后+1）。 三元运算符格式： 数据类型 变量名 = 布尔类型表达式?结果1:结果2 计算方式:布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础-2.常量、变量","slug":"Java基础--2.常量、变量","date":"2019-06-29T05:38:16.000Z","updated":"2019-06-29T08:50:04.029Z","comments":true,"path":"2019/06/29/Java基础--2.常量、变量/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础--2.常量、变量/","excerpt":"","text":"常量 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’，’’， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值 true ， false 空常量 只有一个值 null 变量 Java的数据类型分为两大类: 基本数据类型:包括 整数、浮点数、字符、布尔。 引用数据类型:包括 类 、 数组 、 接口 。 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int(默认) 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double(默认) 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false 变量定义 格式： 数据类型 变量名 = 数据值;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--1.入门程序","slug":"Java基础--1.入门程序","date":"2019-06-29T05:26:32.000Z","updated":"2019-06-29T05:42:11.783Z","comments":true,"path":"2019/06/29/Java基础--1.入门程序/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础--1.入门程序/","excerpt":"","text":"HelloWorld入门程序Java程序开发三步骤:编写、编译、运行。 编写Java源程序 创建HelloWorld.java文件，代码如下： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 编译Java源文件 在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。命令: javac Java源文件名.后缀名 举例: 1javac HelloWorld.java 译成功后，产生一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 运行Java程序 在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。命令: java 类名字 举例： 1java HelloWolrd 入门程序说明 main方法： 称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释： 单行注释以 //开头 换行结束多行注释以 /*开头 以*/结束 关键字： 是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母。 标识符： 是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 HelloWorld案例中，出现的标识符有类名字 HelloWorld 。 命名规则： 硬性要求标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $(美元符号) 和 _(下划线) 。标识符不能以数字开头。标识符不能是关键字。软性要求类名规范:首字母大写，后面每个单词首字母大写(大驼峰式)。方法名规范: 首字母小写，后面每个单词首字母大写(小驼峰式)。变量名规范:全部小写","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"hexo markdown","slug":"hexo-markdown","date":"2019-06-28T10:24:45.000Z","updated":"2019-07-03T12:06:36.611Z","comments":true,"path":"2019/06/28/hexo-markdown/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hexo-markdown/","excerpt":"","text":"一些难记or有些不一样的markdown &lt; br&gt; 换行 两个空格+回车：换行 两个回车：换段落 空格+-，下一行-，会产生缩进序列 &amp;emsp ; 空一个汉字格数 &amp;ensp ; 空一个格","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://mangosTeeN96.github.io/tags/markdown/"}]},{"title":"hexo个人博客搭建","slug":"hexo个人博客搭建","date":"2019-06-28T04:47:04.000Z","updated":"2019-06-28T11:04:54.767Z","comments":true,"path":"2019/06/28/hexo个人博客搭建/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hexo个人博客搭建/","excerpt":"","text":"&emsp;&emsp;1. 安装node.js 打开nodejs.org下载安装包，直接点开安装包安装。 查看安装版本 node -v npm -v &emsp;&emsp;2. 安装hexo框架（以下若权限不足sudo） npm install -g hexo-cli hexo -v 查看hexo版本 &emsp;&emsp;3. 建立blog空文件夹（在用户文件夹中建立即可（位置随意）） mkdir blog 后续如果出现什么问题，把blog文件夹删除重新来即可。 cd blog &emsp;&emsp;4. 初始化博客 sudo hexo init &emsp;&emsp;5. 启动博客 hexo s 浏览器打开localhost:4000，可以看到默认创建的博客 &emsp;&emsp;6. 创建自己的博客 sudo hexo new &quot;测试&quot; cd source/_posts/ 编辑测试.md即可更改博客内容（markdown） cd ../..退回到blog目录下 &emsp;&emsp;7. 本地查看博客总结 hexo clean 清理一下 hexo g 生成一下 hexo s 启动一下 &emsp;&emsp;8. 建repository（为了博客部署到github上公开使用） 登陆自己的github账户，右上角+点开 New repositoryrepository name 必须是 ：昵称（前面的Owner）.github.io 点击greate，出现一个空仓库，保留页面 &emsp;&emsp;9. 安装部署插件 sudo npm install --save hexo-deployer-git 更改_config.yml文件 sudo vim _config.yml 到达文件最底部更改增加如下： 1234deploy: type: git repo: https://github.com/mangosTeeN96/mangosTeeN96.github.io.git branch: master 其中repo地址为刚刚创建的仓库页面的地址（注意冒号后面的空格） &emsp;&emsp;10. 部署到远端 hexo d 中途需要输入GitHub的账户密码 此时访问 mangosteen96.github.io 即可看到自己的博客 到此博客的基本部署就完成了 &emsp;&emsp;11. 更换博客主题 以yilia主题为例 sudo git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 此时themes文件夹中出现yilia文件夹，更改站点配置文件 找到theme：xxx 改为theme：yilia hexo clean hexo g hexo s 4000端口即可看到更改 hexo d 推到远端，mangosteen96.github.io 可以看到（主题更换可能要等一下下）","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-28T04:42:41.376Z","updated":"2019-06-28T04:42:41.377Z","comments":true,"path":"2019/06/28/hello-world/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}