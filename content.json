{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://mangosTeeN96.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-06-28T05:09:08.031Z","updated":"2019-06-27T03:19:17.751Z","comments":false,"path":"tags/index.html","permalink":"http://mangosTeeN96.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-06-28T05:09:08.005Z","updated":"2019-06-27T03:19:17.750Z","comments":false,"path":"categories/index.html","permalink":"http://mangosTeeN96.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-28T05:09:08.017Z","updated":"2019-06-27T03:19:17.750Z","comments":true,"path":"links/index.html","permalink":"http://mangosTeeN96.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础--6.数组","slug":"Java基础--6.数组","date":"2019-07-03T10:14:36.000Z","updated":"2019-07-03T11:14:00.319Z","comments":true,"path":"2019/07/03/Java基础--6.数组/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础--6.数组/","excerpt":"","text":"数组: 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 数组的特点： 数组是一种引用数据类型 数组当中的多个数据，类型必须统一 数组的长度在程序运行期间不可改变 定义数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 两种常见的初始化方式： 动态初始化（指定长度） 静态初始化（指定内容） 动态初始化数组 格式： 数据类型[] 数组名称 = new 数据类型[数组长度]; 解析含义：数据类型：数组当中数据的统一类型[]：代表我是一个数组new：代表创建数组的动作数组长度：指定长度 举例： 1int[] arr = new int[3]; 静态初始化 标准格式： 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 省略格式： 数据类型[] 数组名称 = { 元素1, 元素2, … } 举例： 123int[] arrA = new int[]&#123;1,2,3,4,5&#125;;int[] arrB = &#123;1,2,3,4,5&#125;; 注意： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度 静态初始化标准格式、动态初始化，可以拆分成为两个步骤 静态初始化省略格式不能拆分成为两个步骤 12int[] arrayB;arrayB = new int[] &#123; 11, 21, 31 &#125;; 数组的访问索引：从0开始，通过数组的索引访问到数组中的元素格式： 数组名[索引] 数组长度获得数组长度语句：数组名.length数组的最大索引值为：数组名.length-1 索引访问数组中的元素: 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，获取出数组中的元素 数组内存原理Java虚拟机的内存划分","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--5.方法","slug":"Java基础--5.方法","date":"2019-07-03T08:32:38.000Z","updated":"2019-07-03T10:12:53.344Z","comments":true,"path":"2019/07/03/Java基础--5.方法/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础--5.方法/","excerpt":"","text":"方法: 就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 定义 修饰符 返回值类型 方法名 (参数列表){&emsp;&emsp;&emsp;&emsp;代码…&emsp;&emsp;&emsp;&emsp;return 返回值;} 定义格式解释: 修饰符: 目前固定写法 public static 返回值类型: 没有返回值时为&ensp;void 方法名:满足标识符的规范，用来调用方法。 参数列表: 参数 return:方法结束。返回值类型是void，方法大括号内的return可以不写，有返回值时返回给调用者。 举例： 123 public static void methodName() &#123; System.out.println(&quot;这是一个方法&quot;);&#125; 方法定义注意事项: 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 方法的调用12345678 public static void main(String[] args) &#123; //调用定义的方法method method();&#125;//定义方法，被main方法调用 public static void method() &#123; System.out.println(&quot;自己定义的方法，需要被main调用运行&quot;); &#125; 上面方法为直接调用，有参数时括号内写入参数 还可以输出语句调用: 在输出语句中调用方法， System.out.println(方法名()) 。 不能用输出语句调用 void 类型的方法 方法重载 方法重载:指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。 参数列表:个数不同，数据类型不同，顺序不同。 重载方法调用:JVM通过方法的参数列表，调用不同的方法。 重载练习比较两个数据是否相等。参数类型分别为两个 byte 类型，两个 short 类型，两个 int 类型，两个 long 类型，并在 main 方法中进行测试。 123456789101112131415161718192021222324252627282930313233343536373839public class Method_Demo6 &#123; public static void main(String[] args) &#123; //定义不同数据类型的变量 byte a = 10; byte b = 20; short c = 10; short d = 20; int e = 10; int f = 10; long g = 10; long h = 20; // 调用 System.out.println(compare(a, b)); System.out.println(compare(c, d)); System.out.println(compare(e, f)); System.out.println(compare(g, h)); &#125; // 两个byte类型的 public static boolean compare(byte a, byte b) &#123; System.out.println(&quot;byte&quot;); return a == b; &#125; // 两个short类型的 public static boolean compare(short a, short b) &#123; System.out.println(&quot;short&quot;); return a == b; &#125; // 两个int类型的 public static boolean compare(int a, int b) &#123; System.out.println(&quot;int&quot;); return a == b; &#125; // 两个long类型的 public static boolean compare(long a, long b) &#123; System.out.println(&quot;long&quot;); return a == b; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--4.判断、选择、循环语句","slug":"Java基础--4.判断、选择、循环语句","date":"2019-07-03T07:38:22.000Z","updated":"2019-07-03T07:53:22.147Z","comments":true,"path":"2019/07/03/Java基础--4.判断、选择、循环语句/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础--4.判断、选择、循环语句/","excerpt":"","text":"判断语句 if 123if(关系表达式)&#123; 语句体;&#125; if…else 12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; if…else if…else 12345678910if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n; &#125; else &#123; 执行语句n+1; &#125; 注意：在某些简单的应用中，if语句是可以和三元运算符互换使用的。 1234567891011public static void main(String[] args) &#123; int a = 10; int b = 20; //定义变量，保存a和b的较大值 int c; if(a &gt; b) &#123; c = a; &#125; else &#123; c = b; &#125; //上述功能可以改写为三元运算符形式 c = a &gt; b ? a:b; &#125; 选择语句 switch 123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; switch语句中，表达式的数据类型，可以是byte，short，int，char，enum(枚举)，JDK7后可以接收字符串 注意：case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 循环语句 for循环 for(初始化表达式1; 布尔表达式2; 步进表达式4){ 循环体3} 执行顺序:1234&gt;234&gt;234…2不满足为止。 while循环 初始化表达式1 while(布尔表达式2){&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4} 执行顺序:1234&gt;234&gt;234…2不满足为止。 do…while循环 初始化表达式1 do{&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4}while(布尔表达式2); 执行顺序:134&gt;234&gt;234…2不满足为止。 for 和 while 的小区别: 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 跳出语句break -使用场景:终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景:结束本次循环，继续下一次的循环 嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Hexo博客导入图片","slug":"Hexo博客导入图片","date":"2019-07-03T07:13:20.000Z","updated":"2019-07-03T07:29:49.982Z","comments":true,"path":"2019/07/03/Hexo博客导入图片/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Hexo博客导入图片/","excerpt":"","text":"方法1 站点配置文件_config.yml 里的post_asset_folder:这个选项设置为true npm install hexo-asset-image --save 安装一个可以上传本地图片的插件 安装插件后hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片复制到xxxx这个文件夹中，在xxxx.md中按照markdown的格式引入图片(此处为了不被识别为图片就先这么写了)： 感叹号+[]括号内可输入替代文字+(xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看，html标签内的语句是img src=”2017/02/26/xxxx/图片名.jpg”，必须要有日期。 其它方法 本地source中建立img文件夹&lt;&gt; 内 img src=”img/图片名.jpg（此方法未详细试验） 图床 所遇问题由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理链接时出现路径错误，没有年月，无法显示图片。可直接安装已经修改过得插件npm install https://github.com/7ym0n/hexo-asset-image --save","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"}]},{"title":"hadoop安装与伪分布式搭建","slug":"hadoop安装与伪分布式搭建","date":"2019-06-29T09:30:52.000Z","updated":"2019-07-03T05:49:19.373Z","comments":true,"path":"2019/06/29/hadoop安装与伪分布式搭建/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/hadoop安装与伪分布式搭建/","excerpt":"","text":"创建Hadoop用户 创建新用户用户名为hadoop，使用/bin/bash作为shellsudo useradd -m hadoop -s /bin/bash 修改密码 1234$ sudo passwd hadoopEnter new UNIX password: Retype new UNIX password: passwd: password updated successfully 为hadoop用户添加管理员权限sudo adduser hadoop sudo 安装jdk1.7首先在oracle官网下载,接下来进行安装与环境变量配置，根据个人电脑系统选择对应版本，我选的是jdk-8u211-linux-x64.tar.gz 12345$ mkdir /usr/lib/jvm #创建jvm文件夹$ sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/lib/jvm #/ 解压到/usr/lib/jvm目录下$ cd /usr/lib/jvm #进入该目录$ mv jdk1.8.0_211 java #重命名为java$ vim ~/.bashrc #给JDK配置环境变量 在.bashrc文件添加如下指令： 1234export JAVA_HOME=/usr/lib/jvm/javaexport JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 在文件修改完毕以后，输入代码：$ source ~/.bashrc #使新配置的环境变量生效$ java -version #检测是否安装成功，查看java版本 安装SSH服务端 安装$ sudo apt-get install openssh-server 登录localhost$ ssh localhost之后会在~/文件夹下发现一个.ssh文件 设置为无密码登录123$ cd ~/.ssh/$ ssh-keygen -t rsa #出现提示直接按enter$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys #加入授权 此时就直接使用$ ssh localhost，无密码登录了。 安装Hadoop本文采用伪分布式模式：存储采用分布式文件系统HDFS，但是HDFS的节点和数据节点都在同一节点。 下载安装下载安装包后解压即可使用：1234$ sudo tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local$ cd /usr/local/$ sudo mv ./hadoop-2.7.1/ ./hadoop # 将文件夹名改为hadoop$ sudo chown -R hadoop ./hadoop # 修改文件权限 查看Hadoop版本信息： 12$ cd /usr/local/hadoop/bin$ ./hadoop version &lt;img src=”hadoop安装与伪分布式搭建/2.png&gt; 伪分布式模式配置修改配置文件:需要修改/usr/local/hadoop/etc/hadoop/文件夹下的core-site.xml和hdfs-site.xml文件。core-site.xml文件:将12&lt;configuration&gt;&lt;/configuration&gt; 修改为： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml文件修改如下： 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将/hadoop/etc/hadoop/hadoop-env.sh文件的JAVA_HOME改为绝对路径。将export JAVA_HOME=$JAVA_HOME改为export JAVA_HOME=/usr/lib/jvm/default-java 注意：Hadoop的运行方式是由配置文件决定的，如果想从伪分布式模式切换回单机模式，只需删除core-site.xml文件中的配置项即可 执行名称节点格式化执行如下命令：12$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format 出现如下错误 原因应该是权限不够无法再目录内新建文件。解决方案是：先输入命令：sudo su转为root身份输入命令：sudo chmod -R a+w /opt/hadoop-1.2.1/注意修改自己的安装路径。输入命令exit回到用户身份 再执行格式化成功。如果出现/usr/local/hadoop/tmp/dfs/name has been successfully formatted.和 Exiting with status 0，表示格式化成功。 启动Hadoop12$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh 用jps命令查看Hadoop是否启动成功，如果出现DataNode、NameNode、SecondaryNameNode的进程说明启动成功。 使用浏览器查看HDFS信息在浏览器中打开链接：http://localhost:50070/dfshealth.html#tab-overview即可查看 关闭Hadoop使用命令：./sbin/stop-dfs.sh下次启动时不需要再执行节点格式化命令（否则会报错），只需要直接运行start-dfs.sh命令即可。","categories":[{"name":"大数据环境搭建","slug":"大数据环境搭建","permalink":"http://mangosTeeN96.github.io/categories/大数据环境搭建/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://mangosTeeN96.github.io/tags/hadoop/"}]},{"title":"Java基础--3.数据类型转换、运算符","slug":"Java基础--3.数据类型转换、运算符","date":"2019-06-29T05:40:35.000Z","updated":"2019-06-29T08:51:36.966Z","comments":true,"path":"2019/06/29/Java基础--3.数据类型转换、运算符/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础--3.数据类型转换、运算符/","excerpt":"","text":"Java程序中要求参与的计算的数据，必须要保证数据类型的一致性（比如进行加法运算），如果数据类型不一致将发生类型的转换。 自动转换将 取值范围小的类型 自动提升为 取值范围大的类型 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 将 取值范围大的类型 强制转换成 取值范围小的类型 。 自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 转换格式： 数据类型 变量名 = (数据类型)被转数据值; 注意： 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 ASCII编码表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 1234567public static void main(String[] args) &#123; //字符类型变量 char c = 'a'; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98 &#125; 算数运算符 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 注意：变量在独立运算时， 前++ 和 后++ 没有区别 ；和其他变量放在一起， 前++ 和 后++ 就产生了不同（+1后赋值、赋值后+1）。 三元运算符格式： 数据类型 变量名 = 布尔类型表达式?结果1:结果2 计算方式:布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础-2.常量、变量","slug":"Java基础--2.常量、变量","date":"2019-06-29T05:38:16.000Z","updated":"2019-06-29T08:50:04.029Z","comments":true,"path":"2019/06/29/Java基础--2.常量、变量/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础--2.常量、变量/","excerpt":"","text":"常量 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’，’’， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值 true ， false 空常量 只有一个值 null 变量 Java的数据类型分为两大类: 基本数据类型:包括 整数、浮点数、字符、布尔。 引用数据类型:包括 类 、 数组 、 接口 。 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int(默认) 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double(默认) 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false 变量定义 格式： 数据类型 变量名 = 数据值;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础--1.入门程序","slug":"Java基础--1.入门程序","date":"2019-06-29T05:26:32.000Z","updated":"2019-06-29T05:42:11.783Z","comments":true,"path":"2019/06/29/Java基础--1.入门程序/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础--1.入门程序/","excerpt":"","text":"HelloWorld入门程序Java程序开发三步骤:编写、编译、运行。 编写Java源程序 创建HelloWorld.java文件，代码如下： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 编译Java源文件 在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。命令: javac Java源文件名.后缀名 举例: 1javac HelloWorld.java 译成功后，产生一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 运行Java程序 在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。命令: java 类名字 举例： 1java HelloWolrd 入门程序说明 main方法： 称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释： 单行注释以 //开头 换行结束多行注释以 /*开头 以*/结束 关键字： 是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母。 标识符： 是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 HelloWorld案例中，出现的标识符有类名字 HelloWorld 。 命名规则： 硬性要求标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $(美元符号) 和 _(下划线) 。标识符不能以数字开头。标识符不能是关键字。软性要求类名规范:首字母大写，后面每个单词首字母大写(大驼峰式)。方法名规范: 首字母小写，后面每个单词首字母大写(小驼峰式)。变量名规范:全部小写","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"hexo markdown","slug":"hexo-markdown","date":"2019-06-28T10:24:45.000Z","updated":"2019-07-03T08:39:47.062Z","comments":true,"path":"2019/06/28/hexo-markdown/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hexo-markdown/","excerpt":"","text":"一些难记or有些不一样的markdown &lt; br&gt; 换行 两个空格+回车：换行 两个回车：换段落 空格+-，下一行-，会产生缩进序列 &amp;emsp ; 空一个汉字格数","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://mangosTeeN96.github.io/tags/markdown/"}]},{"title":"hexo个人博客搭建","slug":"hexo个人博客搭建","date":"2019-06-28T04:47:04.000Z","updated":"2019-06-28T11:04:54.767Z","comments":true,"path":"2019/06/28/hexo个人博客搭建/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hexo个人博客搭建/","excerpt":"","text":"&emsp;&emsp;1. 安装node.js 打开nodejs.org下载安装包，直接点开安装包安装。 查看安装版本 node -v npm -v &emsp;&emsp;2. 安装hexo框架（以下若权限不足sudo） npm install -g hexo-cli hexo -v 查看hexo版本 &emsp;&emsp;3. 建立blog空文件夹（在用户文件夹中建立即可（位置随意）） mkdir blog 后续如果出现什么问题，把blog文件夹删除重新来即可。 cd blog &emsp;&emsp;4. 初始化博客 sudo hexo init &emsp;&emsp;5. 启动博客 hexo s 浏览器打开localhost:4000，可以看到默认创建的博客 &emsp;&emsp;6. 创建自己的博客 sudo hexo new &quot;测试&quot; cd source/_posts/ 编辑测试.md即可更改博客内容（markdown） cd ../..退回到blog目录下 &emsp;&emsp;7. 本地查看博客总结 hexo clean 清理一下 hexo g 生成一下 hexo s 启动一下 &emsp;&emsp;8. 建repository（为了博客部署到github上公开使用） 登陆自己的github账户，右上角+点开 New repositoryrepository name 必须是 ：昵称（前面的Owner）.github.io 点击greate，出现一个空仓库，保留页面 &emsp;&emsp;9. 安装部署插件 sudo npm install --save hexo-deployer-git 更改_config.yml文件 sudo vim _config.yml 到达文件最底部更改增加如下： 1234deploy: type: git repo: https://github.com/mangosTeeN96/mangosTeeN96.github.io.git branch: master 其中repo地址为刚刚创建的仓库页面的地址（注意冒号后面的空格） &emsp;&emsp;10. 部署到远端 hexo d 中途需要输入GitHub的账户密码 此时访问 mangosteen96.github.io 即可看到自己的博客 到此博客的基本部署就完成了 &emsp;&emsp;11. 更换博客主题 以yilia主题为例 sudo git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 此时themes文件夹中出现yilia文件夹，更改站点配置文件 找到theme：xxx 改为theme：yilia hexo clean hexo g hexo s 4000端口即可看到更改 hexo d 推到远端，mangosteen96.github.io 可以看到（主题更换可能要等一下下）","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-28T04:42:41.376Z","updated":"2019-06-28T04:42:41.377Z","comments":true,"path":"2019/06/28/hello-world/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}