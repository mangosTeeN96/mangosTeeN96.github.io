{"meta":{"title":"MangosTeen","subtitle":null,"description":"想养一只猫","author":"MangosTeen","url":"http://mangosTeeN96.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-19T05:33:22.000Z","updated":"2019-08-19T05:34:22.599Z","comments":true,"path":"categories/index.html","permalink":"http://mangosTeeN96.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-06-28T05:09:08.017Z","updated":"2019-06-27T03:19:17.750Z","comments":true,"path":"links/index.html","permalink":"http://mangosTeeN96.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-19T05:28:46.000Z","updated":"2019-08-19T05:29:59.602Z","comments":true,"path":"tags/index.html","permalink":"http://mangosTeeN96.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vim基本命令","slug":"Vim基本命令","date":"2019-08-25T12:18:17.000Z","updated":"2019-08-25T12:38:10.399Z","comments":true,"path":"2019/08/25/Vim基本命令/","link":"","permalink":"http://mangosTeeN96.github.io/2019/08/25/Vim基本命令/","excerpt":"","text":"Vim命令 代码操作 命令 作用 yy 复制 光标所在的这一行 4yy 复制 光标所在的行开始向下的4行 p 粘贴 dd 剪切 光标所在行 4dd 向下4行 D 从光标开始剪切，一直到行末 d0 从光标开始剪切，一直到行首 dw 删除这个单词 x 删除当前光标，每次只删除一个 X 删除当前光标前面的那个，每次只删除一个 u 撤销刚刚操作(可多次） ctrl+r 反撤销 . 重复执行上一次命令 定位操作 命令 作用 h，j，k，l 命令下的光标 左，下，上，右 H，M，L 当前屏幕的 上方，中间，下方 ctrl+f 向下翻一页代码 ctrl+b 向上翻一页代码 20G 快速定位到第20行代码 G 快速回到整个代码的最后一行 gg 快速回到整个代码的第一行 w 向后跳一个单词的长度，即下一个单词的开始 b 向前 移动替换 命令 作用 { 按段移动，上移 } 按段移动，下移 v 选中（配合上下左右可以选中一片）光标在哪选到哪 V 选中，光标所在行都选中 &gt; 整体向右移动代码 &lt; 向左 r 替换当前字符(输入r后输入替换后的字符） R 替换当前行光标后的字符 查找替换、保存退出 命令 作用 / 查找（搜不存在的可去掉颜色） n下一个搜索到的 N上一个 %s///g(：末行模式下） /被替换/替换/ 11,16s///g 替换11到16行 vim 4.py vim下 创建or进入4.py vi (似乎更方便，再次进入的时候） ：w （末行模式） 保存 ：q 直接退出（没保存的话会提示） ：q！ 不保存退出 ：wq或者x 保存并退出 shift+zz 相当于末行模式的wq ctrl+N查看已经定义的变量","categories":[{"name":"Vim","slug":"Vim","permalink":"http://mangosTeeN96.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://mangosTeeN96.github.io/tags/Vim/"}]},{"title":"Linux以及命令.md","slug":"Linux以及命令","date":"2019-08-25T11:24:06.000Z","updated":"2019-08-25T12:15:14.767Z","comments":true,"path":"2019/08/25/Linux以及命令/","link":"","permalink":"http://mangosTeeN96.github.io/2019/08/25/Linux以及命令/","excerpt":"","text":"Linux操作系统命令： 命令 作用 command + 调大字体 - 调小 ls 当前路径下所有文件夹和名字 pwd 目前处在的路径，第一个/为根目录 cd 切换路径 clear 清屏 命令基本格式:命令 选项 参数选项的格式为:-选项 命令 作用 ls -a 创建的文件的名字以.开头，则为隐藏文件，ls命令看不见。此时运行ls -a，则能看见 ls -l 以列表方式显示 ls -l -h 显示列表的时候会给数字显示一个合适的单位 可以ls -a -l -h一起使用，顺序无所谓，ls -alh 查看帮助文档 命令 作用 命令 –help man 命令 （进入后不能输入命令，按q退出，f向下翻一屏，b向上） man 2 命令 查看c语言下的帮助文档 history 查看历史命令 对文件（夹）的操作 命令 作用 tab键 文件名补全 touch 新建文件 mkdir 创建文件夹 rmdir 删除文件夹（非空删除不了） open 打开并编辑文件 cat 查看文件 cat 123.txt 234.txt 会同时显示两个文件的内容 cat 123.txt 234.txt &gt; xxx.txt 合并两个文件的内容到一个文件xxx.txt more 查看文件（适合大文件，不会全显示出来，显示一页，按f键翻页，q退出) 可以结合ls命令：ls -ahl /bin ` rm 删除命令 可以删除非空文件夹：rm -r 文件夹名。不想一直询问，直接删除-rf mv 123.txt 789.txt 重命名，原文件名 新文件名 mv 789.txt A 剪切文件到A文件夹 cp 复制粘贴 不让copy文件夹，加-r，遇到文件夹不让动的，多数可以加-r解决（-r：递归） 文件中查找操作 命令 作用 grep “s” xxx.txt 在xxx.txt中查找s grep -n “s” xxx.txt 搜索显示前面会带有在哪一行 grep -n “s” xxx.txt 查找不包含s的 grep “^s” xxx.txt 查找以s开头的 grep “s$” xxx.txt 查找以s结尾的 通配符 命令 作用 ls 2* 只查看以2开头的文件 ls *.txt 只查看.txt文件 *代表的位数可以为0到n位（不只可以与ls合用，与rm等也可以一起） ls 2？ 查看以2开头且只有两位 几个？则几位 ls 2？3 .txt ls 2[12345]3.txt 查看213到253之间到文件（可以写成1-5） 重定向 命令 作用 ls -ahl &gt; xxx.txt 创建了xxx.txt文件，并且把命令ls -ahl应该显示的内容存放进去 &gt;&gt; 追加，会在原来的末尾把当前内容追加进去 如果只&gt;，会把原来的删除。如果原来没有这个文件，&gt;&gt;也会创建文件。 路径 相对路径 从当前路径算起 绝对路径 从根目录算起 cd时不知道下一层文件夹名字，可以按两次tab键，会把能补全的文件夹名字全显示出来 cd A 跳转到（当前路径的）A文件夹 cd ./A 跳转到当前路径的A文件夹 cd .. 跳转到上一层文件夹 cd ../.. 上上层 跳转文件距离根目录近，用绝对路径，距离当前文件近，用相对路径。 cd - 跳转到上一次操作所在路径（最多只能记忆一次，再次使用就跳回来了） cd ~ 回到家目录 链接 命令 作用 ln -s 789.txt 789-softlink.txt 创建软链接文件（快捷方式） 原文件删除，软链接文件没有用了 ln 789.txt 789-hardlink.txt 创建硬链接文件（快捷方式） 硬链接文件相当于给原文件重新起名，原文件删除，硬链接文件数据仍然在。 如果写完一行命令不想执行，按control+C，则直接换行。 文件查找操作 命令 作用 find 在一个路径里找东西 find / -name “” 在根目录里按名字找，名字里带双引号里的 如果有没有权限的，在find前加sudo find ./ 在当前目录查找 按照文件名查找 find / -name httpd.conf 在根目录下查找文件httpd.conf，表示在整个硬盘查找 find /etc -name httpd.conf 在/etc目录下文件httpd.conf find /etc -name ‘srm‘ 使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件 find . -name ‘srm*’ 表示当前目录下查找文件名开头是字符串‘srm’的文件 -size 按大小找 2M 大小等于 +2M 大小大于2M的文件 归档管理 tar tar -cvf test.tar *.py 将*.py的文件打包为test.tar tar -xvf test.tar 将test.tar解压到当前文件夹，压缩包不删 打包不压缩 tar -zcvf test.tar.gz *.py 压缩 tar -zxvf 解压缩 tar -jcvf test.tar.bz2 *.py 另一种压缩方式 tar -jxvf 解 tar 在命令后面加-C，加指定路径 解压到指定路径 一般用上面这两种压缩 zip test.zip *.py 压缩为zip文件（压缩效果不好） unzip test.zip 解 一些其它命令 命令 作用 links … 打开网页 which 查看用的命令在哪个路径下的文件 cal 日历 cal -y 2008 date 日期时间 ps aux ; top 查看当前运行情况（任务管理器） kill PID码 结束那个进程 kill后加-9 强制结束 reboot 重启 shutdown -h now 立刻关机 +10 10分钟后关机 20:20 df df -h 查看硬盘使用情况 du -h 当前路径使用情况 ifconfig 查看当前电脑上的网卡信息 ping +IP地址 测试远程电脑联通情况，能否通信 useradd shuaige -m 添加用户 sudo（没有权限） passwd shuaige 更改密码 su shuaige 切换账户 exit 退出 whoami 当前用户是谁 userdel shuaige 删除账户 userdel -r shuaige 同时删除家目录 sudo 拥有超级管理员的权限 sudo -s 变成超级管理员(root) groupadd shuaige 创建组 groupdel 删除 cat /etc/group 查看所有组 ls -alf","categories":[{"name":"Linux","slug":"Linux","permalink":"http://mangosTeeN96.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://mangosTeeN96.github.io/tags/Linux/"}]},{"title":"Java_继承与多态","slug":"Java_继承与多态","date":"2019-07-09T03:16:06.000Z","updated":"2019-08-21T15:53:59.131Z","comments":true,"path":"2019/07/09/Java_继承与多态/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/09/Java_继承与多态/","excerpt":"","text":"一、继承多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为子类，单独那一个类称为父类、超类(superclass)或者基类。 继承描述的是事物之间的所属关系，这种关系是: is-a 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 定义： 继承:就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 1.1 格式123456public class 父类 &#123; ...&#125;public class 子类 extends 父类 &#123; ...&#125; 1.2 成员变量访问在父子类的继承关系当中，如果成员变量重名，则： 直接通过子类对象访问成员变量： 等号左边是谁，就优先用谁，没有则向上找。 间接通过成员方法访问成员变量： 该方法属于谁，就优先用谁，没有则向上找 三种变量写法整理： 局部变量：&emsp;&emsp;&emsp; 直接写成员变量名 本类的成员变量： this.成员变量名 父类的成员变量： super.成员变量 父类： 123public class Fu &#123; int num = 10;&#125; 子类： 1234567891011public class Zi extends Fu &#123; int num = 20; public void method() &#123; int num = 30; System.out.println(num); // 30，局部变量 System.out.println(this.num); // 20，本类的成员变量 System.out.println(super.num); // 10，父类的成员变量 &#125;&#125; 1.3 成员方法 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。 注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的 重写（覆盖重写）– 成员方法重名方法重写 :子类中出现与父类一模一样的方法时(返回值类型，方法名和参数列表都相同)会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 特点：创建的是子类对象，则优先用子类方法 注意事项： 必须保证父子类之间方法的名称相同，参数列表也相同。 @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。 这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。 子类方法的返回值必须【小于等于】父类方法的返回值范围。 小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。 子类方法的权限必须【大于等于】父类方法的权限修饰符。 小扩展提示：public &gt; protected &gt; (default) &gt; private备注：(default)不是关键字default，而是什么都不写，留空。 (其实多数情况这些范围权限都是相等的) 应用： 12345public class Phone &#123; public void show() &#123; System.out.println(\"显示号码\"); &#125;&#125; 12345678910public class NewPhone extends Phone &#123; @Override public void show() &#123; super.show(); // 把父类的show方法拿过来重复利用 // 自己子类再来添加更多内容 System.out.println(\"显示姓名\"); System.out.println(\"显示头像\"); &#125;&#125; 1.4构造方法继承关系中，父子类构造方法的访问特点： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 12345678public class Fu &#123; public Fu() &#123; System.out.println(\"父类无参构造\"); &#125; public Fu(int num) &#123; System.out.println(\"父类有参构造！\"); &#125;&#125; 123456789101112public class Zi extends Fu &#123; public Zi() &#123; super(); // 在调用父类无参构造方法// super(20); // 在调用父类重载的构造方法 System.out.println(\"子类构造方法！\"); &#125; public void method() &#123;// super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。 &#125;&#125; 总结：子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。 super关键字用法总结： 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 this关键字用法总结： super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种： 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意：A. this(…)调用也必须是构造方法的第一个语句，唯一一个。B. super和this两种构造调用，不能同时使用 super与this的内存图: 1.5 继承的特点 java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 Java支持多层继承(继承体系)。 子类和父类是一种相对的概念。 二、抽象类没有方法主体的方法称为抽象方法包含抽象方法的类就是抽象类 抽象方法概念图： 2.1 格式抽象类与抽象方法格式： 123456public abstract class Animal &#123; // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。 public abstract void eat();&#125; 2.2 使用使用抽象类和抽象方法： 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使用。 注意事项： 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。理解:子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类。理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 2.3 案例案例分析： 用户父类: 123456789101112131415161718192021222324252627282930public class User &#123; private String name; // 姓名 private int money; // 余额，也就是当前用户拥有的钱数 public User() &#123; &#125; public User(String name, int money) &#123; this.name = name; this.money = money; &#125; // 展示一下当前用户有多少钱 public void show() &#123; System.out.println(\"我叫：\" + name + \"，我有多少钱：\" + money); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getMoney() &#123; return money; &#125; public void setMoney(int money) &#123; this.money = money; &#125;&#125; 群主子类： 123456789101112131415161718192021222324252627282930313233343536373839public class Manager extends User &#123; public Manager() &#123; &#125; public Manager(String name, int money) &#123; super(name, money); &#125; public ArrayList&lt;Integer&gt; send(int totalMoney, int count) &#123; // 首先需要一个集合，用来存储若干个红包的金额 ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;(); // 看一下群主自己有多少钱 int leftMoney = super.getMoney(); // 群主当前余额 if (totalMoney &gt; leftMoney) &#123; System.out.println(\"余额不足\"); return redList; // 返回空集合 &#125; // 扣钱，其实就是重新设置余额 super.setMoney(leftMoney - totalMoney); // 发红包需要平均拆分成为count份 int avg = totalMoney / count; int mod = totalMoney % count; // 余数，也就是甩下的零头 // 除不开的零头，包在最后一个红包当中 // 下面把红包一个一个放到集合当中 for (int i = 0; i &lt; count - 1; i++) &#123; redList.add(avg); &#125; // 最后一个红包 int last = avg + mod; redList.add(last); return redList; &#125;&#125; 群成员子类： 1234567891011121314151617181920public class Member extends User &#123; public Member() &#123; &#125; public Member(String name, int money) &#123; super(name, money); &#125; public void receive(ArrayList&lt;Integer&gt; list) &#123; // 从多个红包当中随便抽取一个，给我自己。 // 随机获取一个集合当中的索引编号 int index = new Random().nextInt(list.size()); // 根据索引，从集合当中删除，并且得到被删除的红包，给我自己 int delta = list.remove(index); // 当前成员自己本来有多少钱： int money = super.getMoney(); // 加法，并且重新设置回去 super.setMoney(money + delta); &#125;&#125; 发红包： 123456789101112131415161718192021222324252627282930public class MainRedPacket &#123; public static void main(String[] args) &#123; Manager manager = new Manager(\"群主\", 100); Member one = new Member(\"成员A\", 0); Member two = new Member(\"成员B\", 0); Member three = new Member(\"成员C\", 0); manager.show(); // 100 one.show(); // 0 two.show(); // 0 three.show(); // 0 System.out.println(\"===============\"); // 群主总共发20块钱，分成3个红包 ArrayList&lt;Integer&gt; redList = manager.send(20, 3); // 三个普通成员收红包 one.receive(redList); two.receive(redList); three.receive(redList); manager.show(); // 100-20=80 // 6、6、8，随机分给三个人 one.show(); two.show(); three.show(); &#125;&#125; 三、接口接口就是多个类的公共规范。 接口，是Java语言中一种引用类型，是方法的集合。如果说类的内部封装了成员变量、构造方法和成员方法，那么，接口的内部主要就是封装了方法，包含抽象方法(JDK 7及以前)，默认方法和静态方法(JDK 8)，私有方法 (JDK 9)。 3.1 格式 public interface 接口名称 {&emsp;&emsp;&emsp;&emsp;// 抽象方法&emsp;&emsp;&emsp;&emsp;// 默认方法&emsp;&emsp;&emsp;&emsp;// 静态方法&emsp;&emsp;&emsp;&emsp;// 私有方法} 3.2 实现（接口的使用）实现格式： public class 实现类名称 implements 接口名称 {&emsp;&emsp;&emsp;&emsp;// …} 接口不能直接使用，必须有一个“实现类”来“实现”该接口。 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号。 创建实现类的对象，进行使用。 接口 MyInterfaceAbstract 1234public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbs()&#125; 实现类 MyInterfaceAbstractImpl 123456public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123; @Override public void methodAbs() &#123; System.out.println(\"这是一个方法！\"); &#125;&#125; 接口实现 1234567891011public class Demo01Interface &#123; public static void main(String[] args) &#123; // 错误写法！不能直接new接口对象使用。// MyInterfaceAbstract inter = new MyInterfaceAbstract(); // 创建实现类的对象使用 MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbs() &#125;&#125; 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。 3.3 抽象方法格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。） 方法的三要素，可以随意定义 3.4 默认方法可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 格式： public default 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 备注：接口当中的默认方法，可以解决接口升级的问题 接口 1234567891011121314public interface MyInterfaceDefault &#123; // 抽象方法 public abstract void methodAbs(); // 新添加了一个抽象方法// public abstract void methodAbs2(); // 新添加的方法，改成默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125; 实现类A（未重写） 123456public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，AAA\"); &#125;&#125; 实现类B（重写） 1234567891011public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodAbs() &#123; System.out.println(\"实现了抽象方法，BBB\"); &#125; @Override public void methodDefault() &#123; System.out.println(\"实现类B覆盖重写了接口的默认方法\"); &#125;&#125; 主代码 1234567891011121314151617public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 System.out.println(\"==========\"); MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodAbs(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125; 3.5 静态方法格式： public static 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 只能使用接口名调用(直接在主代码中调用) 不可以通过实现类的类名或者实现类的对象调用 调用格式： 接口名称.静态方法名(参数); 3.6 私有方法问题描述：我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。 普通私有方法 解决多个默认方法之间重复代码问题格式： private 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 12345678910111213141516171819public interface MyInterfacePrivateA &#123; public default void methodDefault1() &#123; System.out.println(\"默认方法1\"); methodCommon(); &#125; public default void methodDefault2() &#123; System.out.println(\"默认方法2\"); methodCommon(); &#125; private void methodCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 静态私有方法 解决多个静态方法之间重复代码问题格式： private static 返回值类型 方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;方法体} 3.7 常量接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰 从效果上看，这其实就是接口的常量 格式： public static final 数据类型 常量名称 = 数据值; 接口 123456public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 主代码 12345678public class Demo05Interface &#123; public static void main(String[] args) &#123; // 访问接口当中的常量 System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS); &#125;&#125; 一旦使用final关键字进行修饰，说明不可改变。 注意事项： 接口当中的常量，可以省略public static final不写也一样。 接口当中的常量，必须赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 3.8 接口使用注意事项 接口是没有静态代码块或者构造方法的。 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式： public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {&emsp;&emsp;&emsp;&emsp;// 覆盖重写所有抽象方法} 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。 如果实现类锁实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。 一个类如果它的直接父类当中的方法，和接口当中的默认方法产生了冲突（重名），优先用父类当中的方法。 接口A： 1234567891011public interface MyInterfaceA &#123; public abstract void methodA(); public abstract void methodabs(); public default void methodDefault()&#123; System.out.println(\"默认方法AAA\"); &#125;&#125; 接口B： 12345678910public interface MyInterfaceB &#123; public abstract void methodB(); public abstract void methodabs(); public default void methodDefault()&#123; System.out.println(\"默认方法BBB\"); &#125;&#125; 实现类： 12345678910111213141516171819202122public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA, MyInterfaceB &#123; @Override public void methodA() &#123; System.out.println(\"覆盖重写了A方法\"); &#125; @Override public void methodB() &#123; System.out.println(\"覆盖重写了B方法\"); &#125; @Override public void methodAbs() &#123; System.out.println(\"覆盖重写了AB接口都有的抽象方法\"); &#125; @Override public void methodDefault() &#123; System.out.println(\"对多个接口当中冲突的默认方法进行了覆盖重写\"); &#125;&#125; 3.9 接口的多继承 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似 接口的继承使用 extends 关键字，子接口继承父接口的方法 如果父接口中的默认方法有重名的，那么子接口需要重写一次 四、多态多态是继封装、继承之后，面向对象的第三大特性。 多态: 是指同一行为，具有多个不同表现形式。 前提： 继承或者实现 方法的重写(意义体现:不重写，无意义) 父类引用指向子类对象 4.1 格式 父类名称 对象名 = new 子类名称(); 或者： 接口名称 对象名 = new 实现类名称(); 当使用多态方式调用方法时，首先检查父类中是否有该方法 如果没有，则编译错误 如果有，执行的是子类重写后方法 父类： 123public abstract class Animal &#123; public abstract void eat();&#125; 子类： 12345class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125;&#125; 测试类 12345678public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Animal a = new Cat(); // 调用的是 Cat 的 eat a.eat(); &#125; &#125; 4.2 成员变量多态中成员变量的使用特点，与之前的笔记中一样。 访问成员变量的两种方式(Fu obj = new Zi())： 直接通过对象名称（obj.num)访问成员变量：看等号左边是谁，优先用谁，没有则向上找。(成员变量不能覆盖重写) 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 4.3 成员方法多态中，成员方法的访问规则(也和以前一样)：&emsp;&emsp;&emsp;看new的是谁，就优先用谁，没有则向上找。 特殊之处：编译看左边，运行看右边 对比一下： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边 4.4 使用多态的好处 多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 4.5 引用类型转型多态的转型分为向上转型与向下转型两种: 向上转型 当父类引用指向一个子类对象(接口、实现类)时，便是向上转型。 多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 格式（即多态）： 父类类型 变量名 = new 子类类型();如： Animal animal = new Cat(); 向上转型一定是安全的，没有问题的，正确的 但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 解决方案：用对象的向下转型【还原】 向下转型 一个已经向上转型的子类对象（实现类），将父类（接口）引用转为子类引用（还原），可以使用强制类型转换的格式，便是向下转型 格式： 子类类型 变量名 = (子类类型) 父类变量名;如：Cat cat = (Cat) animal instanceof关键字如何才能知道一个父类引用的对象，本来是什么子类？ 格式： 对象 instanceof 类名称 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例 1234567891011121314151617public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125;&#125; 4.5 接口多态综合案例笔记本电脑(laptop)通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口， 但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。 定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守 USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 分析：进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要实现USB接口，并具备点击的方法 键盘类，要实现USB接口，具备敲击的方法 USB: 1234567public interface USB &#123; public abstract void open(); // 打开设备 public abstract void close(); // 关闭设备&#125; 笔记本： 123456789101112131415161718192021222324public class Computer &#123; public void powerOn() &#123; System.out.println(\"笔记本电脑开机\"); &#125; public void powerOff() &#123; System.out.println(\"笔记本电脑关机\"); &#125; // 使用USB设备的方法，使用接口作为方法的参数 public void useDevice(USB usb) &#123; usb.open(); // 打开设备 if (usb instanceof Mouse) &#123; // 一定要先判断 Mouse mouse = (Mouse) usb; // 向下转型 mouse.click(); &#125; else if (usb instanceof Keyboard) &#123; // 先判断 Keyboard keyboard = (Keyboard) usb; // 向下转型 keyboard.type(); &#125; usb.close(); // 关闭设备 &#125;&#125; 鼠标： 12345678910111213141516// 鼠标就是一个USB设备public class Mouse implements USB &#123; @Override public void open() &#123; System.out.println(\"打开鼠标\"); &#125; @Override public void close() &#123; System.out.println(\"关闭鼠标\"); &#125; public void click() &#123; System.out.println(\"鼠标点击\"); &#125;&#125; 键盘： 12345678910111213141516// 键盘就是一个USB设备public class Keyboard implements USB &#123; @Override public void open() &#123; System.out.println(\"打开键盘\"); &#125; @Override public void close() &#123; System.out.println(\"关闭键盘\"); &#125; public void type() &#123; System.out.println(\"键盘输入\"); &#125;&#125; Main代码: 123456789101112131415161718192021222324252627public class DemoMain &#123; public static void main(String[] args) &#123; // 首先创建一个笔记本电脑 Computer computer = new Computer(); computer.powerOn(); // 准备一个鼠标，供电脑使用// Mouse mouse = new Mouse(); // 首先进行向上转型 USB usbMouse = new Mouse(); // 多态写法 // 参数是USB类型，我正好传递进去的就是USB鼠标 computer.useDevice(usbMouse); // 创建一个USB键盘 Keyboard keyboard = new Keyboard(); // 没有使用多态写法 // 方法参数是USB类型，传递进去的是实现类对象 computer.useDevice(keyboard); // 正确写法！也发生了向上转型 // 使用子类对象，匿名对象，也可以// computer.useDevice(new Keyboard()); // 也是正确写法 computer.powerOff(); System.out.println(\"==================\"); &#125;&#125; 五、final关键字 final: 不可改变。可以用于修饰类、方法和变量 类:被修饰的类，不能被继承 方法:被修饰的方法，不能被重写 变量:被修饰的变量，不能被重新赋值 5.1 修饰类格式： public final class 类名{&emsp;&emsp;&emsp;&emsp;//} 当前这个类不能有任何的子类 注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没子类） 5.2 修饰方法格式： 修饰符 final 返回值类型 方法名(参数列表){&emsp;&emsp;&emsp;&emsp;//方法体} 例如：public final void method(){//} 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 5.3 局部变量 基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // “一次赋值，终生不变” final int num2 = 200; System.out.println(num2); // 200// num2 = 250; // 错误写法！不能改变！ // 正确写法！只要保证有唯一一次赋值即可 final int num3; num3 = 30; // 对于引用类型来说，不可变说的是变量当中的地址值不可改变 //未使用final Student stu1 = new Student(\"赵丽颖\"); System.out.println(stu1.getName()); // 赵丽颖 stu1 = new Student(\"霍建华\"); System.out.println(stu1.getName()); // 霍建华 //使用final final Student stu2 = new Student(\"高圆圆\"); // 错误写法！final的引用类型变量，其中的地址不可改变// stu2 = new Student(\"赵又廷\"); System.out.println(stu2.getName()); // 高圆圆 stu2.setName(\"高圆圆圆圆圆圆\"); System.out.println(stu2.getName()); // 高圆圆圆圆圆圆 &#125; 5.4 成员变量对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。 由于成员变量具有默认值，所以用了final之后必须手动赋值，用了final不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值 1234567891011121314151617181920public class Person &#123; private final String name/* = \"鹿晗\"*/;//直接赋值 public Person() &#123; name = \"关晓彤\"; //构造方法赋值 &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;// public void setName(String name) &#123;// this.name = name;// &#125;&#125; 六、内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 分为：成员内部类、局部内部类（包含匿名内部类) 6.1 成员内部类格式 修饰符 class 外部类名称 {&emsp;&emsp;&emsp;&emsp;修饰符 class 内部类名称 {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// …&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;// …} 访问特点 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 使用成员内部类的方法： 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 类： 1234567891011121314151617181920212223242526272829public class Body &#123; // 外部类 public class Heart &#123; // 成员内部类 // 内部类的方法 public void beat() &#123; System.out.println(\"心脏跳动：蹦蹦蹦！\"); System.out.println(\"我叫：\" + name); // 正确写法！ &#125; &#125; // 外部类的成员变量 private String name; // 外部类的方法 public void methodBody() &#123; System.out.println(\"外部类的方法\"); new Heart().beat(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; main 代码： 1234567891011121314public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); // 外部类的对象 // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); System.out.println(\"=====================\"); // 按照公式写： Body.Heart heart = new Body().new Heart(); heart.beat(); &#125;&#125; 同名变量访问格式： 外部类名称.this.外部类成员变量名 格式举例： 123456789101112131415161718public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 6.2 局部内部类 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类 “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了 格式 修饰符 class 外部类名称 {&emsp;&emsp;&emsp;&emsp;修饰符 返回值类型 外部类方法名称(参数列表) {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;class 局部内部类名称 {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// …&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}&emsp;&emsp;&emsp;&emsp;}} 类： 123456789101112131415class Outer &#123; public void methodOuter() &#123; class Inner &#123; // 局部内部类 int num = 10; public void methodInner() &#123; System.out.println(num); // 10 &#125; &#125; Inner inner = new Inner(); inner.methodInner(); &#125;&#125; main代码： 12345678public class DemoMain &#123; public static void main(String[] args) &#123; Outer obj = new Outer(); obj.methodOuter(); &#125;&#125; 权限修饰符定义一个类的时候，权限修饰符规则： 外部类：public / (default) 成员内部类：public / protected / (default) / private 局部内部类：什么都不能写 final问题局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的。 备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 比如： 12345678910111213public class MyOuter &#123; public void methodOuter() &#123; int num = 10; // 所在方法的局部变量 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125; &#125;&#125; 6.3 匿名内部类 匿名内部类：是内部类的简化写法。本质：带具体实现的 父类（父接口） 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类 缘由： 以接口举例，当你使用一个接口时，似乎得做如下几步操作， 定义实现类 重写接口中的方法 创建子类对象 调用重写后的方法 匿名内部类是对此的简化 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次比如多态情况MyInterface obj = new MyInterfaceImpl();那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类 格式 接口名称 对象名 = new 接口名称() {&emsp;&emsp;&emsp;&emsp;// 覆盖重写所有抽象方法}; 有点类似把实现类的内容拿出来了，把实现类的名字匿了 注意事项 匿名内部类，在创建对象的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，要么重复写两遍，要么就需要使用单独定义的实现类了。 匿名对象，在调用方法的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，要么重复写两遍，要么必须给对象起个名字。 匿名内部类是省略了实现类/子类名称，但是匿名对象是省略了对象名称强调：匿名内部类和匿名对象不是一回事！！！ 6.4 类作为成员变量英雄 123456789101112131415161718192021public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; // getter、setter省略&#125; 武器 12345678910111213public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; // getter、setter省略&#125; main 12345678910111213141516171819public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"AK-47\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 6.5 接口作为成员变量英雄 1234567891011121314151617181920public class Hero &#123; private String name; // 英雄的名称 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; // getter、setter省略&#125; 技能 12345public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; main 123456789101112131415161718192021222324252627282930public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125; 接口还可以做方法的参数和返回值 6.6 案例 发红包（待整理）","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"继承与多态","slug":"继承与多态","permalink":"http://mangosTeeN96.github.io/tags/继承与多态/"}]},{"title":"Java_常用API","slug":"Java_常用API","date":"2019-07-04T07:35:24.000Z","updated":"2019-08-21T15:33:52.456Z","comments":true,"path":"2019/07/04/Java_常用API/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java_常用API/","excerpt":"API: API(Application Programming Interface)，应用程序编程接口Java API是一本程序员的字典是我们使用的类的说明文档","text":"API: API(Application Programming Interface)，应用程序编程接口Java API是一本程序员的字典是我们使用的类的说明文档 API帮助文档（中文版）：JDK_API_1_6_zh_CN.CHM 引用类: 一般步骤： 导包 import 包路径.类名称; 如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。只有java.lang包下的内容不需要导包（比如String），其他的包都需要import语句。 创建 类名称 对象名 = new 类名称(); 使用 对象名.成员方法名() 一、 Scanner类 Scanner类的功能：可以实现键盘输入数据，到程序当中 使用方法： 查看类 java.util.Scanner :该类需要import导入后使用。 查看构造方法 public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。 查看成员方法 public int nextInt() :将输入信息的下一个标记扫描为一个 int 值。 还有很多，比如next（），String值 使用Scanner类，完成接收键盘录入数据的操作，代码如下: 12345678910111213141516171819import java.util.Scanner; public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 2. 创建 // 备注：System.in代表从键盘进行输入 Scanner sc = new Scanner(System.in); // 3. 获取键盘输入的int数字 int num = sc.nextInt(); System.out.println(\"输入的int数字是：\" + num); // 4. 获取键盘输入的字符串 String str = sc.next(); System.out.println(\"输入的字符串是：\" + str); &#125; &#125; 练习题： 键盘输入三个int数字，然后求出其中的最大值 123456789101112131415161718192021import java.util.Scanner;public class Demo03ScannerMax &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个数字：\"); int a = sc.nextInt(); System.out.println(\"请输入第二个数字：\"); int b = sc.nextInt(); System.out.println(\"请输入第三个数字：\"); int c = sc.nextInt(); // 首先得到前两个数字当中的最大值 int temp = a &gt; b ? a : b; int max = temp &gt; c ? temp : c; System.out.println(\"最大值是：\" + max); &#125;&#125; 二、匿名对象匿名对象：没有变量名的对象 格式: new 类名(参数列表); 应用场景: 创建匿名对象直接调用方法，没有变量名 匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。一旦调用两次方法，就是创建了两个对象，造成浪费 匿名对象可以作为方法的参数和返回值 作为参数 12345678910111213class Test &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = new Scanner(System.in); input(sc); //匿名对象作为方法接收的参数 input(new Scanner(System.in)); &#125; public static void input(Scanner sc)&#123; System.out.println(sc); &#125; &#125; 作为返回值 123456789101112131415class Test2 &#123; public static void main(String[] args) &#123; // 普通方式 Scanner sc = getScanner(); &#125; public static Scanner getScanner()&#123; //普通方式 //Scanner sc = new Scanner(System.in); //return sc; //匿名对象作为方法返回值 return new Scanner(System.in); &#125;&#125; 三、Random类Random类：用来生成随机数字 使用步骤： 导包 import java.util.Random; idea可以自动生成 创建 Random r = new Random(); // 小括号当中留空即可 使用 获取一个随机的int数字（范围是int所有范围，有正负两种）： int num = r.nextInt() 获取一个随机的int数字（参数代表了范围，左闭右开区间）： int num = r.nextInt(3) 实际上代表的含义是：[0,3)，也就是0~2 练习： 猜数字小游戏游戏开始，随机生成一个1-100之间的整数 number 。玩家猜测一个数字 guessNumber ，会与 number 作比较，系统提示大了或者小了，直到玩家猜中，游戏结束。 代码： 123456789101112131415161718192021public static void main(String[] args) &#123; Random r = new Random(); int randomNum = r.nextInt(100) + 1; //[1:100] Scanner sc = new Scanner(System.in); while (true)&#123; System.out.println(\"请输入你猜测的数字：\"); int guessNum = sc.nextInt(); if (guessNum &gt; randomNum)&#123; System.out.println(\"太大了，请重试\"); &#125;else if (guessNum &lt; randomNum)&#123; System.out.println(\"太小了，请重试\"); &#125;else &#123; System.out.println(\"恭喜你，猜中啦\"); break; &#125; &#125; System.out.println(\"游戏结束\");&#125; 四、ArrayList类对象数组： 数组类型选用对象，例如： 123456789101112public static void main(String[] args) &#123; // 首先创建一个长度为3的数组，里面用来存放Person类型的对象 Person[] array = new Person[3]; Person one = new Person(\"迪丽热巴\", 18); // 将one当中的地址值赋值到数组的0号元素位置 array[0] = one; System.out.println(array[0]); // 地址值 System.out.println(array[0].getName()); // 迪丽热巴&#125; 而数组的长度是固定的，无法适应数据变化的需求 ArrayList类： 数组的长度不可以发生改变但是ArrayList集合的长度是可以随意变化的 4.1 查看类 java.util.ArrayList &lt;E&gt;:需要 import导入 &lt;E&gt; ，表示一种指定的数据类型，叫做泛型。 在出现 E 的地方，我们使用一种引用数据类型将其替换即可，表示我们将存储哪种引用类型的元素 ArrayList，ArrayList 4.2 格式(查看构造方法)基本格式: ArrayList&lt; String&gt; list = new ArrayList&lt; String&gt;(); 在JDK 1.7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式: ArrayList&lt; String&gt; list = new ArrayList&lt;&gt;(); 注意：对于ArrayList集合来说，未添加数据直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号：[] 4.3 常用方法及遍历 对于元素的操作,基本体现在——增、删、查。常用的方法有: public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致。返回值代表添加是否成功。备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合（后面会有）来说，add添加动作不一定成功。 public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。 public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。 public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数 举例： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 向集合中添加元素：add boolean success = list.add(\"柳岩\"); System.out.println(list); // [柳岩] System.out.println(\"添加的动作是否成功：\" + success); // true list.add(\"高圆圆\"); list.add(\"赵又廷\"); list.add(\"李小璐\"); list.add(\"贾乃亮\"); System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 李小璐, 贾乃亮] // 从集合中获取元素：get。索引值从0开始 String name = list.get(2); System.out.println(\"第2号索引位置：\" + name); // 赵又廷 // 从集合中删除元素：remove。索引值从0开始。 String whoRemoved = list.remove(3); System.out.println(\"被删除的人是：\" + whoRemoved); // 李小璐 System.out.println(list); // [柳岩, 高圆圆, 赵又廷, 贾乃亮] // 获取集合的长度尺寸，也就是其中元素的个数 int size = list.size(); System.out.println(\"集合的长度是：\" + size); //遍历 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //idea中，list.fori可以自动生成这个循环&#125; 4.4 存储基本数据类型ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 &lt; int&gt; 不能写，但是存储基本数据类型对应的 包装类型是可以的。 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 4.5练习 生成6个1~33之间的随机整数,添加到集合,并遍历 1234567891011121314151617public class Test01ArrayList &#123; public static void main(String[] args) &#123; // 创建Random 对象 Random random = new Random(); // 创建ArrayList 对象 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 添加随机数到集合 for (int i = 0; i &lt; 6; i++) &#123; int r = random.nextInt(33) + 1; list.add(r); &#125; // 遍历集合输出 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125; &#125; 自定义2个学生对象，添加到集合，并遍历 123456789101112131415161718public class Demo02ArrayListStudent &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); Student one = new Student(\"洪七公\", 20); Student two = new Student(\"欧阳锋\", 21); list.add(one); list.add(two); // 遍历集合 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); System.out.println(\"姓名：\" + stu.getName() + \"，年龄\" + stu.getAge()); &#125; &#125;&#125; 对象可以作为集合元素 定义以指定格式打印集合的方法(ArrayList类型作为参数)，使用{}扩起集合，使用@分隔每个元素。格式参照 {元素@元素@元素} 12345678910111213141516171819202122232425public class Demo05ArrayListPrint &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"宋远桥\"); list.add(\"张无忌\"); list.add(\"李连杰\"); System.out.println(list); printArrayList(list); &#125; public static void printArrayList(ArrayList&lt;String&gt; list)&#123; System.out.print(\"&#123;\"); for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); if (i == list.size() - 1)&#123; System.out.println(name + \"&#125;\"); &#125;else&#123; System.out.print(name + \"@\"); &#125; &#125; &#125;&#125; 用一个大集合存入20个随机数字(1~100)，然后筛选其中的偶数元素，放到小集合当中。要求使用自定义的方法来实现筛选 1234567891011121314151617181920212223242526272829303132public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); Random r = new Random(); for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(100) + 1; // 1~100 bigList.add(num); &#125; ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println(\"偶数总共有多少个：\" + smallList.size()); for (int i = 0; i &lt; smallList.size(); i++) &#123; System.out.println(smallList.get(i)); &#125; &#125; // 这个方法，接收大集合参数，返回小集合结果 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; // 创建一个小集合，用来装偶数结果 ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bigList.size(); i++) &#123; int num = bigList.get(i); if (num % 2 == 0) &#123; smallList.add(num); &#125; &#125; return smallList; &#125;&#125; ArrayList类型作为返回值 五、String类java.lang.String类代表字符串程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。） 特点： 字符串的内容永不可变。 正是因为字符串不可改变，所以字符串是可以共享使用的。 字符串效果上相当于是char[ ]字符数组，但是底层原理是byte[]字节数组。 5.1 构造方法创建字符串的常见3+1种方式。 三种构造方法： public String()：创建一个空白字符串，不含有任何内容。 public String(char[] array)：根据字符数组的内容，来创建对应的字符串。 public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。 代码： 12345678910 // 无参构造String str = new String();// 通过字符数组构造char chars[] = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;; String str3 = new String(bytes);//打印输出是'a','b','c' 一种直接创建： String str = &quot;Hello&quot;; // 右边直接用双引号 注意：直接写上双引号，就是字符串对象。 5.2 字符串的常量池 字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中 对于基本类型来说，==是进行 数值 的比较 对于引用类型来说，==是进行 地址值 的比较 1234567891011public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a', 'b', 'c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false&#125; 5.3 比较方法==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法： public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。 注意事项： 任何对象都能用Object进行接收。 equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：”abc”.equals(str)不推荐：str.equals(“abc”) public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。 5.4 获取方法 String当中与获取相关的常用方法有： public int length()：获取字符串长度。 public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。 public char charAt(int index)：获取指定索引位置的单个字符。（索引从0开始。） public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。 12345678910111213141516171819202122public static void main(String[] args) &#123; // 获取字符串的长度 int length = \"asdasfeutrvauevbueyvb\".length(); // 拼接字符串 String str1 = \"Hello\"; String str2 = \"World\"; String str3 = str1.concat(str2); System.out.println(str3); // HelloWorld，新的字符串 // 获取指定索引位置的单个字符 char ch = \"Hello\".charAt(1); System.out.println(\"在1号索引位置的字符是：\" + ch); // 查找参数字符串在本来字符串当中出现的第一次索引位置 // 如果根本没有，返回-1值 String original = \"HelloWorldHelloWorld\"; int index = original.indexOf(\"llo\"); System.out.println(\"第一次索引值是：\" + index); // 2 System.out.println(\"HelloWorld\".indexOf(\"abc\")); // -1&#125; 5.5 截取方法 字符串的截取方法： public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。[begin,end)，包含左边，不包含右边 123456String str1 = \"HelloWorld\";String str2 = str1.substring(5);System.out.println(str2); // World，新字符串String str3 = str1.substring(4, 7);System.out.println(str3); // oWo 5.6 转换方法 String当中与转换相关的常用方法有： public char[] toCharArray()：将当前字符串拆分成为字符数组作为返回值。 public byte[] getBytes()：获得当前字符串底层的字节数组。 public String replace(CharSequence oldString, CharSequence newString)： 将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。备注：CharSequence意思就是说可以接受字符串类型 1234567891011121314// 转换成为字符数组char[] chars = \"Hello\".toCharArray();System.out.println(chars[0]); // H// 转换成为字节数组byte[] bytes = \"abc\".getBytes();for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.println(bytes[i]);&#125;// 字符串的内容替换String str1 = \"How do you do?\";String str2 = str1.replace(\"o\", \"*\");System.out.println(str2); // H*w d* y*u d*? 5.7 分割方法分割字符串的方法：public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。 12345String str1 = \"aaa,bbb,ccc\";String[] array1 = str1.split(\",\");for (int i = 0; i &lt; array1.length; i++) &#123; System.out.println(array1[i]);&#125; 注意事项：split方法的参数其实是一个“正则表达式”，今后学习。今天要注意：如果按照英文句点“.”进行切分，必须写”\\.”（两个反斜杠） 六、static关键字static关键字：它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 6.1 类变量（修饰成员变量） 当static修饰成员变量时，该变量称为类变量 该类的每个对象都共享同一个类变量的值 任何对象都可以更改该类变量的值 但也可以在不创建该类的对象的情况下对类变量进行操作。 举例： 每新来一个同学，id自动+1 学生类： 12345678910111213141516171819202122232425262728293031323334353637public class Student &#123; private int id; // 学号 private String name; // 姓名 private int age; // 年龄 static String room; // 所在教室 private static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++ public Student() &#123; this.id = ++idCounter; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 代码： 1234567891011121314151617public class Demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student(\"郭靖\", 19); one.room = \"101教室\";//后面会说，不推荐这么写 System.out.println(\"姓名：\" + one.getName() + \"，年龄：\" + one.getAge() + \"，教室：\" + one.room + \"，学号：\" + one.getId()); Student two = new Student(\"黄蓉\", 16); System.out.println(\"姓名：\" + two.getName() + \"，年龄：\" + two.getAge() + \"，教室：\" + two.room + \"，学号：\" + two.getId()); &#125;&#125; 输出： 姓名：郭靖，年龄：19，教室：101教室，学号：1姓名：黄蓉，年龄：16，教室：101教室，学号：2 6.2 静态方法（类方法）（修饰成员方法） 一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。 如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。 如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。 静态变量：类名称.静态变量 静态方法：类名称.静态方法() 注意事项： 静态不能直接访问非静态原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容“先人不知道后人，但是后人知道先人。” 静态方法当中不能用this原因：this代表当前对象，通过谁调用的方法，谁就是当前对象 MyClass类： 1234567891011121314151617181920212223242526272829public class MyClass &#123; int num; // 成员变量 static int numStatic; // 静态变量 // 成员方法 public void method() &#123; System.out.println(\"这是一个成员方法。\"); // 成员方法可以访问成员变量 System.out.println(num); // 成员方法可以访问静态变量 System.out.println(numStatic); &#125; // 静态方法 public static void methodStatic() &#123; System.out.println(\"这是一个静态方法。\"); // 静态方法可以访问静态变量 System.out.println(numStatic); // 静态不能直接访问非静态【重点】// System.out.println(num); // 错误写法！ // 静态方法中不能使用this关键字。// System.out.println(this); // 错误写法！ &#125;&#125; 代码： 12345678910111213141516171819202122public class Demo02StaticMethod &#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); // 首先创建对象 // 然后才能使用没有static关键字的内容 obj.method(); // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名” MyClass.methodStatic(); // 正确，推荐 // 对于本来当中的静态方法，可以省略类名称 myMethod(); Demo02StaticMethod.myMethod(); // 完全等效 &#125; public static void myMethod() &#123; System.out.println(\"自己的方法！\"); &#125;&#125; 6.3静态代码块格式： public class 类名称 {&emsp;&emsp;&emsp;&emsp;static {&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;// 静态代码块的内容&emsp;&emsp;&emsp;&emsp;}} 特点： 当第一次用到本类时，静态代码块执行唯一的一次。 静态内容总是优先于非静态，所以静态代码块比构造方法先执行。 典型用途： 用来一次性地对静态成员变量进行赋值。 Person类： 123456789public class Person &#123; static &#123; System.out.println(\"静态代码块执行！\"); &#125; public Person() &#123; System.out.println(\"构造方法执行！\"); &#125;&#125; 代码： 1234public static void main(String[] args) &#123; Person one = new Person(); Person two = new Person();&#125; 输出结果： 静态代码块执行！构造方法执行！构造方法执行！ 七、Arrays类java.util.Arrays此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 常用方法： public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]） public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。 如果是数值，sort默认按照升序从小到大 如果是字符串，sort默认按照字母升序 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习） 123String[] array2 = &#123;\"bbb\", \"aaa\", \"ccc\"&#125;;Arrays.sort(array2);System.out.println(Arrays.toString(array2)); // [aaa, bbb, ccc] 练习： 请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。（涉及到倒序遍历） 1234567891011121314public static void main(String[] args) &#123; String str = \"asv76agfqwdfvasdfvjh\"; // 如何进行升序排列：sort // 必须是一个数组，才能用Arrays.sort方法 // String --&gt; 数组，用toCharArray char[] chars = str.toCharArray(); Arrays.sort(chars); // 对字符数组进行升序排列 // 需要倒序遍历(此处idea快捷键：chars.forr) for (int i = chars.length - 1; i &gt;= 0; i--) &#123; System.out.println(chars[i]); &#125;&#125; 八、Math类java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 基本运算方法： public static double abs(double num)：获取绝对值。有多种重载。 public static double ceil(double num)：向上取整。 public static double floor(double num)：向下取整。 public static long round(double num)：四舍五入。 Math.PI代表近似的圆周率常量（double） 1234567double d1 = Math.abs(‐5); //d1的值为5double d2 = Math.ceil(3.3); //d2的值为 4.0double d3 = Math.floor(3.3); //d3的值为3.0long d4 = Math.round(5.5); //d4的值为6.0","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"常用API","slug":"常用API","permalink":"http://mangosTeeN96.github.io/tags/常用API/"}]},{"title":"Java基础_3","slug":"Java基础_3","date":"2019-07-04T04:48:39.000Z","updated":"2019-08-20T07:47:17.619Z","comments":true,"path":"2019/07/04/Java基础_3/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/04/Java基础_3/","excerpt":"","text":"第一章 类与对象 类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 1.1 类的定义格式： public class ClassName {&emsp;&emsp;&emsp;&emsp;//成员变量(属性)&emsp;&emsp;&emsp;&emsp;//成员方法(行为)} 成员变量:和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。 成员方法:和以前定义方法几乎是一样的。只不过把static去掉。 举例： 1234567891011121314 public class Student &#123; //成员变量 String name;//姓名 int age;//年龄 //成员方法 //学习的方法 public void study() &#123; System.out.println(\"好好学习，天天向上\"); &#125; //吃饭的方法 public void eat() &#123; System.out.println(\"学习饿了要吃饭\"); &#125;&#125; 1.2 对象的使用格式： 导包 import 包名称.类名称； （属于同一个包可以不写） 创建对象 类名 对象名 = new 类名(); 使用对象访问类中的成员 对象名.成员变量;对象名.成员方法(); 成员变量的默认值 数据类型 默认值 基本类型 整数(byte，short，int，long) 0 浮点数(float，double) 0.0 字符(char) ‘\\u0000’ 布尔(boolean) false 引用类型 数组，类，接口 null 类与对象举例： 定义手机类: 123456789101112131415public class Phone &#123; // 成员变量 String brand; //品牌 int price; //价格 String color; //颜色 // 成员方法 //打电话 public void call(String name) &#123; System.out.println(\"给\"+name+\"打电话\"); &#125; //发短信 public void sendMessage() &#123; System.out.println(\"群发短信\"); &#125;&#125; 定义测试类: 1234567891011121314151617181920212223242526public class Test02Phone &#123; public static void main(String[] args) &#123; //创建对象 Phone p = new Phone(); //输出成员变量值 System.out.println(\"品牌:\"+p.brand);//null System.out.println(\"价格:\"+p.price);//0 System.out.println(\"颜色:\"+p.color);//null System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐\"); //给成员变量赋值 p.brand = \"锤子\"; p.price = 2999; p.color = \"棕色\"; //再次输出成员变量值 System.out.println(\"品牌:\"+p.brand);//锤子 System.out.println(\"价格:\"+p.price);//2999 System.out.println(\"颜色:\"+p.color);//棕色 System.out.println(\"‐‐‐‐‐‐‐‐‐‐‐‐\"); //调用成员方法 p.call(\"紫霞\"); p.sendMessage(); &#125; &#125; 成员变量和局部变量区别 在类中的位置不同 成员变量:类中，方法外 局部变量:方法中或者方法声明上(形式参数) 作用范围不一样 成员变量:类中 局部变量:方法中 初始化值的不同 成员变量:有默认值 局部变量:没有默认值。必须先定义，赋值，最后使用 在内存中的位置不同 成员变量:堆内存 局部变量:栈内存 生命周期不同 成员变量:随着对象的创建而存在，随着对象的消失而消失 局部变量:随着方法的调用而存在，随着方法的调用完毕而消失 第二章 封装封装 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。原则：将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 方法就是一种封装 关键字private也是 2.1 封装步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对getXxx方法 、setXxx方法。 2.2 封装的操作——private关键字 private的含义 private是一个权限修饰符，代表最小权限。 可以修饰成员变量和成员方法。 被private修饰后的成员变量和成员方法，只在本类中才能访问。 使用格式 private 数据类型 变量名 ; 使用 private 修饰成员变量，代码如下: 1234public class Student &#123; private String name; private int age;&#125; 提供 getXxx 方法 / setXxx 方法，可以访问成员变量 代码如下: 123456789101112131415161718public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; &#125; set方法，用于向age设置数据 get方法，用于获取age的数据 可以用set约束设置的数据 注意： 对于基本类型中的boolean值，getter方法要写成isxxx，而setxxx规则不变 第三章 封装优化3.1 this关键字上一篇笔记中，setXxx 方法中形参名字并不符合见名知意的规定如果修改与成员变量名一致，代码如下: 1234567891011public class Student &#123; private String name; private int age; public void setName(String name) &#123; name = name; &#125; public void setAge(int age) &#123; age = age; &#125; &#125; 当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量如果需要访问本类当中的成员变量，需要使用this关键字通过谁调用的方法，谁就是this 格式： this.成员变量名; 使用 this 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下: 12345678910public class Person &#123; String name; // 我自己的名字 // 参数name是对方的名字 // 成员变量name是自己的名字 public void sayHello(String name) &#123; System.out.println(name + \"，你好。我是\" + this.name); System.out.println(this); &#125;&#125; 12345678910public class Demo01Person &#123; public static void main(String[] args) &#123; Person person = new Person(); // 设置我自己的名字 person.name = \"王健林\"; person.sayHello(\"王思聪\"); System.out.println(person); // 地址值 &#125;&#125; 输出结果： 王思聪，你好。我是王健林cn.itcast.day06.demo04.Person@7852e922cn.itcast.day06.demo04.Person@7852e922 3.2 构造方法构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。格式： public 类名称(参数类型 参数名称) {&emsp;&emsp;&emsp;&emsp;方法体} 注意事项： 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样 构造方法不要写返回值类型，连void都不写 构造方法不能return一个具体的返回值 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。public Student() {} 一旦编写了至少一个构造方法，那么编译器将不再赠送。 构造方法也是可以进行重载的。 使用构造方法后，代码如下: 12345678910111213public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 全参数构造方法，方便我们在创建对象的把数据直接通过参数的形式设置进来，省去多次调用setget方法 但是当修改对象内容时set方法还是有用的。 获取数据时还是要用get方法 要写全参数构造方法时，需要把无参数也写上，因为系统不会赠送了。 3.3 标准代码——JavaBean一个标准的类通常要拥有下面四个组成部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 这样标准的类也叫做Java Bean 编写符合 JavaBean 规范的类，以学生类为例，标准代码如下: 12345678910111213141516171819202122232425262728public class Student &#123; //成员变量 private String name; // 姓名 private int age; // 年龄 //构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; 成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 测试类，代码如下： 1234567891011121314public class TestStudent &#123; public static void main(String[] args) &#123; //无参构造使用 Student s= new Student(); s.setName(\"柳岩\"); s.setAge(18); System.out.println(s.getName()+\"‐‐‐\"+s.getAge()); //带参构造使用 Student s2= new Student(\"赵丽颖\",18); System.out.println(s2.getName()+\"‐‐‐\"+s2.getAge()); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"Java基础_2","slug":"Java基础_2","date":"2019-07-03T08:32:38.000Z","updated":"2019-08-20T07:45:40.477Z","comments":true,"path":"2019/07/03/Java基础_2/","link":"","permalink":"http://mangosTeeN96.github.io/2019/07/03/Java基础_2/","excerpt":"","text":"第一章 方法方法: 就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 1.1 定义 修饰符 返回值类型 方法名 (参数列表){&emsp;&emsp;&emsp;&emsp;代码…&emsp;&emsp;&emsp;&emsp;return 返回值;} 定义格式解释: 修饰符: 目前固定写法 public static 返回值类型: 没有返回值时为&ensp;void 方法名:满足标识符的规范，用来调用方法。 参数列表: 参数 return:方法结束。返回值类型是void，方法大括号内的return可以不写，有返回值时返回给调用者。 举例： 123 public static void methodName() &#123; System.out.println(\"这是一个方法\");&#125; 方法定义注意事项: 方法必须定义在一类中方法外 方法不能定义在另一个方法的里面 1.2 方法的调用12345678 public static void main(String[] args) &#123; //调用定义的方法method method();&#125;//定义方法，被main方法调用 public static void method() &#123; System.out.println(\"自己定义的方法，需要被main调用运行\"); &#125; 上面方法为直接调用，有参数时括号内写入参数 还可以输出语句调用: 在输出语句中调用方法， System.out.println(方法名()) 。 不能用输出语句调用 void 类型的方法 1.3 方法重载 方法重载:指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。 参数列表:个数不同，数据类型不同，顺序不同。 重载方法调用:JVM通过方法的参数列表，调用不同的方法。 重载练习比较两个数据是否相等。参数类型分别为两个 byte 类型，两个 short 类型，两个 int 类型，两个 long 类型，并在 main 方法中进行测试。 123456789101112131415161718192021222324252627282930313233343536373839public class Method_Demo6 &#123; public static void main(String[] args) &#123; //定义不同数据类型的变量 byte a = 10; byte b = 20; short c = 10; short d = 20; int e = 10; int f = 10; long g = 10; long h = 20; // 调用 System.out.println(compare(a, b)); System.out.println(compare(c, d)); System.out.println(compare(e, f)); System.out.println(compare(g, h)); &#125; // 两个byte类型的 public static boolean compare(byte a, byte b) &#123; System.out.println(\"byte\"); return a == b; &#125; // 两个short类型的 public static boolean compare(short a, short b) &#123; System.out.println(\"short\"); return a == b; &#125; // 两个int类型的 public static boolean compare(int a, int b) &#123; System.out.println(\"int\"); return a == b; &#125; // 两个long类型的 public static boolean compare(long a, long b) &#123; System.out.println(\"long\"); return a == b; &#125;&#125; 1.4 权限修饰符public:公共的protected:受保护的default:默认的（不写）private:私有的 public protected default(空的) private 同一类中 √ √ √ √ 同一包中(子类与无关类) √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 第二章 数组数组: 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 数组的特点： 数组是一种引用数据类型 数组当中的多个数据，类型必须统一 数组的长度在程序运行期间不可改变 2.1 定义数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。 两种常见的初始化方式： 动态初始化（指定长度） 静态初始化（指定内容） 动态初始化数组 格式： 数据类型[] 数组名称 = new 数据类型[数组长度]; 解析含义：数据类型：数组当中数据的统一类型[]：代表我是一个数组new：代表创建数组的动作数组长度：指定长度 举例： 1int[] arr = new int[3]; 静态初始化 标准格式： 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, … }; 省略格式： 数据类型[] 数组名称 = { 元素1, 元素2, … } 举例： 123int[] arrA = new int[]&#123;1,2,3,4,5&#125;;int[] arrB = &#123;1,2,3,4,5&#125;; 注意： 静态初始化没有直接指定长度，但是仍然会自动推算得到长度 静态初始化标准格式、动态初始化，可以拆分成为两个步骤 静态初始化省略格式不能拆分成为两个步骤 12int[] arrayB;arrayB = new int[] &#123; 11, 21, 31 &#125;; 2.2 数组的访问索引：从0开始，通过数组的索引访问到数组中的元素格式： 数组名[索引] 数组长度获得数组长度语句：数组名.length数组的最大索引值为：数组名.length-1 索引访问数组中的元素: 数组名[索引]=数值，为数组中的元素赋值 变量=数组名[索引]，获取出数组中的元素 2.3 数组内存原理Java虚拟机的内存划分 一个数组内存图 两个独立数组内存图 两个变量指向同一个数组内存图 2.4 数组遍历123456public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 2.5 数组获得最大值元素123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++)&#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println(\"数组最大值是: \" + max); &#125; 2.6 数组反转数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1 实现思想:数组最远端的元素互换位置。 实现反转，就需要将数组最远端元素位置交换 定义两个变量，保存数组的最小索引和最大索引 两个索引上的元素交换位置 最小索引++，最大索引–，再次交换位置 最小索引超过了最大索引，数组反转操作结束 12345678910111213141516public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 2.7 数组作为方法参数和返回值 数组作为方法参数传递，传递的参数是数组内存的地址 数组作为方法的返回值，返回的是数组的内存地址 方法的参数为基本类型时，传递的是数据值。为引用类型时，传递的是地址值。","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"hadoop安装与伪分布式搭建","slug":"hadoop安装与伪分布式搭建","date":"2019-06-29T09:30:52.000Z","updated":"2019-08-21T15:57:31.071Z","comments":true,"path":"2019/06/29/hadoop安装与伪分布式搭建/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/hadoop安装与伪分布式搭建/","excerpt":"","text":"创建Hadoop用户 创建新用户用户名为hadoop，使用/bin/bash作为shellsudo useradd -m hadoop -s /bin/bash 修改密码 1234$ sudo passwd hadoopEnter new UNIX password: Retype new UNIX password: passwd: password updated successfully 为hadoop用户添加管理员权限sudo adduser hadoop sudo 安装jdk1.7首先在oracle官网下载,接下来进行安装与环境变量配置，根据个人电脑系统选择对应版本，我选的是jdk-8u211-linux-x64.tar.gz 12345$ mkdir /usr/lib/jvm #创建jvm文件夹$ sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/lib/jvm #/ 解压到/usr/lib/jvm目录下$ cd /usr/lib/jvm #进入该目录$ mv jdk1.8.0_211 java #重命名为java$ vim ~/.bashrc #给JDK配置环境变量 在.bashrc文件添加如下指令： 1234export JAVA_HOME=/usr/lib/jvm/javaexport JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 在文件修改完毕以后，输入代码：$ source ~/.bashrc #使新配置的环境变量生效$ java -version #检测是否安装成功，查看java版本 安装SSH服务端 安装$ sudo apt-get install openssh-server 登录localhost$ ssh localhost之后会在~/文件夹下发现一个.ssh文件 设置为无密码登录123$ cd ~/.ssh/$ ssh-keygen -t rsa #出现提示直接按enter$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys #加入授权 此时就直接使用$ ssh localhost，无密码登录了。 安装Hadoop本文采用伪分布式模式：存储采用分布式文件系统HDFS，但是HDFS的节点和数据节点都在同一节点。 下载安装下载安装包后解压即可使用：1234$ sudo tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local$ cd /usr/local/$ sudo mv ./hadoop-2.7.1/ ./hadoop # 将文件夹名改为hadoop$ sudo chown -R hadoop ./hadoop # 修改文件权限 查看Hadoop版本信息： 12$ cd /usr/local/hadoop/bin$ ./hadoop version &lt;img src=”hadoop安装与伪分布式搭建/2.png&gt; 伪分布式模式配置修改配置文件:需要修改/usr/local/hadoop/etc/hadoop/文件夹下的core-site.xml和hdfs-site.xml文件。core-site.xml文件:将12&lt;configuration&gt;&lt;/configuration&gt; 修改为： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml文件修改如下： 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 将/hadoop/etc/hadoop/hadoop-env.sh文件的JAVA_HOME改为绝对路径。将export JAVA_HOME=$JAVA_HOME改为export JAVA_HOME=/usr/lib/jvm/default-java 注意：Hadoop的运行方式是由配置文件决定的，如果想从伪分布式模式切换回单机模式，只需删除core-site.xml文件中的配置项即可 执行名称节点格式化执行如下命令：12$ cd /usr/local/hadoop$ ./bin/hdfs namenode -format 出现如下错误 原因应该是权限不够无法再目录内新建文件。解决方案是：先输入命令：sudo su转为root身份输入命令：sudo chmod -R a+w /opt/hadoop-1.2.1/注意修改自己的安装路径。输入命令exit回到用户身份 再执行格式化成功。如果出现/usr/local/hadoop/tmp/dfs/name has been successfully formatted.和 Exiting with status 0，表示格式化成功。 启动Hadoop12$ cd /usr/local/hadoop$ ./sbin/start-dfs.sh 用jps命令查看Hadoop是否启动成功，如果出现DataNode、NameNode、SecondaryNameNode的进程说明启动成功。 使用浏览器查看HDFS信息在浏览器中打开链接：http://localhost:50070/dfshealth.html#tab-overview即可查看 关闭Hadoop使用命令：./sbin/stop-dfs.sh下次启动时不需要再执行节点格式化命令（否则会报错），只需要直接运行start-dfs.sh命令即可。","categories":[{"name":"大数据环境搭建","slug":"大数据环境搭建","permalink":"http://mangosTeeN96.github.io/categories/大数据环境搭建/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://mangosTeeN96.github.io/tags/hadoop/"}]},{"title":"Java基础_1","slug":"Java基础_1","date":"2019-06-29T05:26:32.000Z","updated":"2019-08-20T07:21:15.246Z","comments":true,"path":"2019/06/29/Java基础_1/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/29/Java基础_1/","excerpt":"","text":"第一章 入门1.1 HelloWorld入门程序Java程序开发三步骤:编写、编译、运行。 编写Java源程序 创建HelloWorld.java文件，代码如下： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 编译Java源文件 在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。命令: javac Java源文件名.后缀名 举例: 1javac HelloWorld.java 译成功后，产生一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 运行Java程序 在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。命令: java 类名字 举例： 1java HelloWolrd 入门程序说明 main方法： 称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 注释： 单行注释以 //开头 换行结束多行注释以 /*开头 以*/结束 关键字： 是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母。 标识符： 是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 HelloWorld案例中，出现的标识符有类名字 HelloWorld 。 命名规则： 硬性要求标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $(美元符号) 和 _(下划线) 。标识符不能以数字开头。标识符不能是关键字。软性要求类名规范:首字母大写，后面每个单词首字母大写(大驼峰式)。方法名规范: 首字母小写，后面每个单词首字母大写(小驼峰式)。变量名规范:全部小写 1.2 常量变量常量 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’，’’， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值 true ， false 空常量 只有一个值 null 变量 Java的数据类型分为两大类: 基本数据类型:包括 整数、浮点数、字符、布尔。 引用数据类型:包括 类 、 数组 、 接口 。 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int(默认) 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double(默认) 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false 变量定义 格式： 数据类型 变量名 = 数据值; 1.3 数据类型转换、运算符ava程序中要求参与的计算的数据，必须要保证数据类型的一致性（比如进行加法运算），如果数据类型不一致将发生类型的转换。 自动转换将 取值范围小的类型 自动提升为 取值范围大的类型 。 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 将 取值范围大的类型 强制转换成 取值范围小的类型 。 自动转换是Java自动执行的，而强制转换需要我们自己手动执行。 转换格式： 数据类型 变量名 = (数据类型)被转数据值; 注意： 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失。 ASCII编码表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 1234567public static void main(String[] args) &#123; //字符类型变量 char c = 'a'; int i = 1; //字符类型和int类型计算 System.out.println(c+i);//输出结果是98 &#125; 运算符算数运算符 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++ 、 – 自增自减运算 注意：变量在独立运算时， 前++ 和 后++ 没有区别 ；和其他变量放在一起， 前++ 和 后++ 就产生了不同（+1后赋值、赋值后+1）。 三元运算符 格式： 数据类型 变量名 = 布尔类型表达式?结果1:结果2 计算方式:布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125; 第二章 判断、选择、循环语句2.1 判断语句 if 123if(关系表达式)&#123; 语句体;&#125; if…else 12345if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; if…else if…else 12345678910if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n; &#125; else &#123; 执行语句n+1; &#125; 注意：在某些简单的应用中，if语句是可以和三元运算符互换使用的。 1234567891011public static void main(String[] args) &#123; int a = 10; int b = 20; //定义变量，保存a和b的较大值 int c; if(a &gt; b) &#123; c = a; &#125; else &#123; c = b; &#125; //上述功能可以改写为三元运算符形式 c = a &gt; b ? a:b; &#125; 2.2 选择语句 switch 123456789101112switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; switch语句中，表达式的数据类型，可以是byte，short，int，char，enum(枚举)，JDK7后可以接收字符串 注意：case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 2.3 循环语句 for循环 for(初始化表达式1; 布尔表达式2; 步进表达式4){ 循环体3} 执行顺序:1234&gt;234&gt;234…2不满足为止。 while循环 初始化表达式1 while(布尔表达式2){&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4} 执行顺序:1234&gt;234&gt;234…2不满足为止。 do…while循环 初始化表达式1 do{&emsp;&emsp;&emsp;循环体3&emsp;&emsp;&emsp;步进表达式4}while(布尔表达式2); 执行顺序:134&gt;234&gt;234…2不满足为止。 for 和 while 的小区别: 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 2.4跳出语句break -使用场景:终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 continue 使用场景:结束本次循环，继续下一次的循环 嵌套循环 所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数","categories":[{"name":"java","slug":"java","permalink":"http://mangosTeeN96.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://mangosTeeN96.github.io/tags/java基础/"}]},{"title":"hexo markdown","slug":"hexo-markdown","date":"2019-06-28T10:24:45.000Z","updated":"2019-08-25T11:57:11.349Z","comments":true,"path":"2019/06/28/hexo-markdown/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hexo-markdown/","excerpt":"","text":"一些markdown记录 &lt; br&gt; 换行 两个空格+回车：换行 两个回车：换段落 空格+-，下一行-，会产生缩进序列 &amp;emsp ; 空一个汉字格数 &amp;ensp ; 空一个格","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://mangosTeeN96.github.io/tags/markdown/"}]},{"title":"hexo个人博客搭建","slug":"hexo个人博客搭建","date":"2019-06-28T04:47:04.000Z","updated":"2019-08-21T14:56:31.416Z","comments":true,"path":"2019/06/28/hexo个人博客搭建/","link":"","permalink":"http://mangosTeeN96.github.io/2019/06/28/hexo个人博客搭建/","excerpt":"","text":"搭建流程&emsp;&emsp;1. 安装node.js 打开nodejs.org下载安装包，直接点开安装包安装。 查看安装版本 node -v npm -v &emsp;&emsp;2. 安装hexo框架（以下若权限不足sudo） npm install -g hexo-cli hexo -v 查看hexo版本 &emsp;&emsp;3. 建立blog空文件夹（在用户文件夹中建立即可（位置随意）） mkdir blog 后续如果出现什么问题，把blog文件夹删除重新来即可。 cd blog &emsp;&emsp;4. 初始化博客 sudo hexo init &emsp;&emsp;5. 启动博客 hexo s 浏览器打开localhost:4000，可以看到默认创建的博客 &emsp;&emsp;6. 创建自己的博客 sudo hexo new &quot;测试&quot; cd source/_posts/ 编辑测试.md即可更改博客内容（markdown） cd ../..退回到blog目录下 &emsp;&emsp;7. 本地查看博客总结 hexo clean 清理一下 hexo g 生成一下 hexo s 启动一下 &emsp;&emsp;8. 建repository（为了博客部署到github上公开使用） 登陆自己的github账户，右上角+点开 New repositoryrepository name 必须是 ：昵称（前面的Owner）.github.io 点击greate，出现一个空仓库，保留页面 &emsp;&emsp;9. 安装部署插件 sudo npm install --save hexo-deployer-git 更改_config.yml文件 sudo vim _config.yml 到达文件最底部更改增加如下： 1234deploy: type: git repo: https://github.com/mangosTeeN96/mangosTeeN96.github.io.git branch: master 其中repo地址为刚刚创建的仓库页面的地址（注意冒号后面的空格） &emsp;&emsp;10. 部署到远端 hexo d 中途需要输入GitHub的账户密码 此时访问 mangosteen96.github.io 即可看到自己的博客 到此博客的基本部署就完成了 &emsp;&emsp;11. 更换博客主题 以yilia主题为例 sudo git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 此时themes文件夹中出现yilia文件夹，更改站点配置文件 找到theme：xxx 改为theme：yilia hexo clean hexo g hexo s 4000端口即可看到更改 hexo d 推到远端，mangosteen96.github.io 可以看到（主题更换可能要等一下下） Hexo博客导入图片方法1 站点配置文件_config.yml 里的post_asset_folder:这个选项设置为true npm install hexo-asset-image --save 安装一个可以上传本地图片的插件 安装插件后hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 把图片复制到xxxx这个文件夹中，在xxxx.md中按照markdown的格式引入图片(此处为了不被识别为图片就先这么写了)： 感叹号+[]括号内可输入替代文字+(xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看，html标签内的语句是img src=”2017/02/26/xxxx/图片名.jpg”，必须要有日期。 其它方法 本地source中建立img文件夹&lt;&gt; 内 img src=”img/图片名.jpg（此方法未详细试验） 图床 所遇问题 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理链接时出现路径错误，没有年月，无法显示图片。可直接安装已经修改过得插件npm install https://github.com/7ym0n/hexo-asset-image --save 由于title中有一些符号（比如（）、–等）用hexo new命令创建博客时，出现文件名称与文章title不符的情况在博客中没有图片时，并不产生影响，但当要插入图片时，在路径正确的情况下，依然显示不出图片解决办法暂时只是把 1.文件夹名称、2.md文件名称、3.title 这三者统一","categories":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://mangosTeeN96.github.io/tags/hexo/"}]}]}