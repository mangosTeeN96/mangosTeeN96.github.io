<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">



















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="python数据分析基础，Numpy、Pandas、数据采集清洗集成变换、数据可视化">
<meta name="keywords" content="数据分析">
<meta property="og:type" content="article">
<meta property="og:title" content="python数据分析">
<meta property="og:url" content="http://mangosTeeN96.github.io/2019/12/28/python数据分析/index.html">
<meta property="og:site_name" content="MangosTeen">
<meta property="og:description" content="python数据分析基础，Numpy、Pandas、数据采集清洗集成变换、数据可视化">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/3.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/4.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/5.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/6.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/8.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/9.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/10.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/11.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/12.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/13.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/14.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/15.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/16.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/17.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/19.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/20.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/21.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/22.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/23.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/24.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/26.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/29.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/30.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/31.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/51.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/32.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/33.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/34.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/35.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/36.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/37.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/38.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/39.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/40.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/42.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/43.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/196.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/49.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/45.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/46.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/47.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/48.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/50.png">
<meta property="og:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/41.png">
<meta property="og:updated_time" content="2020-05-28T06:03:42.464Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python数据分析">
<meta name="twitter:description" content="python数据分析基础，Numpy、Pandas、数据采集清洗集成变换、数据可视化">
<meta name="twitter:image" content="http://mangosteen96.github.io/2019/12/28/python数据分析/3.png">





  
  
  <link rel="canonical" href="http://mangosTeeN96.github.io/2019/12/28/python数据分析/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>python数据分析 | MangosTeen</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MangosTeen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mangosTeeN96.github.io/2019/12/28/python数据分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MangosTeen">
      <meta itemprop="description" content="想养一只猫">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MangosTeen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python数据分析

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-28 09:27:08" itemprop="dateCreated datePublished" datetime="2019-12-28T09:27:08+08:00">2019-12-28</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-28 14:03:42" itemprop="dateModified" datetime="2020-05-28T14:03:42+08:00">2020-05-28</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br>
          

          

          
            <div class="post-description">python数据分析基础，Numpy、Pandas、数据采集清洗集成变换、数据可视化</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="python数据分析"><a href="#python数据分析" class="headerlink" title="python数据分析"></a>python数据分析</h1><h2 id="1-数据分析全景图"><a href="#1-数据分析全景图" class="headerlink" title="1. 数据分析全景图"></a>1. 数据分析全景图</h2><p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/3.png" alt="3"></p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/4.png" alt="4"></p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/5.png" alt="5"></p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/6.png" alt="6"></p>
<h2 id="2-数据挖掘的最佳路径"><a href="#2-数据挖掘的最佳路径" class="headerlink" title="2.数据挖掘的最佳路径"></a>2.数据挖掘的最佳路径</h2><p>数据挖掘的基本流程</p>
<p>数据挖掘的十大算法</p>
<h2 id="3-Python基础语法"><a href="#3-Python基础语法" class="headerlink" title="3.Python基础语法"></a>3.Python基础语法</h2><p>见另一个笔记</p>
<h2 id="4-Numpy快速处理数据"><a href="#4-Numpy快速处理数据" class="headerlink" title="4.Numpy快速处理数据"></a>4.Numpy快速处理数据</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>它不仅是Python中使用最多的第三方库，而且还是SciPy、Pandas等数据科学的基础库。它所提供的数据结构比Python自身的“更高级、更高效”，可以这么说，NumPy所提供的数据结构是Python数据分析的基础。</p>
<p>我上次讲到了Python数组结构中的列表list，它实际上相当于一个数组的结构。而NumPy中一个关键数据类型就是关于数组的，那为什么还存在这样一个第三方的数组结构呢？</p>
<p>实际上，标准的Python中，用列表list保存数组的数值。由于<strong>列表中的元素可以是任意的对象</strong>，所以列表中list保存的是对象的<strong>指针</strong>。虽然在Python编程中隐去了指针的概念，但是数组有指针，Python的列表list其实就是数组。这样如果我要保存个简单的数组[0,1,2]，就需要有3个指针和3个整数的对象，这样对于Python来说是非常不经济的，浪费了内存和计算时间。</p>
<p>列表list的元素在系统内存中是分散存储的，而NumPy数组存储在一个<strong>均匀连续的内存块</strong>中。这样数组计算遍历所有的元素，不像列表list还需要对内存地址进行查找，从而节省了计算资源。</p>
<p>另外在内存访问模式中，缓存会直接把字节块从RAM加载到CPU寄存器中。因为数据连续的存储在内存中，NumPy直接利用现代CPU的矢量化指令计算，加载寄存器中的多个连续浮点数。另外NumPy中的矩阵计算可以采用多线程的方式，充分利用多核CPU计算资源，大大提升了计算效率。</p>
<p>当然除了使用NumPy外，你还需要一些技巧来提升内存和提高计算资源的一个重要的规则就是：避免采用隐式拷贝，而是采用<strong>就地操作</strong>的方式。举个例子，如果我想让一个数值x是原来的两倍，可以直接写成<code>x*=2</code>，而不要写成<code>y=x*2</code>。这样速度能快到2倍甚至更多。</p>
<br>

<p>在NumPy里有<strong>两个重要的对象</strong>：ndarray（N-dimensional arrayobject）解决了多维数组问题，而ufunc（universal function object）则是解决对数组进行处理的函数。</p>
<p>ndarray对象</p>
<p>ndarray实际上是多维数组的含义。在NumPy数组中，维数称为秩（rank），一维数组的秩为1，二维数组的秩为2，以此类推。在NumPy中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。</p>
<p>ndarray对象创建数组，处理结构数组。</p>
<p>ufunc运算 </p>
<p>ufunc是universal function的缩写，它能对数组中每个元素进行函数操作。NumPy中很多ufunc函数计算速度非常快，因为都是采用C语言实现的。</p>
<h3 id="numpy数组"><a href="#numpy数组" class="headerlink" title="numpy数组"></a>numpy数组</h3><table>
<thead>
<tr>
<th>numpy</th>
<th>处理数值型数据</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建</strong>数组</td>
<td>import numpy as np<br>a = np.array([1,2,3])  <br>[1 2 3]<br>a = np.array(range(1,6))     <br>[1 2 3 4 5]  <br>a = np.array(range(5)) <br>[0 1 2 3 4]<br>a=np.array([1,2,3],[4,5,6],[7,8,9])<br>a = np.arange(start,stop,step)</td>
</tr>
<tr>
<td>数组的类名</td>
<td>type（a）</td>
</tr>
<tr>
<td>数据的类型</td>
<td>a.dtype</td>
</tr>
<tr>
<td>在创建数组时指定数据类型</td>
<td>a = np.array([1,2,3]，dtype=’’)</td>
</tr>
<tr>
<td>修改数据类型</td>
<td>a.astype(‘’)</td>
</tr>
<tr>
<td>保留几位小数</td>
<td>np.round(数组，位数）random.random() 生成随机小数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>数组操作</th>
</tr>
</thead>
<tbody><tr>
<td>查看数组的形状</td>
<td>a.shape</td>
</tr>
<tr>
<td></td>
<td>shape[0]  多少行<br>shape[1]  多少列</td>
</tr>
<tr>
<td>修改</td>
<td>a.reshape（3，4）</td>
</tr>
<tr>
<td></td>
<td>一维（3，）</td>
</tr>
<tr>
<td></td>
<td>三维（3，3，2）三块、三行、两列</td>
</tr>
<tr>
<td></td>
<td>a.reshape（-1） 转换为1行，自动匹配列数</td>
</tr>
<tr>
<td></td>
<td>a.reshape（-1，1）转换为1列，自动匹配行数<br>a.reshape（-1，2）2列，匹配行数</td>
</tr>
<tr>
<td>二维展开为一维</td>
<td>a.flatten（）</td>
</tr>
<tr>
<td>数组计算</td>
<td>a+2数组内所有数+2其他运算相同</td>
</tr>
<tr>
<td>数组间计算</td>
<td>a*b两数组形状一样，对应位置计算；若形状不一样，但某一个数组与另一个数组的一列或一行形状相同，会对应计算</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>数组拼接</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>竖直拼接</td>
<td>np.vstack((t1,t2))</td>
</tr>
<tr>
<td>水平拼接</td>
<td>np.hstack((t1,t2))</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>行交换</td>
<td>a[[1,2],:] = a[[2,1],:]</td>
</tr>
<tr>
<td>列交换</td>
<td>a[:,[0,2]] = t[:,[2,0]]</td>
</tr>
</tbody></table>
<p>numpy中定义的数据类型及类型代码</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">类型代码</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int8、uint8</td>
<td align="left">i1、u1</td>
<td align="left">有符号和无符号的8位整型（1个字节）</td>
</tr>
<tr>
<td align="left">int16、uint16</td>
<td align="left">i2、u2</td>
<td align="left">有符号和无符号的16位整型（2个字节）</td>
</tr>
<tr>
<td align="left">int32、uint32</td>
<td align="left">i4、u4</td>
<td align="left">有符号和无符号的32位整型（4个字节）</td>
</tr>
<tr>
<td align="left">int64、uint64</td>
<td align="left">i8、u8</td>
<td align="left">有符号和无符号的64位整型（8个字节）</td>
</tr>
<tr>
<td align="left">float16</td>
<td align="left">f2</td>
<td align="left">半精度浮点数</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">f4或f</td>
<td align="left">标准的单精度浮点数</td>
</tr>
<tr>
<td align="left">float64</td>
<td align="left">f8或d</td>
<td align="left">标准的双精度浮点数</td>
</tr>
<tr>
<td align="left">float128</td>
<td align="left">f16或g</td>
<td align="left">扩展精度浮点数</td>
</tr>
<tr>
<td align="left">complex64、complex128</td>
<td align="left">c8、c16</td>
<td align="left">分别用两个32位、64位或128位浮点数表示的复数</td>
</tr>
<tr>
<td align="left">complex256</td>
<td align="left">c32</td>
<td align="left">复数</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">？</td>
<td align="left">True和False布尔类型</td>
</tr>
<tr>
<td align="left">object</td>
<td align="left">O</td>
<td align="left">Python对象类型</td>
</tr>
<tr>
<td align="left">string_</td>
<td align="left">S</td>
<td align="left">固定长度的字符串类型。例如，创建一个长度为10的字符串，应使用S10</td>
</tr>
<tr>
<td align="left">unicode_</td>
<td align="left">U</td>
<td align="left">固定长度的Unicode类型，跟字符串定义方式一样，比如U10</td>
</tr>
</tbody></table>
<h4 id="numpy结构化数组——structured-array"><a href="#numpy结构化数组——structured-array" class="headerlink" title="numpy结构化数组——structured array"></a>numpy结构化数组——structured array</h4><p>“结构化数组”这一称呼来源于C语言，在C语言中，如果我们需要创建一个“ 学生 ”的数组，每一个学生包括 姓名、年龄、性别、体重 四个信息，我们需要先构造一个结构体，然后使用结构体数组。得到的数组的形式如下所示：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">name</th>
<th align="left">age</th>
<th align="left">weight</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">张三</td>
<td align="left">22</td>
<td align="left">68</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">李四</td>
<td align="left">27</td>
<td align="left">56</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">王五</td>
<td align="left">25</td>
<td align="left">62</td>
</tr>
</tbody></table>
<p>比如有一个numpy数组</p>
<p>a=np.array([1,2,3,4,5],dtype=np.int32)    #创建数组时，每一个元素的“ 类型 ”都是相同的，</p>
<p>也就是说，如果要创建类似于上面的“ 结构体数组 ”，第一件事情是需要定义一个 全新的dtype。参见下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">student_type=&#123;<span class="string">'names'</span>:(<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>,<span class="string">'weight'</span>), <span class="string">'formats'</span>:(<span class="string">'U10'</span>, <span class="string">'i4'</span>,<span class="string">'U6'</span>, <span class="string">'f8'</span>)&#125; <span class="comment">#U可以用S</span></span><br><span class="line">students=np.array([(<span class="string">'袁菲'</span>,<span class="number">25</span>,<span class="string">'女'</span>,<span class="number">55</span>),(<span class="string">'张三'</span>,<span class="number">22</span>,<span class="string">'女'</span>,<span class="number">65</span>),(<span class="string">'李四'</span>,<span class="number">28</span>,<span class="string">'男'</span>,<span class="number">70</span>),(<span class="string">'赵二'</span>,<span class="number">21</span>,<span class="string">'女'</span>,<span class="number">49</span>),(<span class="string">'王五'</span>,<span class="number">29</span>,<span class="string">'男'</span>,<span class="number">85</span>)],dtype=student_type)</span><br><span class="line"> </span><br><span class="line">print(students)</span><br><span class="line">print(students.shape)  <span class="comment">#数组形状</span></span><br><span class="line">print(students.dtype)  <span class="comment">#数组元素类型</span></span><br><span class="line">print(<span class="string">'========================================================================'</span>)</span><br><span class="line">row1=students[<span class="number">0</span>]       <span class="comment">#返回某一行，依然使用索引index</span></span><br><span class="line">print(row1)</span><br><span class="line">name=students[<span class="string">'name'</span>]  <span class="comment">#返回某一列，</span></span><br><span class="line">print(name)</span><br><span class="line">sex=students[<span class="string">'sex'</span>]</span><br><span class="line">print(sex)</span><br><span class="line">print(<span class="string">'========================================================================'</span>)</span><br><span class="line">element=students[<span class="number">1</span>][<span class="string">'age'</span>] <span class="comment">#返回某一行的某一列，即返回某一个 单元格 元素，等价于students[1][1]</span></span><br><span class="line">print(element)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[(&apos;袁菲&apos;, 25, &apos;女&apos;, 55.) (&apos;张三&apos;, 22, &apos;女&apos;, 65.) (&apos;李四&apos;, 28, &apos;男&apos;, 70.) (&apos;赵二&apos;, 21, &apos;女&apos;, 49.) (&apos;王五&apos;, 29, &apos;男&apos;, 85.)]</span><br><span class="line"></span><br><span class="line">(5,)</span><br><span class="line"></span><br><span class="line">[(&apos;name&apos;, &apos;&lt;U10&apos;), (&apos;age&apos;, &apos;&lt;i4&apos;), (&apos;sex&apos;, &apos;&lt;U6&apos;), (&apos;weight&apos;, &apos;&lt;f8&apos;)]</span><br><span class="line"></span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line">(&apos;袁菲&apos;, 25, &apos;女&apos;, 55.)</span><br><span class="line"></span><br><span class="line">[&apos;袁菲&apos; &apos;张三&apos; &apos;李四&apos; &apos;赵二&apos; &apos;王五&apos;]</span><br><span class="line"></span><br><span class="line">[&apos;女&apos; &apos;女&apos; &apos;男&apos; &apos;女&apos; &apos;男&apos;]</span><br><span class="line"></span><br><span class="line">======================================================</span><br><span class="line"></span><br><span class="line">22</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，numpy的结构化数组有点类似于pandas的使用，如果熟悉pandas的dataframe结构，就很简单了，但也有区别，比如我们不能通过这样的方式同时访问多个列：</p>
<p>name=students[‘name’,’weight’]   #会显示错误</p>
<p>columns=students[[‘name’,’weight’]] #这样就正确了</p>
<p><strong>核心–如何创建自定义的dtype</strong></p>
<p>创建dtype的几种方式：字符串、列表、元组、字典</p>
<p><strong>（1）方法一：使用字符串创建dtype类型</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mytype=<span class="string">'int,float,int'</span></span><br><span class="line"></span><br><span class="line">s=np.zeros(<span class="number">5</span>,dtype=mytype)   <span class="comment">#等价于s=np.zeros(5,dtype='int,float,int')</span></span><br></pre></td></tr></table></figure>

<p>运行的结果是包含5个元素的结构体数组，这里结构体元素都是以单一的数字，我们还可以给结构体元素指定特定的形状，如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.zeros(<span class="number">3</span>, dtype=<span class="string">'3int8, float32, (2,3)float64'</span>)</span><br><span class="line"><span class="comment"># 3int8 表示的是结构体的第一个元素是包含 3 个int元素的</span></span><br><span class="line"><span class="comment"># float 就表示第二个元素只是单纯的一个float值</span></span><br><span class="line"><span class="comment"># (2,3)float64 表示的是第三个元素是（2，3）的形状的 float元素</span></span><br><span class="line"><span class="keyword">print</span> x</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[([0, 0, 0], 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])</span><br><span class="line"> ([0, 0, 0], 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])</span><br><span class="line"> ([0, 0, 0], 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])]</span><br></pre></td></tr></table></figure>

<p>总结：字符串创建自定义的“ 结构体元素 ”的方式为 ‘（形状）类型一，（形状）类型二，（形状）类型三’  的形式</p>
<p><strong>（2）方法二：使用元组创建dtype类型</strong></p>
<p><strong>（3）方法三：使用列表创建dtype类型</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = np.zeros(<span class="number">5</span>, dtype=[(<span class="string">'age'</span>,<span class="string">'int'</span>), (<span class="string">'height'</span>,<span class="string">'i8'</span>), (<span class="string">'weight'</span>,np.float), (<span class="string">'width'</span>,<span class="string">'float'</span>,(<span class="number">2</span>,<span class="number">3</span>))])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 第一个字段为age ，可以直接使用 int、float等等</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 第二个参数为height ，可以使用 i4、i8、f8等形式的参数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 第三个参数为weight ，可以使用np的定义的类型</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 第四个参数为width ，还可以给参数指定形状（2，3)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[(0, 0, 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])</span><br><span class="line"> (0, 0, 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])</span><br><span class="line"> (0, 0, 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])</span><br><span class="line"> (0, 0, 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])</span><br><span class="line"> (0, 0, 0.0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])]</span><br></pre></td></tr></table></figure>

<p>总结：使用列表定义dtype的一般格式为：</p>
<p>[ (‘ 字段一 ‘，’类型一‘，（形状一）),(‘ 字段二 ‘，’类型二，（形状二）),(‘ 字段三 ‘，’类型三‘，（形状三）)]</p>
<p><strong>（4）方法四：使用字典创建dtype类型</strong></p>
<p>student_type={‘names’:(‘name’, ‘age’, ‘sex’,’weight’), ‘formats’:(‘U10’, ‘i4’,’U6’, ‘f8’)}<br>通过指定字典的 names和formats 去实现。</p>
<h3 id="numpy读取本地文件"><a href="#numpy读取本地文件" class="headerlink" title="numpy读取本地文件"></a>numpy读取本地文件</h3><p>轴axis</p>
<p>一维0轴，二维0，1轴，三维0，1，2轴</p>
<p>并不会经常用numpy读取，pandas有更强大的方法</p>
<table>
<thead>
<tr>
<th></th>
<th>np.loadtxt(frame,dtype= ,delimiter= ,skiprows= ,usecols= ,unpack= )</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/8.png" alt="8"></td>
</tr>
</tbody></table>
<h3 id="numpy索引和切片"><a href="#numpy索引和切片" class="headerlink" title="numpy索引和切片"></a>numpy索引和切片</h3><table>
<thead>
<tr>
<th>操作（查找、修改值）</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>取一行</td>
<td>a[1]</td>
</tr>
<tr>
<td>取多行</td>
<td>a[1:3]</td>
</tr>
<tr>
<td>取不连续的多行</td>
<td>a[[2,4,6]]</td>
</tr>
<tr>
<td>取一列</td>
<td>a[:,2]</td>
</tr>
<tr>
<td>取多列</td>
<td>a[:,2:4]</td>
</tr>
<tr>
<td>取不连续的多列</td>
<td>a[:,[0,2]]</td>
</tr>
<tr>
<td>一个值</td>
<td>a[2,3]</td>
</tr>
<tr>
<td></td>
<td>a[2:3,3:4]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>修改值直接取出来赋值即可还可以调节查找然后赋值</td>
<td>a[a&lt;10]=3</td>
</tr>
<tr>
<td>a&lt;10替换为0，否则10</td>
<td>np.where(a&lt;10,0,10)</td>
</tr>
<tr>
<td>a&lt;10替换为10，a&gt;18替换为18</td>
<td>a.clip(10,18)</td>
</tr>
</tbody></table>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><table>
<thead>
<tr>
<th>操作</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>获取最大值最小值的位置</td>
<td>np.argmax(a,axis=0)            min</td>
</tr>
<tr>
<td>创建全0数组</td>
<td>np.zeros((3,4))</td>
</tr>
<tr>
<td>全1</td>
<td>ones</td>
</tr>
<tr>
<td>对角线为1的方阵</td>
<td>np.eye(3)</td>
</tr>
</tbody></table>
<p>numpy生成随机数</p>
<p>np.random.xxx</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/9.png" alt="9"></p>
<table>
<thead>
<tr>
<th>a=b</th>
<th>完全不复制，ab互相影响</th>
</tr>
</thead>
<tbody><tr>
<td>a=b[:]</td>
<td>视图的操作，一种切片，会创建新的对象a，a的数据完全由b保管，ab数据变化一致</td>
</tr>
<tr>
<td>a=b.copy()</td>
<td>复制，ab互不影响</td>
</tr>
</tbody></table>
<h3 id="nan、inf"><a href="#nan、inf" class="headerlink" title="nan、inf"></a>nan、inf</h3><table>
<thead>
<tr>
<th>nan</th>
<th>not a number</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>出现：数据有缺失，不合适的计算</td>
</tr>
<tr>
<td>inf</td>
<td>正无穷，-inf负无穷</td>
</tr>
<tr>
<td></td>
<td>比如一个数字除以0，python报错，numpy是inf</td>
</tr>
<tr>
<td></td>
<td>= np.nan<br>np.inf<br>注意二者都是float</td>
</tr>
<tr>
<td>nan注意点</td>
<td><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/10.png" alt="10"></td>
</tr>
<tr>
<td>把nan替换为列的平均值</td>
<td><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/11.png" alt="11"></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t1.shape[<span class="number">1</span>]):  <span class="comment">#遍历每一列</span></span><br><span class="line">  temp_col=t1[:,i]     <span class="comment">#当前一列</span></span><br><span class="line">  nan_num=np.count_nonzero(temp_col!=temp_col) </span><br><span class="line">  <span class="comment">#nan个数，np.count_nonzero（）判断非0元素个数。temp_col为数组，返回的应是一个布尔值数组</span></span><br><span class="line">  <span class="keyword">if</span> nan_num!=<span class="number">0</span>:</span><br><span class="line">    temp_not_nan_col = temp_col[temp_col==temp_col]  <span class="comment">#当前列不为nan的array</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#选中当前为nan的位置，把值赋值为不为nan的数的均值</span></span><br><span class="line">    temp_col[np.isnan(temp_col)] = temp_not_nan_col.mean()</span><br></pre></td></tr></table></figure>

<h3 id="numpy常用函数大全"><a href="#numpy常用函数大全" class="headerlink" title="numpy常用函数大全"></a>numpy常用函数大全</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>.ndim ：维度 </p>
<p>.shape ：各维度的尺度 （2，5） </p>
<p>.size ：元素的个数 10 </p>
<p>.dtype ：元素的类型 dtype(‘int32’) </p>
<p>.itemsize ：每个元素的大小，以字节为单位 ，每个元素占4个字节 </p>
<h4 id="ndarray数组的创建"><a href="#ndarray数组的创建" class="headerlink" title="ndarray数组的创建"></a>ndarray数组的创建</h4><p>np.arange(n) ; 元素从0到n-1的ndarray类型 </p>
<p>np.ones(shape): 生成全1 </p>
<p>np.zeros((shape)， ddtype = np.int32) ： 生成int32型的全0 </p>
<p>np.full(shape, val): 生成全为val </p>
<p>np.eye(n) : 生成单位矩阵</p>
<p>np.ones_like(a) : 按数组a的形状生成全1的数组 </p>
<p>np.zeros_like(a): 同理 </p>
<p>np.full_like (a, val) : 同理</p>
<p>np.linspace（1,10,4）： 根据起止数据等间距地生成数组 </p>
<p>np.linspace（1,10,4, endpoint = False）：endpoint 表示10是否作为生成的元素 </p>
<p>np.concatenate()：连接，连接后ndim不变，a和b可以有一维size不同，但size不同的维度必须是要连接的维度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([[<span class="number">5</span>, <span class="number">6</span>]])               <span class="comment">#b是一个二维array</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.concatenate((a, b), axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.concatenate((a, b.T), axis=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])　　　　　　　　　　　　　　　　<span class="comment">#a、b的shape为（2,2），连接第一维就变成（4,2），连接第二维就变成（2,4）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>

<h4 id="数组的维度变换"><a href="#数组的维度变换" class="headerlink" title="数组的维度变换"></a>数组的维度变换</h4><p>.reshape(shape) : 不改变当前数组，依shape生成 </p>
<p>.resize(shape) : 改变当前数组，依shape生成 </p>
<p>.swapaxes(ax1, ax2) : 将两个维度调换 </p>
<p>.flatten() : 对数组进行降维，返回折叠后的一位数组</p>
<h4 id="数组的类型变换"><a href="#数组的类型变换" class="headerlink" title="数组的类型变换"></a>数组的类型变换</h4><p>数据类型的转换 ：a.astype(new_type) : eg, a.astype (np.float) </p>
<p>数组向列表的转换： a.tolist() </p>
<h4 id="数组的索引和切片"><a href="#数组的索引和切片" class="headerlink" title="数组的索引和切片"></a>数组的索引和切片</h4><ul>
<li>一维数组切片</li>
</ul>
<p>a = np.array ([9, 8, 7, 6, 5, ]) </p>
<p>a[1:4:2] –&gt; array([8, 6]) ： a[起始编号：终止编号（不含）： 步长]</p>
<ul>
<li>多维数组索引</li>
</ul>
<p>a = np.arange(24).reshape((2, 3, 4)) </p>
<p>a[1, 2, 3] 表示 3个维度上的编号， 各个维度的编号用逗号分隔</p>
<ul>
<li>多维数组切片</li>
</ul>
<p>a [：，：，：：2 ] 缺省时，表示从第0个元素开始，到最后一个元素 </p>
<h4 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h4><p>np.abs(a) np.fabs(a) : 取各元素的绝对值 </p>
<p>np.sqrt(a) : 计算各元素的平方根 </p>
<p>np.square(a): 计算各元素的平方 </p>
<p>np.log(a) np.log10(a) np.log2(a) : 计算各元素的自然对数、10、2为底的对数 </p>
<p>np.ceil(a) np.floor(a) : 计算各元素的ceiling 值， floor值（ceil向上取整，floor向下取整） </p>
<p>np.rint(a) : 各元素 四舍五入 </p>
<p>np.modf(a) : 将数组各元素的小数和整数部分以两个独立数组形式返回 </p>
<p>np.exp(a) : 计算各元素的指数值 </p>
<p>np.sign(a) : 计算各元素的符号值 1（+），0，-1（-） </p>
<p>np.maximum(a, b) np.fmax() : 比较（或者计算）元素级的最大值 </p>
<p>np.minimum(a, b) np.fmin() : 取最小值 </p>
<p>np.mod(a, b) : 元素级的模运算 </p>
<p>np.copysign(a, b) : 将b中各元素的符号赋值给数组a的对应元素</p>
<h4 id="数据的CSV文件存取"><a href="#数据的CSV文件存取" class="headerlink" title="数据的CSV文件存取"></a>数据的CSV文件存取</h4><p>CSV (Comma-Separated Value,逗号分隔值) 只能存储一维和二维数组</p>
<p>np.savetxt(frame, array, fmt=’% .18e’, delimiter = None): frame是文件、字符串等，可以是.gz .bz2的压缩文件； array 表示存入的数组； fmt 表示元素的格式 eg： %d % .2f % .18e ; </p>
<p>delimiter： 分割字符串，默认是空格 </p>
<p>eg： np.savetxt(‘a.csv’, a, fmt=%d, delimiter = ‘,’ )</p>
<p>np.loadtxt(frame, dtype=np.float, delimiter = None, unpack = False) : frame是文件、字符串等，可以是.gz .bz2的压缩文件； dtype：数据类型，读取的数据以此类型存储； delimiter: 分割字符串，默认</p>
<p>是空格; unpack: 如果为True， 读入属性将分别写入不同变量。 </p>
<p>多维数据的存取 </p>
<p>a.tofile(frame, sep=’’, format=’%s’ ) : frame: 文件、字符串； sep: 数据分割字符串，如果是空串，</p>
<p>写入文件为二进制 ； format:： 写入数据的格式 </p>
<p>eg: a = np.arange(100).reshape(5, 10, 2) </p>
<p>a.tofile(“b.dat”, sep=”,”, format=’%d’)</p>
<p>np.fromfile(frame, dtype = float, count=-1, sep=’’)： frame： 文件、字符串 ； dtype： 读取的数据以此类型存储； count：读入元素个数， -1表示读入整个文件； sep: 数据分割字符串，如果是空串，写</p>
<p>入文件为二进制</p>
<p>PS: a.tofile() 和np.fromfile（）要配合使用，要知道数据的类型和维度。</p>
<p>np.save(frame, array) : frame: 文件名，以.npy为扩展名，压缩扩展名为.npz ； array为数组变量 </p>
<p>np.load(fname) : frame: 文件名，以.npy为扩展名，压缩扩展名为</p>
<p>np.save() 和np.load() 使用时，不用自己考虑数据类型和维度。</p>
<h4 id="numpy随机数函数"><a href="#numpy随机数函数" class="headerlink" title="numpy随机数函数"></a>numpy随机数函数</h4><p>numpy 的random子库</p>
<p>rand(d0, d1, …,dn) : 各元素是[0, 1）的浮点数，服从均匀分布 </p>
<p>randn(d0, d1, …,dn)：标准正态分布 </p>
<p>random.randint(a,b)：用于生成一个指定范围内的整数。[a，b]</p>
<p>randint(low， high,（ shape）): 依shape创建随机整数或整数数组，范围是[ low, high） </p>
<p>seed(s) ： 随机数种子</p>
<p>shuffle(a) : 根据数组a的第一轴进行随机排列，改变数组a </p>
<p>permutation(a) : 根据数组a的第一轴进行随机排列， 但是不改变原数组，将生成新数组 </p>
<p>choice(a[, size, replace, p]) : 从一维数组a中以概率p抽取元素， 形成size形状新数组，replace表示是</p>
<p>否可以重用元素，默认为False。 </p>
<p>eg： </p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/12.png" alt="12" style="zoom:53%;">

<p>replace = False时，选取过的元素将不会再选取</p>
<p>uniform(low, high, size) : 产生均匀分布的数组，起始值为low，high为结束值，size为形状 </p>
<p>normal(loc, scale, size) : 产生正态分布的数组， loc为均值，scale为标准差，size为形状 </p>
<p>poisson(lam, size) : 产生泊松分布的数组， lam随机事件发生概率，size为形状 </p>
<p>eg: a = np.random.uniform(0, 10, (3, 4)) a = np.random.normal(10, 5, (3, 4))</p>
<h4 id="numpy的统计函数"><a href="#numpy的统计函数" class="headerlink" title="numpy的统计函数"></a>numpy的统计函数</h4><p>sum(a, axis = None) : 依给定轴axis计算数组a相关元素之和，axis为整数或者元组 </p>
<p>mean(a, axis = None) : 同理，计算平均值 </p>
<p>average(a, axis =None, weights=None) : 依给定轴axis计算数组a相关元素的加权平均值 </p>
<p>std（a, axis = None） ：同理，计算标准差 </p>
<p>var（a, axis = None）: 计算方差 </p>
<p>eg： np.mean(a, axis =1) ： 对数组a的第二维度的数据进行求平均 </p>
<p>a = np.arange(15).reshape(3, 5) </p>
<p>np.average(a, axis =0, weights =[10, 5, 1]) : 对a第一各维度加权求平均，weights中为权重，注意要</p>
<p>和a的第一维匹配</p>
<p>min(a) max(a) : 计算数组a的最小值和最大值 </p>
<p>argmin(a) argmax(a) : 计算数组a的最小、最大值的下标（注：是一维的下标） </p>
<p>unravel_index(index, shape) : 根据shape将一维下标index转成多维下标 </p>
<p>ptp(a) : 计算数组a最大值和最小值的差 </p>
<p>median(a) : 计算数组a中元素的中位数（中值） </p>
<p>eg：a = [[15, 14, 13], </p>
<p>[12, 11, 10] ] </p>
<p>np.argmax(a) –&gt; 0 </p>
<p>np.unravel_index( np.argmax(a), a.shape) –&gt; (0,0)</p>
<h4 id="numpy的梯度函数"><a href="#numpy的梯度函数" class="headerlink" title="numpy的梯度函数"></a>numpy的梯度函数</h4><p>np.gradient(a) ： 计算数组a中元素的梯度，f为多维时，返回每个维度的梯度 </p>
<p>离散梯度： xy坐标轴连续三个x轴坐标对应的y轴值：a, b, c 其中b的梯度是（c-a）/2 </p>
<p>而c的梯度是： (c-b)/1</p>
<p>当为二维数组时，np.gradient(a) 得出两个数组，第一个数组对应最外层维度的梯度，第二个数组对应第二</p>
<p>层维度的梯度。 </p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/13.png" alt="13" style="zoom:53%;">

<h4 id="图像的表示和变换"><a href="#图像的表示和变换" class="headerlink" title="图像的表示和变换"></a>图像的表示和变换</h4><p>PIL， python image library 库 </p>
<p>from PIL import Image </p>
<p>Image是PIL库中代表一个图像的类（对象）</p>
<p>im = np.array(Image.open(“.jpg”))</p>
<p>im = Image.fromarray(b.astype(‘uint8’)) # 生成 </p>
<p>im.save(“路径.jpg”) # 保存</p>
<p>im = np.array(Image.open(“.jpg”).convert(‘L’)) # convert(‘L’)表示转为灰度图</p>
<h3 id="※-numpy重点函数-※"><a href="#※-numpy重点函数-※" class="headerlink" title="※ numpy重点函数 ※"></a>※ numpy重点函数 ※</h3><p>简略，前几节有对应的详细内容</p>
<h4 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1. 创建数组"></a>1. 创建数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">b[<span class="number">1</span>,<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a.shape</span><br><span class="line"><span class="keyword">print</span> b.shape</span><br><span class="line"><span class="keyword">print</span> a.dtype</span><br><span class="line"><span class="keyword">print</span> b</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(3,)</span><br><span class="line">(3, 3)</span><br><span class="line">int64</span><br><span class="line">[[ 1  2  3]</span><br><span class="line"> [ 4 10  6]</span><br><span class="line"> [ 7  8  9]]</span><br></pre></td></tr></table></figure>

<h4 id="2-结构数组"><a href="#2-结构数组" class="headerlink" title="2. 结构数组"></a>2. 结构数组</h4><h4 id="3-连续数组的创建"><a href="#3-连续数组的创建" class="headerlink" title="3. 连续数组的创建"></a>3. 连续数组的创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.arange(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1 3 5 7 9]</span><br><span class="line">[ 1.  3.  5.  7.  9.]</span><br></pre></td></tr></table></figure>

<p><strong>np.arange</strong>和<strong>np.linspace</strong>起到的作用是一样的，都是创建等差数组。</p>
<p>arange()类似内置函数range()，通过指定初始值、终值、步长来创建等差数列的一维数组，默认是<strong>不包括终值</strong>的。</p>
<p>linspace是linear space的缩写，代表线性等分向量的含义。linspace()通过指定初始值、终值、元素个数来创建等差数列的一维数组，默认是<strong>包括终值</strong>的。</p>
<h4 id="4-算数运算"><a href="#4-算数运算" class="headerlink" title="4. 算数运算"></a>4. 算数运算</h4><p>加、减、乘、除、求n次方和取余数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.arange(<span class="number">1</span>,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> np.add(x1,x2)</span><br><span class="line"><span class="keyword">print</span> np.subtract(x1,x2)</span><br><span class="line"><span class="keyword">print</span> np.multiply(x1,x2)</span><br><span class="line"><span class="keyword">print</span> np.divide(x1,x2)</span><br><span class="line"><span class="keyword">print</span> np.power(x1,x2)  <span class="comment">#power求n次方，x2可以是数或者数组，数组列数要相同</span></span><br><span class="line"><span class="keyword">print</span> np.mod(x1,x2)   <span class="comment">#mod和remainder一样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[  2.   6.  10.  14.  18.]</span><br><span class="line">[ 0.  0.  0.  0.  0.]</span><br><span class="line">[  1.   9.  25.  49.  81.]</span><br><span class="line">[ 1.  1.  1.  1.  1.]</span><br><span class="line">[  1.00000000e+00   2.70000000e+01   3.12500000e+03   8.23543000e+05</span><br><span class="line">   3.87420489e+08]</span><br><span class="line">[ 0.  0.  0.  0.  0.]</span><br></pre></td></tr></table></figure>

<h4 id="5-统计函数"><a href="#5-统计函数" class="headerlink" title="5. 统计函数"></a>5. 统计函数</h4><ul>
<li>计数组/矩阵中的最大值函数<strong>amax()</strong>，最小值函数<strong>amin()</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="keyword">print</span> np.amin(a)</span><br><span class="line"><span class="keyword">print</span> np.amin(a,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.amin(a,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> np.amax(a)</span><br><span class="line"><span class="keyword">print</span> np.amax(a,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.amax(a,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">[1 2 3]</span><br><span class="line">[1 4 7]</span><br><span class="line">9</span><br><span class="line">[7 8 9]</span><br><span class="line">[3 6 9]</span><br></pre></td></tr></table></figure>

<p>amin()用于计算数组中的元素沿指定轴的最小值。对于一个二维数组a，amin(a）指的是数组中全部元素的最小值</p>
<p><strong>amin(a,0)</strong>是延着axis=0轴的最小值，<strong>axis=0轴</strong>是把元素看成了[1,4,7]，[2,5,8]，[3,6,9]三个元素，所以最小值为[1,2,3]。</p>
<p><strong>amin(a,1)</strong>是延着axis=1轴的最小值，<strong>axis=1轴</strong>是把元素看成了[1,2,3], [4,5,6]，[7,8,9]三个元素，所以最小值为[1,4,7]。</p>
<p>同理amax()是计算数组中元素沿指定轴的最大值。</p>
<br>

<ul>
<li>统计最大值与最小值之差 <strong>ptp()</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="keyword">print</span> np.ptp(a)</span><br><span class="line"><span class="keyword">print</span> np.ptp(a,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.ptp(a,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">[6 6 6]</span><br><span class="line">[2 2 2]</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>统计数组的百分位数 <strong>percentile()</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> np.percentile(a,<span class="number">50</span>)</span><br><span class="line"><span class="keyword">print</span> np.percentile(a,<span class="number">50</span>,axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.percentile(a,<span class="number">50</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5.0</span><br><span class="line">[ 4.  5.  6.]</span><br><span class="line">[ 2.  5.  8.]</span><br></pre></td></tr></table></figure>

<p>percentile()代表着第p个百分位数，这里p的取值范围是0-100，如果p=0 ，就是求最小值，如果p=50就是求</p>
<p>平均值，如果p=100就是求最大值。同样你也可以求得在axis=0 和 axis=1 上的p％的百分位数。</p>
<br>

<ul>
<li><strong>median()</strong>和<strong>mean()</strong>求数组的中位数、平均值</li>
</ul>
<p>同样也可以求得在axis=0和1两个轴上的中位数、平均值。</p>
<br>

<ul>
<li><strong>average()</strong>函数可以求加权平均</li>
</ul>
<p>加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的。也可以指定权重数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">wts = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> np.average(a)</span><br><span class="line"><span class="keyword">print</span> np.average(a,weights = wts)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.5</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure>

<ul>
<li>统计数组中的标准差<strong>std()</strong>、方差<strong>var()</strong></li>
</ul>
<p>方差的计算是指每个数值与平均值之差的平方求和的平均值，即mean（（ x-x.mean() )^2 ）。标准差是方差的算术平方根。</p>
<h4 id="6-Numpy排序"><a href="#6-Numpy排序" class="headerlink" title="6. Numpy排序"></a>6. Numpy排序</h4><p><strong>sort</strong>函数，sort(a,axis=-1,kind=‘quicksort’,order=None）</p>
<p>axis默认是-1，即沿着数组的最后一个轴进行排序，也可以取不同的axis轴，或者axis=None代表采用扁平化的方式作为一个向量进行排序。</p>
<p>kind默认quicksort；在kind里，可以指定quicksort、mergesort、heapsort分别表示快速排序、合并排序、堆排序。</p>
<p>另外order字段，对于结构化的数组可以指定按照某个字段进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="keyword">print</span> np.sort(a)</span><br><span class="line"><span class="keyword">print</span> np.sort(a,axis = <span class="number">-1</span>) <span class="comment">#此处最后一个轴即1</span></span><br><span class="line"><span class="keyword">print</span> np.sort(a,axis = <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">print</span> np.sort(a,axis = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> np.sort(a,axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[2 3 4]</span><br><span class="line"> [1 2 4]]</span><br><span class="line">[[2 3 4]</span><br><span class="line"> [1 2 4]]</span><br><span class="line">[1 2 2 3 4 4]</span><br><span class="line">[[2 3 1]</span><br><span class="line"> [4 4 2]]</span><br><span class="line">[[2 3 4]</span><br><span class="line"> [1 2 4]]</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在NumPy学习中，要掌握的就是对数组的使用，这是NumPy和标准Python最大的区别。</p>
<p>在NumPy中重新对数组进行了定义，同时提供了算术和统计运算，可以使用NumPy自带的排序功能，一句话就搞定各种排序算法。</p>
<p>理解NumPy提供的数据结构为什么比Python自身的“更高级、更高效”，要从对数据指针的引用角度进行理解。</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/14.png" alt="14"></p>
<h2 id="5-Pandas"><a href="#5-Pandas" class="headerlink" title="5.Pandas"></a>5.Pandas</h2><h3 id="pandas之字符串方法"><a href="#pandas之字符串方法" class="headerlink" title="pandas之字符串方法"></a>pandas之字符串方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>实现元素级的字符串<strong>连接</strong>操作，可指定分隔符</td>
</tr>
<tr>
<td><strong>contains</strong></td>
<td>返回表示各字符串<strong>是否含有</strong>指定模式的布尔型数组</td>
</tr>
<tr>
<td>count</td>
<td>模式的出现<strong>次数</strong></td>
</tr>
<tr>
<td>endswith, startswith</td>
<td>相当于对各个元素执行x.endswith(pattern)或x.startswith(pattern)</td>
</tr>
<tr>
<td>findall</td>
<td>计算各字符串的模式列表</td>
</tr>
<tr>
<td>get</td>
<td><strong>获取</strong>各元素的第i个字符</td>
</tr>
<tr>
<td>join</td>
<td>根据指定的分隔符将Series中各元素的字符串<strong>连接</strong>起来</td>
</tr>
<tr>
<td><strong>len</strong></td>
<td>计算各字符串的<strong>长度</strong></td>
</tr>
<tr>
<td><strong>lower</strong>、<strong>upper</strong></td>
<td><strong>转换大小写</strong>。相当于对各个元素执行x.lower()或x.upper()</td>
</tr>
<tr>
<td>match</td>
<td>根据指定的正则表达式对各个元素执行re.match</td>
</tr>
<tr>
<td>pad</td>
<td>在字符串的左边、右边或左右两边添加空白符</td>
</tr>
<tr>
<td>center</td>
<td>相当于pad(side=’both’)</td>
</tr>
<tr>
<td>repeat</td>
<td><strong>重复</strong>值。例如，s.str.repeat(3)相当于对各个字符串执行x*3</td>
</tr>
<tr>
<td><strong>replace</strong></td>
<td>用指定字符串<strong>替换</strong>找到的模式</td>
</tr>
<tr>
<td>slice</td>
<td>对Series中的各个字符串进行子串<strong>截取</strong></td>
</tr>
<tr>
<td><strong>split</strong></td>
<td>根据分隔符或正则表达式对字符串进行<strong>拆分</strong><br>expend = True 返回dataframe<br>False 返回Series</td>
</tr>
<tr>
<td>strip、rstrip、Istrip</td>
<td><strong>去除</strong>空白符，包括换行符。相当于对各个元素执行x.strip()、x.rstrip()、<br>x.Istrip()</td>
</tr>
</tbody></table>
<h3 id="series"><a href="#series" class="headerlink" title="series"></a>series</h3><p>在数据分析工作中，Pandas的使用频率是很高的，一方面是因为Pandas提供的基础数据结构DataFrame与json的契合度很高，转换起来就很方便。另一方面，如果我们日常的数据清理工作不是很复杂的话，通常用几句Pandas代码就可以对数据进行规整。</p>
<p>Pandas可以说是基于 NumPy 构建的含有更高级数据结构和分析能力的工具包。在NumPy中数据结构是围绕ndarray展开的，Pandas中的核心数据结构是什么Series和 DataFrame，他们分别代表着一维的序列和二维的表结构。</p>
<p>基于这两种数据结构，Pandas可以对数据进行导入、清洗、处理、统计和输出。</p>
<table>
<thead>
<tr>
<th>常见数据结构</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>series</td>
<td>一维，带标签数组</td>
</tr>
<tr>
<td>dataframe</td>
<td>二维，series容器</td>
</tr>
</tbody></table>
<p>Series是个定长的字典序列。说是定长是因为在存储的时候，相当于两个ndarray，这也是和字典结构最大的不同。因为在字典的结构里，元素的个数是不固定的。</p>
<table>
<thead>
<tr>
<th></th>
<th>import pandas as pd</th>
</tr>
</thead>
<tbody><tr>
<td>series<strong>创建</strong></td>
<td>Series两个基本属性：index和values<br>在Series结构中，index默认是0,1,2……..递增的整数序列，也可以自己指定索引</td>
</tr>
<tr>
<td></td>
<td>t = pd.Series(data=[1, 2, 3, 4], index=[‘a’, ‘b’, ‘c’, ‘d’])<br><br>一个例子：index =list(string.ascii_uppercase[5:15])键为大写字母第6到16个</td>
</tr>
<tr>
<td></td>
<td>方法2：通过一维数组创建序列</td>
</tr>
<tr>
<td></td>
<td>a = np.arange(2, 9)    #索引默认0，1，2… <br>t1 = pd.Series(a)</td>
</tr>
<tr>
<td></td>
<td>方法3：通过字典的方式创建序列</td>
</tr>
<tr>
<td></td>
<td>t2 = pd.Series({‘a’: 10, ‘b’: 20, ‘c’: 30, ‘d’: 40, ‘e’: 50})</td>
</tr>
<tr>
<td><strong>t.index</strong><br><strong>t.values</strong></td>
<td>type()、len()、list()</td>
</tr>
<tr>
<td></td>
<td>print(type(t2.index))   #&lt;class ‘pandas.core.indexes.base.Index’&gt;<br>print(len(t2.index))     #5<br>print(list(t2.index))     #[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]</td>
</tr>
<tr>
<td>t.tolist()</td>
<td>series转换为list，返回value list</td>
</tr>
<tr>
<td>set()</td>
<td>去重<br>查看某一列都有哪些种数据时，（）内写对应列即可</td>
</tr>
</tbody></table>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><table>
<thead>
<tr>
<th></th>
<th>读取数据</th>
</tr>
</thead>
<tbody><tr>
<td>读取csv文件</td>
<td>t = pd.read_csv(‘./xxx.csv’)</td>
</tr>
<tr>
<td></td>
<td>读取时可以规范数据类型<br> ,dtype={‘列名’: int}<br>增加列头<br>column_names = [‘’, ‘’, …]<br>,names = column_names</td>
</tr>
<tr>
<td>网络读取</td>
<td>data_url = “<a href="https://raw.githubusercontent.com/.csv&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/.csv&quot;</a> #填写url读取 <br>df = pd.read_csv(data_url)</td>
</tr>
<tr>
<td>读取Mysql数据</td>
<td>假设数据库安装在本地，用户名为myusername,密码为mypassword,要读取mydb数据库中的数据 <br>import MySQLdb<br>mysql_cn= MySQLdb.connect(host=’localhost’, port=3306,user=’myusername’, passwd=’mypassword’, db=’mydb’)<code></code>df = pd.read_sql(‘select * from test;’, con=mysql_cn)    mysql_cn.close()`</td>
</tr>
<tr>
<td>数据导出为csv文件</td>
<td>df.to_csv(‘./demo.csv’, encoding=’utf-8’, index=False)  #index=False表示导出时去掉行名称，如果数据中含有中文，一般encoding指定为‘utf-8’</td>
</tr>
<tr>
<td>导出为json文件</td>
<td>df . to_json(‘ ‘ , orient= ‘ ‘  )</td>
</tr>
<tr>
<td></td>
<td>orient可以决定输出格式<br>为records时，输出列表嵌套字典<br>其他可见官网demo<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_json.html" target="_blank" rel="noopener">to_json参数官网demo</a></td>
</tr>
<tr>
<td>xlsx文件</td>
<td>pd.read_excel(‘’)<br>df.to_excel(‘’)</td>
</tr>
</tbody></table>
<p> 将excel文件处理为列表嵌套字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df=pd.read_excel(<span class="string">'lemon.xlsx'</span>)</span><br><span class="line">test_data=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> df.index.values:                         <span class="comment">#获取行号的索引，并对其进行遍历</span></span><br><span class="line">  row_data=df.loc[i,[<span class="string">'列名'</span>, <span class="string">'列名'</span>...]].to_dict() <span class="comment">#根据i获取每一行指定的数据,利用to_dict转成字典</span></span><br><span class="line">  test_data.append(row_data)</span><br><span class="line">df = <span class="string">'&#123;0&#125;'</span>.format(test_data)                      <span class="comment">#format 拼接</span></span><br></pre></td></tr></table></figure>

<p>###DataFrame</p>
<table>
<thead>
<tr>
<th>行索引</th>
<th>index，axis=0</th>
</tr>
</thead>
<tbody><tr>
<td>列索引</td>
<td>columns，axis=1</td>
</tr>
<tr>
<td>创建DataFrame</td>
<td>t=pd.DataFrame（np.arange(12).reshape((3,4))，index=  , columns= ） <br>也可以由字典、列表嵌套字典创建</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = pd.DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>], <span class="string">'d'</span>: list(<span class="string">"hjklmno"</span>)&#125;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   a  b    c  d</span><br><span class="line">0  0  7  one  h</span><br><span class="line">1  1  6  one  j</span><br><span class="line">2  2  5  one  k</span><br><span class="line">3  3  4  two  l</span><br><span class="line">4  4  3  two  m</span><br><span class="line">5  5  2  two  n</span><br><span class="line">6  6  1  two  o</span><br></pre></td></tr></table></figure>

<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/15.png" alt="15"></p>
<p>获得数据可以先用</p>
<p>info(）、head（1）、describe（）</p>
<p>看一下数据情况</p>
<h4 id="DataFrame的一些操作"><a href="#DataFrame的一些操作" class="headerlink" title="DataFrame的一些操作"></a>DataFrame的一些操作</h4><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><table>
<thead>
<tr>
<th>去重</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>df.drop_duplicates(subset=None, keep=’first’, inplace=False)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>df.drop_duplicates()df中一行元素全部相同时才去除</td>
</tr>
<tr>
<td></td>
<td>df.drop_duplicates([‘a’,’b’])df根据’a’,’b’组合列删除重复项，默认保留第一个出现的值组合。传入参数keep=’last’则保留最后一个</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>set（df[‘列名’]）</td>
<td><strong>去重</strong>（仅结果），看这一列有哪些不同值</td>
</tr>
<tr>
<td>df[‘’].value_counts()</td>
<td>查看表格某列中有多少个<strong>不同值</strong><br>并计算每个不同值有在该列中有多少重复值<br>返回Series，index值，value有几个</td>
</tr>
</tbody></table>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'b'</span>: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="string">'c'</span>: [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">  print(index)</span><br><span class="line">  print(row)</span><br></pre></td></tr></table></figure>

<p>这里的iterrows()返回值为元组,(index,row)<br>上面的代码里，for循环定义了两个变量，index，row，那么返回的元组，index=index，row=row.</p>
<p>index行索引0、1、2、3，row此行内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   a  b   c</span><br><span class="line">0  1  5   9</span><br><span class="line">1  2  6  10</span><br><span class="line">2  3  7  11</span><br><span class="line">3  4  8  12</span><br><span class="line">0</span><br><span class="line">a    1</span><br><span class="line">b    5</span><br><span class="line">c    9</span><br><span class="line">Name: 0, dtype: int64</span><br><span class="line">1</span><br><span class="line">a     2</span><br><span class="line">b     6</span><br><span class="line">c    10</span><br><span class="line">Name: 1, dtype: int64</span><br><span class="line">2</span><br><span class="line">a     3</span><br><span class="line">b     7</span><br><span class="line">c    11</span><br><span class="line">Name: 2, dtype: int64</span><br><span class="line">3</span><br><span class="line">a     4</span><br><span class="line">b     8</span><br><span class="line">c    12</span><br><span class="line">Name: 3, dtype: int64</span><br></pre></td></tr></table></figure>

<p>如果for循环时，只定义一个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">  print(row)</span><br></pre></td></tr></table></figure>

<p>那么row就是整个元组。输出结果可以看出： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   a  b   c</span><br><span class="line">0  1  5   9</span><br><span class="line">1  2  6  10</span><br><span class="line">2  3  7  11</span><br><span class="line">3  4  8  12</span><br><span class="line">(0, a    1</span><br><span class="line">b    5</span><br><span class="line">c    9</span><br><span class="line">Name: 0, dtype: int64)</span><br><span class="line">(1, a     2</span><br><span class="line">b     6</span><br><span class="line">c    10</span><br><span class="line">Name: 1, dtype: int64)</span><br><span class="line">(2, a     3</span><br><span class="line">b     7</span><br><span class="line">c    11</span><br><span class="line">Name: 2, dtype: int64)</span><br><span class="line">(3, a     4</span><br><span class="line">b     8</span><br><span class="line">c    12</span><br><span class="line">Name: 3, dtype: int64)</span><br></pre></td></tr></table></figure>

<h5 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h5><table>
<thead>
<tr>
<th>对列操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>对某一列数据进行<strong>修改</strong></td>
<td>df[‘列名’] = df[‘列名’].map（lambda x：操作）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>直接把<strong>索引值赋给</strong>某列</td>
<td>df[‘列名’] = df . index</td>
</tr>
<tr>
<td><strong>类型转换</strong></td>
<td>df[‘列名’] = df[‘列名’] . astype(‘’)</td>
</tr>
<tr>
<td></td>
<td>‘’内int… ，也可以直接改整个dataframe的类型</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>重命名</strong></td>
<td>df.rename(columns={‘A’:’a’, ‘B’:’b’, ‘C’:’c’}, inplace = True)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>df[‘c’] = ‘0’</td>
<td>给df增加一个<strong>全为0的列</strong>，列名为c</td>
</tr>
<tr>
<td>df[‘列名’] = 值</td>
<td>会warning，但可以直接加进一列</td>
</tr>
<tr>
<td>+</td>
<td>列名相同，DataFrame的值可以直接对应<strong>相加</strong></td>
</tr>
</tbody></table>
<h5 id="行列操作"><a href="#行列操作" class="headerlink" title="行列操作"></a>行列操作</h5><table>
<thead>
<tr>
<th><strong>取行取列</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>df.loc<br>通过行列名称</td>
<td>df.loc[‘A’，[‘W’，’Z’]]<br>行索引A，列W，Z<br><br>df.loc[‘A’]<br>df.loc[:, ‘w’]</td>
</tr>
<tr>
<td>df.iloc<br>通过行数列数</td>
<td>df.iloc[0:3]</td>
</tr>
<tr>
<td></td>
<td>loc、iloc只有一位时，都是指行</td>
</tr>
<tr>
<td>df.ix<br>混合</td>
<td>行名称列名称/行数列数混合<br>如果是行/列的名称是int类型时，只能根据行/列名称选，不能根据行数/列数选</td>
</tr>
<tr>
<td>df[]</td>
<td>可以接收行名称或者行数，但必须是<strong>切片</strong><br>df[0:1]<br>行数切片时，如果行索引类型为int，则会根据行数来切片，不会根据行名称切片<br>只能接收列名称，可以是单个或列表<br>df[[‘A’, ‘C’]]</td>
</tr>
<tr>
<td>df.x<br>列</td>
<td>df.A<br>A列</td>
</tr>
<tr>
<td>df.at<br>取值</td>
<td>df.at[0,’A’]<br>0行A列的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>df.corr(<em>method=’pearson’</em>, <em>min_periods=1</em>)</td>
<td>相关系数</td>
</tr>
<tr>
<td></td>
<td>method：可选值为{‘pearson’, ‘kendall’, ‘spearman’}<br>pearson：Pearson相关系数来衡量两个数据集合是否在一条线上面，即针对线性数据的相关系数计算，针对非线性数据便会有误差。<br>kendall：用于反映分类变量相关性的指标，即针对无序序列的相关系数，非正太分布的数据<br>spearman：非线性的，非正太分析的数据的相关系数<br>min_periods：样本最少的数据量</td>
</tr>
<tr>
<td></td>
<td>返回值：各类型之间的相关系数DataFrame表格</td>
</tr>
</tbody></table>
<h5 id="筛选操作"><a href="#筛选操作" class="headerlink" title="筛选操作"></a>筛选操作</h5><table>
<thead>
<tr>
<th>筛选</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Series筛选</td>
<td>即取行取列</td>
</tr>
<tr>
<td></td>
<td>接收参数为单个标签或索引的筛选，返回的都是Series，例如：<br>df.iloc[<code>1</code>] <br>df.iloc[:, <code>2</code>] <br>df.loc[<code>&#39;5&#39;</code>]<br> df.loc[:, <code>&#39;B&#39;</code>] <br>df[<code>&#39;A&#39;</code>] <br>df.A</td>
</tr>
<tr>
<td></td>
<td>接收参数为切片或列表的筛选，即使只有一行/一列数据，返回的都是DataFrame<br>df[<code>0</code>:<code>1</code>] <br>df[<code>&#39;5&#39;</code>: <code>&#39;5&#39;</code>]<br> df.iloc[[<code>1</code>]] <br>df.loc[:, [<code>&#39;B&#39;</code>]]<br> df[[<code>&#39;A&#39;</code>]]<br>如果想获取单行/单列数据的DataFrame，只需要将输入的单个标签或索引改为切片或列表</td>
</tr>
<tr>
<td>bool值列表</td>
<td>[<code>True</code>, <code>False</code>, <code>True</code>, <code>False</code>]<br>DataFrame或者Series可以接受切片/列表参数的地方，都可以接受bool列表，保留bool列表中真值对应的项目<br>（下方代码）</td>
</tr>
<tr>
<td>bool值Series</td>
<td>pd.Series([<code>True</code>, <code>False</code>, <code>True</code>, <code>False</code>], index<code>=</code>df.index)<br>根据bool Series筛选，保留bool Series真值对应的项目<br>（下方代码）<br>1. 按<strong>列</strong>生成的Series，index是原df的<strong>index</strong>，可以对<strong>行</strong>方向操作进行筛选<br>2. 按<strong>行</strong>生成的Series，index是原df的<strong>columns</strong>，可以对<strong>列</strong>方向操作进行筛选</td>
</tr>
<tr>
<td>bool值 DataFrame</td>
<td>保留bool DataFrame真值对应的值，其余值置为NaN<br>chooses =df &gt; 5<br>df[chooses]</td>
</tr>
<tr>
<td>reindex</td>
<td>对行/列进行筛选，它不会修改原DataFrame<br>df.reindex(index=list(‘67’))      # 筛选出行名称为6和7的行 <br>df.reindex(columns=list(‘BC’))    # 筛选出列名称为B和C的列</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>, <span class="number">4</span>), columns=list(<span class="string">'ABCD'</span>), index=list(<span class="string">'5678'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># bool列表</span></span><br><span class="line"><span class="comment"># 1.生成bool列表</span></span><br><span class="line">chooses = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">chooses = [i == <span class="number">0</span> <span class="keyword">or</span> i == <span class="number">8</span> <span class="keyword">for</span> i <span class="keyword">in</span> df[<span class="string">'A'</span>]]  <span class="comment"># 结果是[True, False, True, False]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.筛选</span></span><br><span class="line">df.iloc[chooses]     <span class="comment"># 只留第1第3行</span></span><br><span class="line">df.loc[:, chooses]   <span class="comment"># 只留第1第3列</span></span><br><span class="line">df.ix[chooses]       <span class="comment"># 只留第1第3行</span></span><br><span class="line">df[chooses]          <span class="comment"># 只留第1第3行</span></span><br><span class="line">df[<span class="string">'A'</span>][chooses]     <span class="comment"># 只留A列中第1第3个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bool Series</span></span><br><span class="line"><span class="comment"># 1.生成列方向的bool Series</span></span><br><span class="line">chooses = pd.Series([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>], index=df.index)</span><br><span class="line">chooses = df.loc[:, <span class="string">'A'</span>] &gt; <span class="number">1</span></span><br><span class="line">chooses = df.iloc[:, <span class="number">0</span>] &gt; <span class="number">1</span></span><br><span class="line">chooses = df[<span class="string">'A'</span>] &gt; <span class="number">1</span></span><br><span class="line">chooses = df[<span class="string">'A'</span>] == <span class="number">4</span></span><br><span class="line">chooses1 = ~(df.A == <span class="number">4</span>)   <span class="comment"># 可以直接取反，等效df.A != 4</span></span><br><span class="line">chooses2 = ~(df[<span class="string">'A'</span>] &gt; <span class="number">1</span>)</span><br><span class="line">chooses = df[<span class="string">'A'</span>].isin(range(<span class="number">9</span>))  <span class="comment"># A列的值是否在range(9)中</span></span><br><span class="line">chooses = (df[<span class="string">'A'</span>].isin(range(<span class="number">9</span>))) &amp; (df[<span class="string">'B'</span>] &gt; <span class="number">1</span>)  <span class="comment"># bool Series的&amp;运算，即同时满足A列range(9)内，B列大于1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在行方向筛选（iloc用不了）</span></span><br><span class="line">print(chooses.index)    <span class="comment"># Index(['1', '2', '3', '4'], dtype='object')</span></span><br><span class="line">df[chooses]             <span class="comment"># DataFrame[]</span></span><br><span class="line">df.A[chooses]           <span class="comment"># Series[]</span></span><br><span class="line">df.loc[chooses]         <span class="comment"># loc</span></span><br><span class="line">df.iloc[chooses]        <span class="comment"># 应用在iloc会报错，ValueError</span></span><br><span class="line">df = df.ix[chooses]     <span class="comment"># ix</span></span><br><span class="line">df = df.loc[:, chooses] <span class="comment"># 应用在列方向会报错，pandas.core.indexing.IndexingError</span></span><br><span class="line"></span><br><span class="line">df[(chooses1) | (chooses2)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.生成行方向的bool Series</span></span><br><span class="line">chooses = pd.Series([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>], index=df.columns)</span><br><span class="line">chooses = df.loc[<span class="string">'1'</span>] &gt; <span class="number">1</span></span><br><span class="line">chooses = df.iloc[<span class="number">0</span>] &gt; <span class="number">1</span></span><br><span class="line"><span class="comment"># 2.在列方向筛选</span></span><br><span class="line">print(choose.index)   <span class="comment"># Index(['A', 'B', 'C', 'D'], dtype='object')</span></span><br><span class="line">df.loc[:, chooses]      <span class="comment"># loc</span></span><br><span class="line">df.iloc[:, chooses]     <span class="comment"># 应用在iloc会报错，ValueError</span></span><br><span class="line">df.ix[:, chooses]       <span class="comment"># ix</span></span><br><span class="line">df.loc[chooses]         <span class="comment"># 应用在行方向报错，pandas.core.indexing.IndexingError</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D</span><br><span class="line">5   0   1   2   3</span><br><span class="line">6   4   5   6   7</span><br><span class="line">7   8   9  10  11</span><br><span class="line">8  12  13  14  15</span><br></pre></td></tr></table></figure>

<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><table>
<thead>
<tr>
<th>删除行列</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>删除行</strong></td>
<td></td>
</tr>
<tr>
<td>df.drop()</td>
<td>行名称<br>df.drop([‘1’, ‘2’])<br>默认axis=0（行操作）inplace=False（不在原表操作）</td>
</tr>
<tr>
<td></td>
<td>行号<br>df.drop(df.index[0])</td>
</tr>
<tr>
<td>筛选方法</td>
<td>通过判断等筛选方法实现删除行，上面的笔记有，此处举个例子去重<strong>drop_duplicates()</strong>，见下方代码</td>
</tr>
<tr>
<td><strong>删除列</strong></td>
<td></td>
</tr>
<tr>
<td>del</td>
<td>del df[‘A’]<br>就地修改</td>
</tr>
<tr>
<td>df.drop()</td>
<td>列名称<br>df.drop([<code>&#39;B&#39;</code>, <code>&#39;C&#39;</code>], axis<code>=</code>1<code>, inplace</code>=<code>True</code>)<br>列数<br>df.drop(df.columns[<code>0</code>:<code>3</code>], axis<code>=</code>1<code>, inplace</code>=<code>True</code>)</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对某行数据去重，可以获取去重后的index列表后，使用loc方法</span></span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>, <span class="number">4</span>), columns=list(<span class="string">'ABCD'</span>), index=list(<span class="string">'1234'</span>))</span><br><span class="line">df.loc[<span class="string">'2'</span>,<span class="string">'B'</span>]=<span class="number">9</span></span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">chooses = df[<span class="string">'B'</span>].drop_duplicates().index</span><br><span class="line">print(df.loc[chooses])</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D</span><br><span class="line">1   0   1   2   3</span><br><span class="line">2   4   9   6   7</span><br><span class="line">3   8   9  10  11</span><br><span class="line">4  12  13  14  15</span><br><span class="line">		A   B   C   D</span><br><span class="line">1   0   1   2   3</span><br><span class="line">2   4   9   6   7</span><br><span class="line">4  12  13  14  15</span><br></pre></td></tr></table></figure>

<h5 id="增加操作"><a href="#增加操作" class="headerlink" title="增加操作"></a>增加操作</h5><table>
<thead>
<tr>
<th>增加行</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>loc</td>
<td>df.loc[‘5’] =[16, 17, 18, 19]    # 后面的序列是Iterable就行</td>
</tr>
<tr>
<td>at</td>
<td>df.at[‘5’] =[16, 17, 18, 19]</td>
</tr>
<tr>
<td>set_value</td>
<td>df.set_value(<code>&#39;5&#39;</code>, df.columns, [<code>16</code>, <code>17</code>, <code>18</code>, <code>19</code>], takeable<code>=</code>False)<br># warning，set_value会被取消</td>
</tr>
<tr>
<td>append</td>
<td>添加有name的Series：<br>s =pd.Series([<code>16</code>, <code>17</code>, <code>18</code>, <code>19</code>], index<code>=</code>df.columns, name<code>=</code>‘5’) <br>df = df.append(s)</td>
</tr>
<tr>
<td></td>
<td>添加没有name的Series，必须ignore_index<br>s =pd.Series([<code>16</code>, <code>17</code>, <code>18</code>, <code>19</code>], index<code>=</code>df.columns) <br>df =df.append(s, ignore_index<code>=</code>True)</td>
</tr>
<tr>
<td></td>
<td>可以 append字典列表，同样需要必须ignore_index：<br>ls <code>=[{</code>‘A’<code>:</code>16<code>,</code>‘B’<code>:</code>17<code>,</code>‘C’<code>:</code>18<code>,</code>‘D’<code>:</code>19<code>}, {</code>‘A’<code>:</code>20<code>,</code>‘B’<code>:</code>21<code>,</code>‘C’<code>:</code>22<code>,</code>‘D’<code>:</code>23}] <br>df <code>=df.append(ls, ignore_index</code>=<code>True</code>)</td>
</tr>
<tr>
<td>逐行增加</td>
<td></td>
</tr>
<tr>
<td></td>
<td>df.loc[<code>len</code>(df)] <code>=[</code>16<code>,</code>17<code>,</code>18<code>,</code>19]<br>len(df)生成的是int，如果生成的int，df已经存在了，会覆盖该行数据，而不会新增</td>
</tr>
<tr>
<td>插入行</td>
<td></td>
</tr>
<tr>
<td></td>
<td>增加行没找到类似insert这种可以插入的方法，暂时替代方法可以先reindex，再赋值：<br>df =df.reindex(index<code>=</code>df.index.insert(2, ‘5’))<br>df.loc[‘5’] =[<code>16</code>, <code>17</code>, <code>18</code>, <code>19</code>]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>增加列</strong></td>
<td>一般涉及到增加列项时，经常会对现有的数据进行遍历运算，获得新增列项的值<br>例如，想增加一列’E’，值等于’A’和’C’列对应值之和。</td>
</tr>
<tr>
<td></td>
<td>遍历DataFrame获取序列s见下方代码</td>
</tr>
<tr>
<td>df[‘E’ ]</td>
<td></td>
</tr>
<tr>
<td>df.loc[:, ‘E’]</td>
<td>df.loc[条件,新增列] = 赋初始值</td>
</tr>
<tr>
<td>df.insert(0,’E’,s)</td>
<td>指定插入位置，和插入列名称，插入内容</td>
</tr>
<tr>
<td>pd.concat()</td>
<td></td>
</tr>
<tr>
<td>逐列增加</td>
<td>df[<code>len</code>(df)] <code>=[</code>16<code>,</code>17<code>,</code>18<code>,</code>19]</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = [a + c <span class="keyword">for</span> a, c <span class="keyword">in</span> zip(df[<span class="string">'A'</span>], df[<span class="string">'C'</span>])]          <span class="comment"># 通过遍历获取序列</span></span><br><span class="line">s = [row[<span class="string">'A'</span>] + row[<span class="string">'C'</span>] <span class="keyword">for</span> i, row <span class="keyword">in</span> df.iterrows()]  <span class="comment"># 通过iterrows()获取序列，s为list</span></span><br><span class="line">s = df.apply(<span class="keyword">lambda</span> row: row[<span class="string">'A'</span>] + row[<span class="string">'C'</span>], axis=<span class="number">1</span>)  <span class="comment"># 通过apply获取序列，s为Series</span></span><br><span class="line">s = df[<span class="string">'A'</span>] + df[<span class="string">'C'</span>]                                  <span class="comment"># 通过Series矢量相加获取序列</span></span><br><span class="line">s = df[<span class="string">'A'</span>].values + df[<span class="string">'C'</span>].values                    <span class="comment"># 通过Numpy矢量相加获取序列</span></span><br><span class="line"></span><br><span class="line">df.loc[:, <span class="string">'E'</span>] = s</span><br><span class="line">df[<span class="string">'E'</span>] = s</span><br><span class="line"></span><br><span class="line">df.insert(<span class="number">0</span>, <span class="string">'E'</span>, s)</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>], name=<span class="string">'E'</span>, index=df.index)</span><br><span class="line">df = pd.concat([df, s], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>代码运行行列展示时，<strong>更改默认显示</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示所有列</span></span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#显示所有行</span></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#设置value的显示长度为100，默认为50</span></span><br><span class="line">pd.set_option(<span class="string">'max_colwidth'</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="排序、缺失值处理"><a href="#排序、缺失值处理" class="headerlink" title="排序、缺失值处理"></a>排序、缺失值处理</h3><table>
<thead>
<tr>
<th>排序</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>df.sort_values<br>(by=’ ‘, ascending= )</td>
<td>ascending= True升序 False降序</td>
</tr>
<tr>
<td></td>
<td>想对相等值在排序时分配相同序号（series和df皆可）</td>
</tr>
<tr>
<td>df . rank( )</td>
<td>axis:{0 or ‘index’,1 or ‘columns’} default 0<br>即默认按沿着index方向排名</td>
</tr>
<tr>
<td></td>
<td>method:{‘average’,’min’,’max’,’first’,’dense’}<br>指定排名时用于破坏平级关系的method选项（注：值相同的位同一个分组）<br>‘average’：默认：在相等分组中，为各个值分配平均排名<br>‘min’：使用整个分组的最小排名<br>‘max’：使用整个分组的最大排名<br>‘first’：按值在原始数据中的出现顺序分配排名<br>‘dense’：与’min’类似，但是排名每次只会增加1，即并列的数据只占据一个名次</td>
</tr>
<tr>
<td></td>
<td>ascending 是否为升序，默认为True升序</td>
</tr>
<tr>
<td></td>
<td>na_option用于处理NaN值</td>
</tr>
<tr>
<td></td>
<td>‘keep’：leave NA values where they are</td>
</tr>
<tr>
<td></td>
<td>‘top’：smallest rank if ascending</td>
</tr>
<tr>
<td></td>
<td>‘bottom’：smallest rank if dscending</td>
</tr>
<tr>
<td></td>
<td><a href="https://blog.csdn.net/starter_____/article/details/79183595" target="_blank" rel="noopener">rank的一些demo</a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缺失数据的处理</th>
<th>NaN、0</th>
</tr>
</thead>
<tbody><tr>
<td>NaN</td>
<td></td>
</tr>
<tr>
<td>判断是否为NaN</td>
<td>pd.isnull(df)<br>pd.notnull(df)（bool类型）</td>
</tr>
<tr>
<td>处理方式1：删除NaN所在的行列</td>
<td>t.dropna（axis=0，how=’ ‘，inplace=False）<br>axis=默认0，删除列传入1<br>how=’any’当前行只要有NaN就删除<br>how=’all’ 全为则删<br>inplace 是否在原表删除,True 在<br>thresh=n 保留至少有n个非NaN数据的行/列<br>subset=[‘’]选择要检查的列，多个用列名的list作为参数</td>
</tr>
<tr>
<td>2:填充数据</td>
<td>t.fillna（ ） <br>把NaN填充为（）内的值 还可以填充均值什么的t.mean()</td>
</tr>
<tr>
<td>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>t[t==0]=np.nan</td>
</tr>
</tbody></table>
<h3 id="常用统计函数"><a href="#常用统计函数" class="headerlink" title="常用统计函数"></a>常用统计函数</h3><table>
<thead>
<tr>
<th>统计方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>d1.count()</td>
<td>非空元素个数计算</td>
</tr>
<tr>
<td>d1.min()</td>
<td>最小值</td>
</tr>
<tr>
<td>d1.max()</td>
<td>最大值</td>
</tr>
<tr>
<td>d1.idxmin()</td>
<td>最小值的索引值，类似于R中的which.min函数</td>
</tr>
<tr>
<td>d1.idxmax()</td>
<td>最大值的索引值，类似于R中的which.max函数</td>
</tr>
<tr>
<td>d1.quantile(0.1)</td>
<td>10%分位数</td>
</tr>
<tr>
<td>d1.sum()</td>
<td>求和</td>
</tr>
<tr>
<td>d1.mean()</td>
<td>均值</td>
</tr>
<tr>
<td>d1.median()</td>
<td>中位数</td>
</tr>
<tr>
<td>d1.mode()</td>
<td>众数</td>
</tr>
<tr>
<td>d1.var()</td>
<td>方差</td>
</tr>
<tr>
<td>d1.std()</td>
<td>标准差</td>
</tr>
<tr>
<td>d1.mad()</td>
<td>平均绝对偏差</td>
</tr>
<tr>
<td>d1.skew()</td>
<td>偏度</td>
</tr>
<tr>
<td>d1.kurt()</td>
<td>峰度</td>
</tr>
<tr>
<td>d1.describe()</td>
<td>一次性输出多个描述性统计指标，包括：count,mean,std,min,max等</td>
</tr>
</tbody></table>
<h3 id="数据合并、分组"><a href="#数据合并、分组" class="headerlink" title="数据合并、分组"></a>数据合并、分组</h3><table>
<thead>
<tr>
<th>合并</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>df1.join(df2)</td>
<td>默认情况下是把行索引相同的数据合并到一起</td>
</tr>
<tr>
<td></td>
<td><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/16.png" alt="16" style="zoom:70%;"></td>
</tr>
<tr>
<td>pd.merge（df1，df2）</td>
<td>按照指定的列把数据按照一定的方式合并到一起</td>
</tr>
<tr>
<td></td>
<td>默认情况取交集参数：<br>on=’ ‘  合并哪些列<br>left_on=’ ‘  按左侧的哪列合并<br>right_on=’ ‘  右 <br>how=’ ‘   默认情况是inner，即交集<br>                                  outer，并集，NaN补全<br>                                  left，以左边为准，NaN补全<br>                                  right，右，NaN补全</td>
</tr>
<tr>
<td>pd.concat（[，]）</td>
<td>级联，默认沿列方向拼接</td>
</tr>
<tr>
<td></td>
<td>axis 默认为0<br>jion 默认outer</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>分组</th>
<th>groupby（by=’ ‘）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>.mean().count()</td>
</tr>
<tr>
<td></td>
<td>使用聚合方法得到的数据默认是把分组的列当成索引，<br>有时候需要将分组索引也当成一列,<br>此时就可以使用groupby方法中的 as_index=<strong>False</strong> 修改<br>（代码在下面）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>计算分组中非NA值的数量</td>
</tr>
<tr>
<td>sum</td>
<td></td>
</tr>
<tr>
<td>mean</td>
<td></td>
</tr>
<tr>
<td>median</td>
<td></td>
</tr>
<tr>
<td>std、var</td>
<td>标准差、方差</td>
</tr>
<tr>
<td>min、max</td>
<td></td>
</tr>
<tr>
<td>prod</td>
<td>积</td>
</tr>
<tr>
<td>first、last</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>定义自己的聚合函数</td>
<td></td>
</tr>
<tr>
<td>agg（）</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;df = pd.DataFrame(&#123;<span class="string">'k1'</span>: list(<span class="string">'aabba'</span>), <span class="string">'k2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>], <span class="string">'value1'</span>: np.random.randn(<span class="number">5</span>), <span class="string">'value2'</span>: np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line">&gt;&gt;&gt;df</span><br><span class="line">  k1   k2    value1    value2</span><br><span class="line"><span class="number">0</span>  a  one  <span class="number">0.487768</span>  <span class="number">3.194155</span></span><br><span class="line"><span class="number">1</span>  a  two <span class="number">-1.798654</span>  <span class="number">1.003257</span></span><br><span class="line"><span class="number">2</span>  b  one  <span class="number">0.195446</span> <span class="number">-1.420604</span></span><br><span class="line"><span class="number">3</span>  b  two <span class="number">-0.958120</span> <span class="number">-0.477421</span></span><br><span class="line"><span class="number">4</span>  a  one <span class="number">-2.135973</span>  <span class="number">0.239011</span></span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;g1 = df.groupby(<span class="string">'k1'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">cal_size</span><span class="params">(x)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> x.max() - x.min()</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;g1.agg(cal_size)</span><br><span class="line">      value1    value2</span><br><span class="line">k1</span><br><span class="line">a   <span class="number">2.623741</span>  <span class="number">2.955143</span></span><br><span class="line">b   <span class="number">1.153565</span>  <span class="number">0.943184</span></span><br></pre></td></tr></table></figure>

<p>还可以传入多个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;data = g1.agg([<span class="string">'mean'</span>, <span class="string">'std'</span>, cal_size])</span><br><span class="line">&gt;&gt;&gt;data</span><br><span class="line">      value1                        value2</span><br><span class="line">        mean       std  cal_size      mean       std  cal_size</span><br><span class="line">k1</span><br><span class="line">a  <span class="number">-1.148953</span>  <span class="number">1.427441</span>  <span class="number">2.623741</span>  <span class="number">1.478807</span>  <span class="number">1.533894</span>  <span class="number">2.955143</span></span><br><span class="line">b  <span class="number">-0.381337</span>  <span class="number">0.815694</span>  <span class="number">1.153565</span> <span class="number">-0.949012</span>  <span class="number">0.666931</span>  <span class="number">0.943184</span></span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;data[<span class="string">'value1'</span>]</span><br><span class="line">        mean       std  cal_size</span><br><span class="line">k1</span><br><span class="line">a  <span class="number">-1.148953</span>  <span class="number">1.427441</span>  <span class="number">2.623741</span></span><br><span class="line">b  <span class="number">-0.381337</span>  <span class="number">0.815694</span>  <span class="number">1.153565</span></span><br></pre></td></tr></table></figure>

<p>当传入多个函数时，得到的列会以这个函数命名。如果想更改列名的话，我们可以传入一个 (name,function) 元组组成的列表。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;data1 = g1.agg([(<span class="string">'average'</span>, <span class="string">'mean'</span>), (<span class="string">'error'</span>, <span class="string">'std'</span>), (<span class="string">'size'</span>, cal_size)])</span><br><span class="line">&gt;&gt;&gt;data1</span><br><span class="line">      value1                        value2</span><br><span class="line">     average     error      size   average     error      size</span><br><span class="line">k1</span><br><span class="line">a  <span class="number">-1.148953</span>  <span class="number">1.427441</span>  <span class="number">2.623741</span>  <span class="number">1.478807</span>  <span class="number">1.533894</span>  <span class="number">2.955143</span></span><br><span class="line">b  <span class="number">-0.381337</span>  <span class="number">0.815694</span>  <span class="number">1.153565</span> <span class="number">-0.949012</span>  <span class="number">0.666931</span>  <span class="number">0.943184</span></span><br></pre></td></tr></table></figure>

<p>除此之外，我们还可以针对不同的列使用不同的函数，只需要传入一个字典包含列名到函数的映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;g1.agg(&#123;<span class="string">'value1'</span>: <span class="string">'sum'</span>, <span class="string">'value2'</span>: <span class="string">'mean'</span>&#125;)</span><br><span class="line">      value1    value2</span><br><span class="line">k1</span><br><span class="line">a  <span class="number">-3.446859</span>  <span class="number">1.478807</span></span><br><span class="line">b  <span class="number">-0.762674</span> <span class="number">-0.949012</span></span><br></pre></td></tr></table></figure>

<p>as_index=False:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;df.groupby(<span class="string">'k1'</span>, as_index=<span class="literal">False</span>).agg(&#123;<span class="string">'value1'</span>: <span class="string">'sum'</span>, <span class="string">'value2'</span>: <span class="string">'mean'</span>&#125;)</span><br><span class="line">  k1    value1    value2</span><br><span class="line"><span class="number">0</span>  a <span class="number">-3.446859</span>  <span class="number">1.478807</span></span><br><span class="line"><span class="number">1</span>  b <span class="number">-0.762674</span> <span class="number">-0.949012</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>df.as_matrix()</strong>：转换数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">df</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"></span><br><span class="line">df.as_matrix()</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>

<p>不过此方法已经快要被淘汰，会warning。</p>
<p><strong>df.values</strong></p>
<p>用法结果相同，注意没有（）。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><table>
<thead>
<tr>
<th>操作</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td><strong>获取</strong>index</td>
<td>df.index</td>
</tr>
<tr>
<td><strong>指定</strong>index</td>
<td>df.index = [‘x’,’y’]</td>
</tr>
<tr>
<td>重新<strong>设置</strong>index</td>
<td>df.reindex( [‘x’,’y’] )<br>若原本的index中有x，则是取原本的x的值，若没有，则x的值全为NaN</td>
</tr>
<tr>
<td>返回index的<strong>不重复</strong>的值</td>
<td>df.set_index(‘a’).index.unique()<br>返回列a中不重复的值</td>
</tr>
<tr>
<td><strong>指定某一列</strong>作为index</td>
<td>df.set_index(‘a’，drop=False)<br>把a列设为索引，False则原本的列也不删除<br>默认只是返回值更改，原表未改（inplace true改）</td>
</tr>
<tr>
<td></td>
<td>可以指定多列，得到复合索引取的时候可以指定顺序</td>
</tr>
<tr>
<td>index<strong>转换为列</strong></td>
<td>df.reset_index()</td>
</tr>
<tr>
<td></td>
<td>默认将所有索引转换为列<br>level=’ ‘  设置哪些索引转换，’ ‘内索引名称，若没有可用整数表示，多层索引外侧为0</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>交换</strong>多层索引位置</td>
<td>df.swaplevel()<br>常用于想从里层索引取值</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>series<strong>取值</strong></td>
<td>b[] []</td>
</tr>
<tr>
<td>dataframe取值</td>
<td>b.loc[ ].loc[ ]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>将第一列中所有大于4的数修改成0</td>
<td>df[0] [df[0] &gt; 4]  = 0</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>对层次索引进行交换排序等操作</td>
<td><a href="https://www.jianshu.com/p/3ab1554fe6f3" target="_blank" rel="noopener">https://www.jianshu.com/p/3ab1554fe6f3</a></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>], <span class="string">'d'</span>: list(<span class="string">"hjklmno"</span>)&#125;)</span><br><span class="line">print(df.index)</span><br><span class="line"></span><br><span class="line">df.index = [<span class="string">'10'</span>, <span class="string">'11'</span>, <span class="string">'12'</span>, <span class="string">'13'</span>, <span class="string">'14'</span>, <span class="string">'15'</span>, <span class="string">'16'</span>]</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">print(df.set_index(<span class="string">'c'</span>).index.unique())</span><br><span class="line"></span><br><span class="line">df.set_index(<span class="string">'a'</span>, drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df.reset_index()</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RangeIndex(start=0, stop=7, step=1)</span><br><span class="line">    a  b    c  d</span><br><span class="line">10  0  7  one  h</span><br><span class="line">11  1  6  one  j</span><br><span class="line">12  2  5  one  k</span><br><span class="line">13  3  4  two  l</span><br><span class="line">14  4  3  two  m</span><br><span class="line">15  5  2  two  n</span><br><span class="line">16  6  1  two  o</span><br><span class="line">Index([&apos;one&apos;, &apos;two&apos;], dtype=&apos;object&apos;, name=&apos;c&apos;)</span><br><span class="line">   b    c  d</span><br><span class="line">a           </span><br><span class="line">0  7  one  h</span><br><span class="line">1  6  one  j</span><br><span class="line">2  5  one  k</span><br><span class="line">3  4  two  l</span><br><span class="line">4  3  two  m</span><br><span class="line">5  2  two  n</span><br><span class="line">6  1  two  o</span><br><span class="line">   b    c  d</span><br><span class="line">a           </span><br><span class="line">0  7  one  h</span><br><span class="line">1  6  one  j</span><br><span class="line">2  5  one  k</span><br><span class="line">3  4  two  l</span><br><span class="line">4  3  two  m</span><br><span class="line">5  2  two  n</span><br><span class="line">6  1  two  o</span><br></pre></td></tr></table></figure>

<h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>生成一段<strong>时间范围</strong></td>
<td>pd.date_range(start= ,end= ,periods= ,freq= )</td>
</tr>
<tr>
<td></td>
<td>start和end以及freq配合：生成 start和end范围内以频率freq的一组时间索引 <br>start和periods以及freq配合：能够生成从start开始的频率为freq的periods个时间索引<br>eg: start=’20171230’, end=’20180131’, freq=’10D’<br>periods表示生成多少个时间<br>D：一天<br>M：月<br><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/17.png" alt="17" style="zoom:40%;"></td>
</tr>
<tr>
<td>在DataFrame中使用时间序列</td>
<td>index=pd.date_range(‘20170101’,periods=10)<br>df=pd.DataFrame(np.random.rand(10),index=index)</td>
</tr>
<tr>
<td>把时间字符串<strong>转换</strong>为时间序列</td>
<td>df[‘ ‘] = pd.to_datetime(df[‘ ‘], format=’ ‘)</td>
</tr>
<tr>
<td></td>
<td>format参数大部分情况可以不用写，但是对于pandas无法格式化的时间字符串，可以使用</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>重采样</strong></td>
<td>重采样:指的是将时间序列从一个频率转化为另一个频率进行处理的过程将高频率数据转化为低频率数据为降采样,低频率转化为高频率为升采样</td>
</tr>
<tr>
<td></td>
<td>t.resample(‘M’)<br>t.resample(‘M’).mean()<br>t.resample(‘M’).count()</td>
</tr>
<tr>
<td>一些笔记</td>
<td><a href="https://www.cnblogs.com/zhangyafei/p/10513893.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangyafei/p/10513893.html</a><br><a href="https://blog.csdn.net/qq_40587575/article/details/81205873" target="_blank" rel="noopener">https://blog.csdn.net/qq_40587575/article/details/81205873</a></td>
</tr>
</tbody></table>
<p>datetime.strptime()，strftime()   </p>
<ul>
<li>from datetime import datetime  ：datetime是模块，datetime模块还包含一个datetime类</li>
</ul>
<p><strong>strptime</strong>():</p>
<p>用户输入的日期和时间是字符串，要处理日期和时间，首先必须把<strong>str转换为datetime</strong>。</p>
<p>转换方法是通过<code>datetime.strptime()</code>实现，字符串前后格式要对应，需要一个日期和时间的格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">'2017-8-1 18:20:20'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(cday)</span><br><span class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-01</span> <span class="number">18</span>:<span class="number">20</span>:<span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>strftime</strong>():</p>
<p>后台提取到datetime对象后，要把它格式化为字符串显示给用户，就需要<strong>转换为str</strong>，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))</span><br><span class="line">Mon, May <span class="number">08</span> <span class="number">20</span>:<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p><strong>datetime加减</strong>：</p>
<p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(hours=<span class="number">10</span>)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now - timedelta(days=<span class="number">1</span>)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>返回特定部分</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>dt.date()</td>
<td>只返回日期</td>
</tr>
<tr>
<td>.time()</td>
<td>时间</td>
</tr>
<tr>
<td>.year()</td>
<td>年份</td>
</tr>
<tr>
<td>.month()</td>
<td>月</td>
</tr>
<tr>
<td>.weekday()</td>
<td>某天是一个星期的第几天<br>星期一：0<br>星期日：6</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>格式化字符串</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>%<strong>a</strong></td>
<td>星期几的简写;如 星期三为Web</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的全称;如 星期三为Wednesday</td>
</tr>
<tr>
<td>%<strong>b</strong></td>
<td>月份的简写; 如4月份为Apr</td>
</tr>
<tr>
<td>%B</td>
<td>月份的全称; 如4月份为April</td>
</tr>
<tr>
<td>%c</td>
<td>标准的日期的时间串;（如： 04/07/10 10:43:39）</td>
</tr>
<tr>
<td>%C</td>
<td>年份的后两位数字</td>
</tr>
<tr>
<td>%<strong>d</strong></td>
<td>十进制表示的每月的第几天</td>
</tr>
<tr>
<td>%D</td>
<td>月/天/年</td>
</tr>
<tr>
<td>%e</td>
<td>在两字符域中，十进制表示的每月的第几天</td>
</tr>
<tr>
<td>%F</td>
<td>年-月-日</td>
</tr>
<tr>
<td>%g</td>
<td>年份的后两位数字，使用基于周的年</td>
</tr>
<tr>
<td>%G</td>
<td>年分，使用基于周的年</td>
</tr>
<tr>
<td>%h</td>
<td>简写的月份名</td>
</tr>
<tr>
<td>%<strong>H</strong></td>
<td>24小时制的小时</td>
</tr>
<tr>
<td>%I</td>
<td>12小时制的小时</td>
</tr>
<tr>
<td>%j</td>
<td>十进制表示的每年的第几天</td>
</tr>
<tr>
<td>%<strong>m</strong></td>
<td>十进制表示的月份</td>
</tr>
<tr>
<td>%<strong>M</strong></td>
<td>十时制表示的分钟数</td>
</tr>
<tr>
<td>%n</td>
<td>新行符</td>
</tr>
<tr>
<td>%p</td>
<td>本地的AM或PM的等价显示</td>
</tr>
<tr>
<td>%r</td>
<td>12小时的时间</td>
</tr>
<tr>
<td>%R</td>
<td>显示小时和分钟：hh:mm</td>
</tr>
<tr>
<td>%S</td>
<td>十进制的秒数</td>
</tr>
<tr>
<td>%t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>%T</td>
<td>显示时分秒：hh:mm:ss</td>
</tr>
<tr>
<td>%u</td>
<td>每周的第几天，星期一为第一天 （值从0到6，星期一为0）</td>
</tr>
<tr>
<td>%U</td>
<td>第年的第几周，把星期日做为第一天（值从0到53）</td>
</tr>
<tr>
<td>%V</td>
<td>每年的第几周，使用基于周的年</td>
</tr>
<tr>
<td>%<strong>w</strong></td>
<td>十进制表示的星期几（值从0到6，星期天为0）</td>
</tr>
<tr>
<td>%W</td>
<td>每年的第几周，把星期一做为第一天（值从0到53）</td>
</tr>
<tr>
<td>%x</td>
<td>标准的日期串</td>
</tr>
<tr>
<td>%X</td>
<td>标准的时间串</td>
</tr>
<tr>
<td>%<strong>y</strong></td>
<td>不带世纪的十进制年份（值从0到99）</td>
</tr>
<tr>
<td>%<strong>Y</strong></td>
<td>带世纪部分的十制年份</td>
</tr>
<tr>
<td>%z，%Z</td>
<td>时区名称，如果不能得到时区名称则返回空字符。</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
</tbody></table>
<h3 id="※-pandas-重点-※"><a href="#※-pandas-重点-※" class="headerlink" title="※ pandas 重点 ※"></a>※ pandas 重点 ※</h3><p>简略，前几节有对应的详细内容</p>
<h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><p>Series、DataFrame</p>
<h4 id="2-数据导入与输出"><a href="#2-数据导入与输出" class="headerlink" title="2. 数据导入与输出"></a>2. 数据导入与输出</h4><h4 id="3-数据清洗"><a href="#3-数据清洗" class="headerlink" title="3. 数据清洗"></a>3. 数据清洗</h4><table>
<thead>
<tr>
<th>数据清洗常用操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>删除</strong>不必要的列、行</td>
<td>drop、dropna</td>
</tr>
<tr>
<td><strong>重命名</strong>列名</td>
<td>df.rename(columns={‘o’=’n’,…}, inlace=True)</td>
</tr>
<tr>
<td><strong>去重</strong></td>
<td>df.drop_duplicates()</td>
</tr>
<tr>
<td><strong>格式</strong>问题</td>
<td>df[‘’] = df[‘’].astype(‘str’)<br>                                 (np.int64)</td>
</tr>
<tr>
<td>数据间的<strong>空格</strong></td>
<td>有时先把格式转换为str，以方便数据操作</td>
</tr>
<tr>
<td></td>
<td>df[‘’] = df[‘’].str.strip() #删除两边空格<br>lstrip左边、rstrip右边<br>删除特定符号(只能是最两边的)<br>df[‘’].str.strip(‘$’)</td>
</tr>
<tr>
<td><strong>大小写</strong>转换</td>
<td>.str.upper() #大写<br>.str.lower() #小写<br>.str.title()    #首字母大写</td>
</tr>
<tr>
<td>查找<strong>空值</strong>(NaN)</td>
<td>哪个地方存在，返回bool值DataFrame<br>df.isnull()<br>哪列存在，返回bool Series<br>df.isnull.any()</td>
</tr>
<tr>
<td><strong>apply</strong>函数</td>
<td>DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)</td>
</tr>
<tr>
<td></td>
<td>axis = 0以行为轴操作，1 列<br>args传参</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_df</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(df, n, m)</span>:</span></span><br><span class="line">    df[<span class="string">'news1'</span>] = (df[<span class="string">'English'</span>] + df[<span class="string">'Chinese'</span>])*m</span><br><span class="line">    df[<span class="string">'news2'</span>] = (df[<span class="string">'English'</span>] + df[<span class="string">'Chinese'</span>])*n</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'ZhangFei'</span>, <span class="string">'GuanYu'</span>, <span class="string">'ZhaoYun'</span>, <span class="string">'Caocao'</span>, <span class="string">'LiuBei'</span>], <span class="string">'Chinese'</span>: [<span class="number">65</span>, <span class="number">95</span>, <span class="number">93</span>, <span class="number">90</span>, <span class="number">80</span>],<span class="string">'English'</span>: [<span class="number">88</span>, <span class="number">92</span>, <span class="number">72</span>, <span class="number">82</span>, <span class="number">90</span>], <span class="string">'Math'</span>: [<span class="number">68</span>, <span class="number">73</span>, <span class="number">69</span>, <span class="number">84</span>, <span class="number">80</span>]&#125;)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接调用原有函数</span></span><br><span class="line">df[<span class="string">'name'</span>] = df[<span class="string">'name'</span>].apply(str.upper)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列调用，列的数值分别传入def函数</span></span><br><span class="line">df[<span class="string">'Chinese'</span>] = df[<span class="string">'Chinese'</span>].apply(double_df)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrame调用，df传入def函数</span></span><br><span class="line">df = df.apply(plus, axis=<span class="number">1</span>, args=(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">       name  Chinese  English  Math</span><br><span class="line">0  ZhangFei       65       88    68</span><br><span class="line">1    GuanYu       95       92    73</span><br><span class="line">2   ZhaoYun       93       72    69</span><br><span class="line">3    Caocao       90       82    84</span><br><span class="line">4    LiuBei       80       90    80</span><br><span class="line">       name  Chinese  English  Math</span><br><span class="line">0  ZHANGFEI       65       88    68</span><br><span class="line">1    GUANYU       95       92    73</span><br><span class="line">2   ZHAOYUN       93       72    69</span><br><span class="line">3    CAOCAO       90       82    84</span><br><span class="line">4    LIUBEI       80       90    80</span><br><span class="line">       name  Chinese  English  Math</span><br><span class="line">0  ZHANGFEI      130       88    68</span><br><span class="line">1    GUANYU      190       92    73</span><br><span class="line">2   ZHAOYUN      186       72    69</span><br><span class="line">3    CAOCAO      180       82    84</span><br><span class="line">4    LIUBEI      160       90    80</span><br><span class="line">       name  Chinese  English  Math  news1  news2</span><br><span class="line">0  ZHANGFEI      130       88    68    654    436</span><br><span class="line">1    GUANYU      190       92    73    846    564</span><br><span class="line">2   ZHAOYUN      186       72    69    774    516</span><br><span class="line">3    CAOCAO      180       82    84    786    524</span><br><span class="line">4    LIUBEI      160       90    80    750    500</span><br></pre></td></tr></table></figure>

<h5 id="4-数据统计"><a href="#4-数据统计" class="headerlink" title="4. 数据统计"></a>4. 数据统计</h5><h5 id="5-数据表合并"><a href="#5-数据表合并" class="headerlink" title="5. 数据表合并"></a>5. 数据表合并</h5><p>merge</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/19.png" alt="19"></p>
<h2 id="6-学数据分析要掌握的基本概念"><a href="#6-学数据分析要掌握的基本概念" class="headerlink" title="6.学数据分析要掌握的基本概念"></a>6.学数据分析要掌握的基本概念</h2><h3 id="商业智能BI、数据仓库DW、数据挖掘DM"><a href="#商业智能BI、数据仓库DW、数据挖掘DM" class="headerlink" title="商业智能BI、数据仓库DW、数据挖掘DM"></a>商业智能BI、数据仓库DW、数据挖掘DM</h3><p><strong>商业智能</strong>的英文是Business Intelligence，缩写是<strong>BI</strong>。相比于数据仓库、数据挖掘，它是一个更大的概念。 商业智能可以说是基于数据仓库，经过了数据挖掘后，得到了商业价值的过程。所以说数据仓库是个金矿，数据挖掘是炼金术，而商业报告则是黄金。</p>
<p><strong>数据仓库</strong>的英文是Data Warehouse，缩写是<strong>DW</strong>。数据仓库可以说是数据库的升级概念。从逻辑上理解，数据库和数据仓库没 什么区别，都是通过数据库技术来存储数据的。不过从数量上来讲，数据仓库的量更庞大，适用于数据挖掘和数据分析。</p>
<p>数据仓库将原有的<strong>多个数据来源</strong>中的数据进行汇总， 整理而得。数据进入数据仓库前，必须消除数据中的<strong>不一致性</strong>，方便后续进行数据分析和挖掘。</p>
<p><strong>数据挖掘</strong>的英文是Data Mining，缩写是<strong>DM</strong>。在商业智能BI中经常会使用到数据挖掘技术。数据挖掘的核心包括分类、聚类、预测、关联分析等任务，通过这些炼金术，我们可以从数据仓库中得到宝藏，比如<strong>商业报告</strong>。</p>
<br>

<h3 id="元数据-VS-数据元"><a href="#元数据-VS-数据元" class="headerlink" title="元数据 VS 数据元"></a>元数据 VS 数据元</h3><p>我们前面提到了数据仓库，在数据仓库中，还有一类重要的数据是元数据，那么它和数据元有什么区别呢？</p>
<p><strong>元数据</strong>（MetaData）：<strong>描述其它数据的数据</strong>，也称为“中介数据”。</p>
<p><strong>数据元</strong>（Data Element）：就是最小数据单元。</p>
<p>在生活中，只要有一类事物，就可以定义一套元数据。举个例子，比如一本图书的信息包括了书名、作者、出版社、ISBN、出版时间、页数和定价等多个属性的信息，我们就可以把这些属性定义成一套图书的元数据。</p>
<p>在图书这个元数据中，书名、作者、出版社就是数据元。你可以理解是最的数据单元。元数据最大的好处是使信息的描述和分类实现了<strong>结构化</strong>，让机器处理起来很方便。</p>
<p>元数据可以很方便地应用于数据仓库。比如数据仓库中有数据和数据之间的各种复杂关系，为了描述这些关系，元数据可以对数据仓库的数据进行定义，刻画数据的抽取和转换规则，存储与数据仓库主题有关的各种信息。而且整个数据仓库的运行都是基于元数据的，比如抽取调度数据、获取历史数据等。通过元数据，可以很方便地帮助我们管理数据仓库。</p>
<br>

<h3 id="数据挖掘的流程"><a href="#数据挖掘的流程" class="headerlink" title="数据挖掘的流程"></a>数据挖掘的流程</h3><p>数据挖掘的一个英文解释叫Knowledge Discovery in Database，简称<strong>KDD</strong>，也就是数据库中的知识发现。</p>
<p>在数据挖掘中，有几个非常重要的任务，就是分类、聚类、预测和关联分析。</p>
<ol>
<li>分类</li>
</ol>
<p>就是通过训练集得到一个分类模型，然后用这个模型可以对其他数据进行分类。</p>
<p>这里需要说明下训练集和测试集的概念。一般来说数据可以划分为训练集和测试集。训练集是用来给机器做训练的，通常是人们整理好训练数据，以及这些数据对应的分类标识。通过训练，机器就产生了自我分类的模型，然后机器就可以拿着这个分类模型，对测试集中的数据进行分类预测。同样如果测试集中，人们已经给出了测试结果，我们就可以用测试结果来做验证，从而了解分类器在测试环境下的表现。</p>
<ol start="2">
<li>聚类</li>
</ol>
<p>人以群分，物以类聚。聚类就是将数据自动聚类成几个类别，聚到一起的相似度大，不在一起的差异性大。我们往往利用聚类来做数据划分。</p>
<ol start="3">
<li>预测</li>
</ol>
<p>顾名思义，就是通过当前和历史数据来预测未来趋势，它可以更好地帮助我们识别机遇和风险。</p>
<ol start="4">
<li>关联分析</li>
</ol>
<p>就是发现数据中的关联规则，它被广泛应用在购物篮分析，或事务数据分析中。比如我们开头提到的那个案例。</p>
<p>数据挖掘要怎么完成这些任务呢？它需要将数据库中的数据经过一系列的加工计算，最终得出有用的信息。</p>
<p>这个过程可以用以下步骤来描述。</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/20.png" alt="20"></p>
<p>数据预处理中，我们会对数据进行几个处理步骤：数据清洗，数据集成，以及数据变换。</p>
<ol>
<li><strong>数据清洗</strong></li>
</ol>
<p>主要是为了去除重复数据，去噪声（即干扰数据）以及填充缺失值。</p>
<ol start="2">
<li><strong>数据集成</strong></li>
</ol>
<p>是将多个数据源中的数据存放在一个统一的数据存储中。</p>
<ol start="3">
<li><strong>数据变换</strong></li>
</ol>
<p>就是将数据转换成适合数据挖掘的形式。比如，通过归一化将属性数据按照比例缩放，这样就可以将数值落入一个特定的区间内，比如0~1之间。</p>
<p>我会在后面的几节课给你讲解如何对数据进行预处理。</p>
<p><strong>数据后处理</strong>是将模型预测的结果进一步处理后，再导出。比如在二分类问题中，一般能得到的是0~1之间的概率值，此时把数据以0.5为界限进行四舍五入就可以实现后处理。</p>
<h2 id="7-用户画像：标签化就是数据的抽象能力"><a href="#7-用户画像：标签化就是数据的抽象能力" class="headerlink" title="7. 用户画像：标签化就是数据的抽象能力"></a>7. 用户画像：标签化就是数据的抽象能力</h2><p>如果说互联网的上半场是粗狂运营，因为有流量红利不需要考虑细节。那么在下半场，精细化运营将是长久的主题。有数据，有数据分析能力才能让用户得到更好的体验。</p>
<p>用户是根本，也是数据分析的出发点。</p>
<p>假如你进入到一家卖羊肉串的餐饮公司，老板说现在竞争越来越激烈，要想做得好就要明白顾客喜欢什么。于是上班第一天，老板问你：“你能不能分析下用户数据，给咱们公司的业务做个赋能啊？”你可以这么和老板说：“老板啊，用户画像建模是个系统的工程，我们要解决三个问题。第一呢，就是<strong>用户从哪里来</strong>，这里我们需要统一标识用户ID，方便我们对用户后续行为进行跟踪。我们要了解这些羊肉串的用户从哪里来，他们是为了聚餐，还是自己吃宵夜，这些场景我们都要做统计分析。第二呢，这些<strong>用户是谁</strong>？我们需要对这些用户进行标签化，方便我们对用户行为进行理解。第三呢，就是<strong>用户要到哪里去</strong>？我们要将这些用户画像与我们的业务相关联，提升 )的转化率，或者降低我们的流失率。”</p>
<h3 id="用户画像建模"><a href="#用户画像建模" class="headerlink" title="用户画像建模"></a>用户画像建模</h3><p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/21.png" alt="21"></p>
<ol>
<li>第一步</li>
</ol>
<p><strong>用户唯一标识</strong>是整个用户画像的核心。我们以一个App为例，它把“从用户开始使用APP到下单到售后整个所有的用户行为”进行串联，这样就可以更好地去跟踪和分析一个用户的特征。</p>
<p>设计唯一标识可以从这些项中选择：用户名、注册手机号、联系人手机号、邮箱、设备号、CookielD等。</p>
<ol start="2">
<li>第二步</li>
</ol>
<p>其次，给用户打标签。标签有很多，且不同的产品，标签的选择范围也不同，这么多的标签，怎样划分才能既方便记忆，又能保证用户画像的全面性呢？</p>
<p>总结八个字，叫“用户消费行为分析”，可以从这4个维度来进行标签划分。</p>
<p><strong>用户标签</strong>：它包括了性别、年龄、地域、收入、学历、职业等。这些包括了用户的基础属性。</p>
<p><strong>消费标签</strong>：消费习惯、购买意向、是否对促销敏感。这些统计分析用户的消费习惯。</p>
<p><strong>行为标签</strong>：时间段、频次、时长、访问路径。这些是通过分析用户行为，来得到他们使用App的习惯。</p>
<p><strong>内容分析</strong>：对用户平时浏览的内容，尤其是停留时间长，浏览次数多的内容进行<strong>分析</strong>，分析出用户对哪些内容感兴趣，比如，金融、娱乐、教育、体育、时尚、科技等。</p>
<p>可以说，用户画像是现实世界中的用户的数学建模，我们正是将海量数据进行标签化，来得到精准的用户画像，从而为企业更精准地解决问题。</p>
<ol start="3">
<li>第三步</li>
</ol>
<p>最后， 当有了用户画像，可以为企业带来什么业务价值呢？</p>
<p>我们可以从用户生命周期的三个阶段来划分业务价值，包括：获客、粘客和留客。</p>
<p><strong>获客</strong>：如何进行拉新，通过更精准的营销获取客户。</p>
<p><strong>粘客</strong>：个性化推荐，搜索排序，场景运营等。</p>
<p><strong>留客</strong>：流失率预测，分析关键节点降低流失率。</p>
<br>

<p>如果按照数据流处理的阶段来划分用户画像建模的过程，可以分为数据层、算法层和业务层。你会发现在不同的层，都需要打上不同的标签。</p>
<p><strong>数据层</strong>指的是用户消费行为里的标签。我们可以打上“事实标签” ，作为数据客观的记录。</p>
<p><strong>算法层</strong>指的是透过这些行为算出的用户建模。我们可以打上“模型标签”，作为用户画像的分类标识。</p>
<p><strong>业务层</strong>指的是获客、粘客、留客的手段。我们可以打上“预测标签”，作为业务关联的结果。</p>
<p>所以这个标签化的流程，就是通过数据层的“事实标签”，在算法层进行计算，打上“模型标签”的分类结果，最后指导业务层，得出“预测标签”。</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/22.png" alt="22"></p>
<p>例；美团外卖的用户画像该如何设计？</p>
<p>刚才讲的是用户画像的三个阶段，以及每个阶段的准则。下面，我们来使用这些准则做个练习。</p>
<p>如果你是美团外卖的数据分析师，你该如何制定用户标识ID，制定用户画像，以及基于用户画像可以做哪些业务关联？</p>
<ol>
<li><p>首先，我们先回顾下美团外卖的产品背景。美团已经和大众点评进行了合并，因此在大众点评和美团外卖上都可以进行外卖下单。另外美团外卖针对的是高频O2O的场景，美团外卖是美团的核心产品，基本上有一半的市值都是由外卖撑起来的。</p>
</li>
<li></li>
</ol>
<p>基于用户画像实施的三个阶段，首先需要统一用户的唯一标识，那么究竟哪个字段可以作为用户标识呢？先看下美团和大众点评都是通过哪些方式登录的。 美团采用的是手机号、微信、微博、美团账号的登录方式。大众点评采用的是手机号、微信、 QQ、微博的登录方式。这里面两个APP共同的登录方式都是手机号、微信和微博。那么究竟哪个可以作为用户的唯一标识呢？当然主要是以用户的注册手机号为标准。 大众点评的账号体系就可以相通。</p>
<p>当然，大家知道在集团内部，各部门之间的协作，尤其是用户数据打通是非常困难的，所以这里建议，如果希望大数据对各个部门都能赋能，一定要在集团的战略高度上，尽早就在最开始的顶层架构上，将用户标识进行统一，这样在后续过程中才能实现用户数据的打通。</p>
<ol start="3">
<li><p>然后思考，有了用户，用户画像都可以统计到哪些标签。按照“用户消费行为分析”的准则来进行设计。</p>
</li>
</ol>
<p>用户标签：性别、年龄、家乡、居住地、收货地址、婚姻、宝宝信息、通过何种渠道进行的注册。</p>
<p>消费标签：餐饮口味、消费均价、团购等级、预定使用等级、排队使用等级、外卖等级。</p>
<p>行为标签：点外卖时间段、使用频次、平均点餐用时、访问路径。</p>
<p>内容分析：基于用户平时浏览的内容进行统计，包括餐饮口味、优惠敏感度等。</p>
<p>当你有了“用户消费行为分析”的标签之后，你就可以更好地理解业务了。</p>
<p>比如一个经常买沙拉的人，一般很少吃夜宵。同样，一个经常吃夜宵的人，吃小龙虾的概率可能远高于其他人。这些结果都是通过数据挖掘中的关联分析得出的。有了这些数据，我们就可以预测用户的行为。比如一个用户购买了“月子餐”后，更有可能购买婴儿水，同样婴儿相关的产品比如婴儿湿巾等的购买概率也会增大。</p>
<ol start="4">
<li><p>具体在业务层上，可以基于标签产生哪些业务价值呢？</p>
</li>
</ol>
<p>在获客上，我们可以找到优势的宣传渠道，如何通过个性化的宣传手段，吸引有潜在需求的用户，并刺激其转化。</p>
<p>在粘客上，如何提升用户的单价和消费频次，方法可以包括购买后的个性化推荐、针对优质用户进行优质高价商品的推荐、以及重复购买，比如通过红包、优惠等方式激励对优惠敏感的人群，提升购买频次。</p>
<p>在留客上，预测用户是否可能会从平台上流失。在营销领域，关于用户留存有一个观点——如果将顾客流失率降低5%，公司利润将提升25%~85%。可以看出留存率是多么的重要。用户流失可能会包括多种情况，比如用户体验、竞争对手、需求变化等，通过预测用户的流失率可以大幅降低用户留存的运营成本。</p>
<p>锻炼自己的<strong>抽象能力</strong>，将繁杂的事务简单化</p>
<p>上面我们讲到的“用户消费行为标签”都是基于一般情况考虑的，除此之外，用户的行为也会随着营销的节奏产生<strong>异常值</strong>，比如双十一的时候，如果商家都在促销就会产生突发的大量订单。因此在做用户像的时候，还要考虑到异常值的处理。</p>
<p>总之，数据量是庞大的，会存在各种各样的使用情况。光是分析EB级大数据，我们就要花很长的时间。但我们的最终目的不是处理这些数据，而是理解、使用这些数据挖掘的结果。对数据的标签化能让我们快速理解一个用户，一个商品，乃至一个视频内容的特征，从而方便我们去理解和使用数据。</p>
<p>对数据的标签化其实考验的是我们的抽象能力，在日常工作中，我们也要锻炼自己的抽象能力，它可以让我们很快地将一个繁杂的事物简单化，不仅方便理解，还有益后续的使用。</p>
<h2 id="8-数据采集"><a href="#8-数据采集" class="headerlink" title="8.数据采集"></a>8.数据采集</h2><p>从数据采集角度，把数据源分成以下四类</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/23.png" alt="23"></p>
<p>这四类数据源包括了：开放数据源、爬虫抓取、传感器和日志采集。它们各有特点。</p>
<p><strong>开放数据源</strong>一般是针对行业的数据库。比如美国人口调查局开放了美国的人口信息、地区分布和教育情况数据。除了政府外，企业和高校也会开放相应的大数据，这方面北美相对来说做得好一些。国内，贵州做了不少大胆尝试，搭建了云平台，逐年开放了旅游、交通、商务等领域的数据量。</p>
<p>要知道很多研究都是基于开放数据源进行的，否则每年不会有那么多论文发表，大家需要相同的数据集才能对比出算法的好坏。</p>
<p><strong>爬虫抓取</strong>，一般是针对特定的网站或App。如果我们想要抓取指定的 ，比如购物网站上的购物评价等，就需要我们做特定的爬虫抓取。</p>
<p>第三类数据源是<strong>传感器</strong>，它基本上采集的是物理信 图像、视频、或者某个物体的速度、热度、压强等。</p>
<p>最后是<strong>日志采集</strong>，这个是统计用户的操作。 升 可以在前端进行埋点，在后端进行脚本收集、统计，来分析网站的访问情况，以及使用瓶颈等。 </p>
<h3 id="开放数据源"><a href="#开放数据源" class="headerlink" title="开放数据源"></a>开放数据源</h3><p>开放数据源可以从两个维度来考虑，一个是单位的维度，比如政府、企业、高校；一个就是行业维度，比如交通、金融、能源等领域。这方面，国外的开放数据源比国内做得好一些，当然近些年国内的政府和高校做开放数据源的也越来越多。一方面服务社会，另一方面自己的影响力也会越来越大。</p>
<p>比如，下面这张表格列举的就是单位维度的数据源。</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/24.png" alt="24" style="zoom:60%;">

<p>所以如果想找某个领域的数据源，比如金融领域，基本上可以看下政府、高校、企业是否有开放的数据源。当然你也可以直接搜索金融开放数据源。 </p>
<h3 id="爬虫抓取"><a href="#爬虫抓取" class="headerlink" title="爬虫抓取"></a>爬虫抓取</h3><p>爬虫抓取应该属于最常见的需求，比如你想要餐厅的评价数据。当然这里要注重版权问题，而且很多网站也是有反爬机制的。</p>
<p>最直接的方法就是使用Python编写爬虫代码，当然前提是你需要会Python的基本语法。除此之外，PHP也可以做爬虫，只是功能不如Python完善，尤其是涉及到多线程的操作。</p>
<p>在<strong>Python爬虫</strong>中，基本上会经历三个过程。</p>
<ol>
<li><p>使用 Requests 爬取内容。我们可以使用 Requests库来抓取网页信息。Requests库可以说是 Python爬虫的利器，也就是Python的HTTP 库，通过这个库爬取网页中的数据，非常方便，可以帮我们节约大量的时间。</p>
</li>
<li><p>使用 XPath 解析内容。XPath 是XML Path的缩写，也就是XML 路径语言。它是一种用来确定 XML 文档中某部分位置的语言，在开发中经常用来当作小型查询语言。XPath可以通过元素和属性进行位置索引。</p>
</li>
<li><p>使用 Pandas 保存数据。Pandas 是让数据分析工作变得更加简单的高级数据结构，我们可以用 Pandas保存爬取的数据，</p>
</li>
</ol>
<p>最后通过Pandas再写入到XLS或者MySQL等数据库中。</p>
<p>Requests、XPath、Pandas是Python的三个利器。当然做Python爬虫还有很多利器，比如Selenium，PhantomJS，或者用Puppteteer这种无头模式。</p>
<p>另外我们也可以不编程就抓取到网页信息，这里介绍三款常用的抓取工具。</p>
<p><strong>火车采集器</strong></p>
<p>火车采集器已经有13年历史了，是老牌的采集工具。它不仅可以做抓取工具，也可以做数据清洗、数据分析、数据挖掘和可视化等工作。数据源适用于绝大部分的网页，网页中能看到的内容都可以通过采集规则进行抓取。</p>
<p><strong>八爪鱼</strong></p>
<p>八爪鱼也是知名的采集工具，它有两个版本，一个就是免费的采集模板，还有一个就是云采集（付费）。</p>
<p>免费的采集模板实际上就是内容采集规则，包括了电商类、生活服务类、 社 和论坛类的网站都可以采集，用起来非常方便。当然你也可以自己来自定义任务。</p>
<p>那什么是云采集呢？就是当你配置好采集任务，就可以交给八爪鱼的云端进行采集。八爪鱼一共有5000台服务器，通过云端多节点并发采集，采集速度远远超过本地采集，此外还可以自动切换多个IP，避免IP被封，影响采集。</p>
<p>做过工程项目的同学应该能体会到，云采集这个功能太方便了，很多时候自动切换IP以及云采集才是自动化采集的关键。</p>
<p><strong>集搜客</strong></p>
<p>这个工具的特点是完全可视化操作，无需编程。整个采集过程也是所见即所得，抓取结果信息、错误信息等都反应在软件中。相比于八爪鱼来说，集搜客没有流程的概念，用户只需要关注抓取什么数据，而流程细节完全交给集搜客来处理。</p>
<p>但是集搜客的缺点是没有云采集功能，所有爬虫都是在用户自己电脑上跑的。</p>
<h3 id="日志采集工具"><a href="#日志采集工具" class="headerlink" title="日志采集工具"></a>日志采集工具</h3><p>日志采集最大的作用，就是通过分析用户访问情况，提升系统的性能，从而提高系统承载量。及时发现系统承载瓶颈，也可以方便技术人员基于用户实际的访问情况进行优化。日志采集也是运维人员的重要工作之一。</p>
<p>日志就是日记的意思，它记录了用户访问网站的全过程：哪些人在什么时间，通过什么渠道（比如搜索引擎、网址输入）来过，都执行了哪些操作；系统是否产生了错误；甚至包括用户的IP、HTTP请求的时间，用户代理等。这些日志数据可以被写在一个日志文件中，也可以分成不同的日志文件，比如访问日志、错误日志等。</p>
<p>日志采集可以分两种形式。</p>
<ol>
<li><p>通过Web服务器采集，例如 httpd、Nginx、Tomcat 都自带日志记录功能。同时很多互联网企业都有自己的海量数据采集工具，多用于系统日志采集，如Hadoop的Chukwa、Cloudera的Flume、Facebook的Scril 这些工具均采用分布式架构，能够满足每秒数百MB的日志数据采集和传输需求。 </p>
</li>
<li><p>自定义采集用户行为，例如用JavaScript代码监听用户的行为、AJAX异步请求后台记录日志等。</p>
</li>
</ol>
<p><strong>埋点</strong></p>
<p>埋点是日志采集的关键步骤。埋点就是在有需要的位置采集相应的信息，进行上报。比如某页面的访问情况，包括用户信息、设备信息；或者用户在页面上的操作行为，包括时间长短等。这就是埋点，每一个埋点就像一台摄像头，采集用户行为数据，将数据进行多维度的交叉分析，可真实还原出用户使用场景，和用户使用需求。</p>
<p>如何进行埋点：</p>
<p>埋点就是在你需要统计数据的地方植入统计代码，当然植入代码可以自己写，也可以使用第三方统计工具。按照“不重复造轮子”的原则，一般来说需要自己写的代码，一般是主营核心业务，对于埋点这类监测性的工具，市场上已经比较成熟，这里推荐使用第三方的工具，比如友盟、GoogleAnalysis、Talkingdata等。他们都是采用前端埋点的方式，然后在第三方工具里就可以看到用户的行为数据。但如果我们想要看到更深层的用户操作行为，就需要进行自定义埋点。</p>
<p>总结一下，日志采集有助于我们了解用户的操作数据，适用于运维监控、安全审计、业务数据分析等场景。一般Web服务器会自带日志功能，也可以使用Flume从不同的服务器集群中采集、汇总和传输大容量的日志数据。当然我们也可以使用第三方的统计工具或自定义埋点得到自己想要的统计内容。</p>
<p>总结</p>
<p>数据采集是数据分析的关键，很多时候我们会想到Python网络爬虫，实际上数据采集的方法、渠道很广，有些可以直接使用开放的数据源，比如想获取比特币历史的价格及交易数据，可以直接从Kaggle上下载，不需要自己爬取。另一方面根据我们的需求，需要采集的数据也不同，比如交通行业，数据采集会和摄像头或者测速仪有关。对于运维人员，日志采集和分析则是关键。所以我们需要针对特定的业务场景，选择适合的采集工具。</p>
<h2 id="9-数据采集：使用八爪鱼采集微博上的D-amp-G评论"><a href="#9-数据采集：使用八爪鱼采集微博上的D-amp-G评论" class="headerlink" title="9.数据采集：使用八爪鱼采集微博上的D&amp;G评论"></a>9.数据采集：使用八爪鱼采集微博上的D&amp;G评论</h2><p>（八爪鱼，竟然没有mac版）</p>
<h2 id="10-Python爬虫"><a href="#10-Python爬虫" class="headerlink" title="10.Python爬虫"></a>10.Python爬虫</h2><h2 id="11-数据清洗"><a href="#11-数据清洗" class="headerlink" title="11.数据清洗"></a>11.数据清洗</h2><p>整个数据分析过程中，不管时间还是功夫，数据清洗都占到了80%</p>
<h3 id="数据清洗规则"><a href="#数据清洗规则" class="headerlink" title="数据清洗规则"></a>数据清洗规则</h3><p><strong>完整性</strong>：单条数据是否存在<strong>空值</strong>，统计的字段是否<strong>完善</strong>。</p>
<p><strong>全面性</strong>：观察某一<strong><em>列</em></strong>的<strong>全部数值</strong>，比如在Excel表中，我们选中一列，可以看到该列的<strong>平均值、最大值、最小值</strong>。我们可以通过<strong>常识</strong>来判断该列是否有问题，比如：<strong>数据定义</strong>、<strong>单位标识</strong>、<strong>数值本身</strong>、<strong>列名</strong>。</p>
<p><strong>合法性</strong>：<strong><em>数据</em></strong>的类型、内容、大小的合法性。比如数据中存在非ASCII字符，性别存在了未知，年龄超过了150岁等。</p>
<p><strong>唯一性</strong>：数据是否存在<strong>重复</strong>记录，因为数据通常来自不同渠道的汇总，重复的情况是常见的。行数据、列数据都需要是唯一的，比如一个人不能重复记录多次，且一个人的体重也不能在列指标中重复记录多次。</p>
<p>按照以上的原则，我们能解决数据清理中遇到的大部分问题，使得数据标准、干净、连续，为后续数据统计、数据挖掘做好准备。如果想要进一步优化数据质量，还需要在实际案例中灵活使用。</p>
<h3 id="Pandas举例"><a href="#Pandas举例" class="headerlink" title="Pandas举例"></a>Pandas举例</h3><p>以Pandas为例，如图数据表为例，应用数据清洗准则，给出可能遇到的问题中的一些举例。</p>
<p>（部分参数详细用法见前面Pandas章节）</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/26.png" alt="26"></p>
<ol>
<li>完整性</li>
</ol>
<ul>
<li>问题1：<strong>缺失值</strong></li>
</ul>
<p>在数据中有些年龄、体重数值是缺失的，这往往是因为数据量较大，在过程中，有些数值没有采集到。通常我们可以采用以下三种方法：</p>
<p><strong>删除</strong>：删除数据缺失的记录；</p>
<p><strong>均值</strong>：使用当前列的均值；</p>
<p><strong>高频</strong>：使用当前列出现频率最高的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 均值</span></span><br><span class="line">df[<span class="string">'Age'</span>].fillna(df[<span class="string">'Age'</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高频</span></span><br><span class="line">age_max = df[<span class="string">'Age'</span>].value_counts().index[<span class="number">0</span>]</span><br><span class="line">df[<span class="string">'Age'</span>].fillna(age_max, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>问题2：<strong>空行/列</strong></li>
</ul>
<p>我们发现数据中有一个空行，除了index之外，全部的值都是NaN，Pandas的read_csv并没有可选参数来忽略空行，这样，我们就需要在数据被读入之后再使用 dropna()进行处理，删除空行。</p>
<br>

<ol start="2">
<li>全面性</li>
</ol>
<ul>
<li>问题1：没有<strong>列头</strong></li>
</ul>
<p>可以使用read_csv()的names参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加列头</span></span><br><span class="line">column_names= [<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'weight'</span>,<span class="string">'m0006'</span>,<span class="string">'m0612'</span>,<span class="string">'m1218'</span>,<span class="string">'f0006'</span>,<span class="string">'f0612'</span>,<span class="string">'f1218'</span>]</span><br><span class="line">df = pd.read_csv(<span class="string">'../data/patient_heart_rate.csv'</span>, names = column_names)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>

<ul>
<li>问题2：列数据的<strong>单位</strong>不统一</li>
</ul>
<p>weight列的单位不统一，有的单位是千克（kgs），有的单位是磅（Ibs）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 weight 数据列中单位为 lbs 的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rows_with_lbs得到的是bool Series，包含lbs为true，否则false</span></span><br><span class="line">rows_with_lbs = df[<span class="string">'weight'</span>].str.contains(<span class="string">'lbs'</span>)</span><br><span class="line">df[rows_with_lbs]</span><br></pre></td></tr></table></figure>

<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/29.png" alt="29"></p>
<p>这里我使用千克作为统一的度量单位，将磅（Ibs）转化为千克（kgs）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 lbs 的数据转换为 kgs 数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> i,lbs_row <span class="keyword">in</span> df[rows_with_lbs].iterrows():</span><br><span class="line">  <span class="comment"># i每次循环分别是1、4、5、9</span></span><br><span class="line">  <span class="comment"># lbs_row是每个i的列名-value</span></span><br><span class="line">  <span class="comment"># 字符串转float，计算后转int</span></span><br><span class="line">	weight = int(float(lbs_row[<span class="string">'weight'</span>][:<span class="number">-3</span>])/<span class="number">2.2</span>)</span><br><span class="line">  <span class="comment"># 拼接、赋值</span></span><br><span class="line">	df.at[i,<span class="string">'weight'</span>] = <span class="string">'&#123;&#125;kgs'</span>.format(weight)</span><br></pre></td></tr></table></figure>

<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/30.png" alt="30"></p>
<ul>
<li>问题3：一列有多个参数</li>
</ul>
<p>Name 列包含了两个参数 Firtname 和 Lastname</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切分名字，删除源数据列</span></span><br><span class="line">df[[<span class="string">'first_name'</span>,<span class="string">'last_name'</span>]] = df[<span class="string">'name'</span>].str.split(expand=<span class="literal">True</span>)</span><br><span class="line">df.drop(<span class="string">'name'</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>例1：规范化<strong>数据类型</strong></li>
</ul>
<p>read_csv()的dtype参数</p>
<ul>
<li>例2：<strong>大小写</strong>不统一、删除<strong>额外空格</strong></li>
</ul>
<p>data[‘’].str.upper()<br>data[‘’].str.strip()</p>
<ul>
<li>例3：<strong>重命名</strong>列名</li>
</ul>
<p>rename()</p>
<br>

<ol start="3">
<li>合理性</li>
</ol>
<p>问题1：<strong>非ASCII字符</strong></p>
<p>在数据集中 Fristname 和 Lastname 有一些非 ASCII ，可以删除、替换、或者仅仅提示一下</p>
<p>这里使用删除方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除非 ASCII 字符</span></span><br><span class="line">df[<span class="string">'first_name'</span>].replace(&#123;<span class="string">r'[^\x00-\x7F]+'</span>:<span class="string">''</span>&#125;, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">'last_name'</span>].replace(&#123;<span class="string">r'[^\x00-\x7F]+'</span>:<span class="string">''</span>&#125;, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>唯一性</li>
</ol>
<p>问题1：重复数据</p>
<p>我们校验一下数据中是否存在重复记录。如果存在重复记录，就使用 Pandas 提供的 drop_duplicates(）来删除重复数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除重复数据行</span></span><br><span class="line">df.drop_duplicates([<span class="string">'first_name'</span>,<span class="string">'last_name'</span>],inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="12-数据集成"><a href="#12-数据集成" class="headerlink" title="12.数据集成"></a>12.数据集成</h2><p>我们采集的数据经常会有冗余重复的情况。举个简单的例子，假设你是一个网络综艺节目的制片人，一共有12期节目，你一共打算邀请30位明星作为节目的嘉宾。你知道这些明星影响力都很大，具体在微博上的粉丝数都有标记。于是你想统计下，这些明星一共能直接影响到微博上的多少粉丝，能产生多大的影响力。</p>
<p>然后你突然发现，这些明星的粉丝数总和超过了20亿。那么他们一共会影响到中国20亿人口么？显然不是的，那么如何统计这30位明星真实的影响力总和呢？这里就需要用到数据集成的概念了。</p>
<br>

<p><strong>数据集成</strong>就是将多个数据源合并存放在一个数据存储中（如数据仓库），从而方便后续的数据挖掘工作。</p>
<p>据统计，大数据项目中80%的工作都和数据集成有关，这里的数据集成有更广泛的意义，包括了数据清洗、数据抽取、数据集成和数据变换等操作。这是因为数据挖掘前，我们需要的数据往往分布在不同的数据源中，需要考虑字段表达是否一样，以及属性是否冗余。</p>
<h3 id="数据集成的两种架构：ELT和ETL"><a href="#数据集成的两种架构：ELT和ETL" class="headerlink" title="数据集成的两种架构：ELT和ETL"></a>数据集成的<strong>两种架构</strong>：ELT和ETL</h3><p><strong>ETL</strong>：Extract、Transform和Load的缩写，顾名思义它包括了数据抽取、转换、加载三个过程。ETL可以说是进行数据挖掘这项工作前的“备菜”过程。</p>
<p><strong>抽取</strong>：将数据从已有的数据源中提取出来。</p>
<p><strong>转换</strong>：对原始数据进行处理，例如将表输入1和表输入2进行连接形成一张新的表。</p>
<p>根据转换发生的顺序和位置，数据集成可以分为ETL和ELT两种架构。</p>
<p>ETL 的过程为提取（Extract)- -转换(Transform)— -加载(Load)，在数据源抽取后首先进行转换，然后将转换的结果写入目的地。</p>
<p><strong>ELT</strong> 的过程则是提取(Extract)——加载(Load)——变换(Transform)，在抽取后将结果先写入目的地，然后利用数据库的聚合分析能力或者外部计算框架，如Spark来完成转换的步骤。</p>
<p>目前数据集成的主流架构是ETL，但未来使用ELT作为数据集成架构的将越来越多。这样做会带来多种好处：</p>
<ol>
<li><p>ELT 和 ETL 相比，最大的区别是“重抽取和加载，轻转换”，从而可以用更轻量的方案搭建起一个数据集成平台。使用ELT方法，在提取完成之后，数据加载会立即开始。一方面更省时，另一方面ELT允许BI分析人员无限制地访问整个原始数据，为分析师提供了更大的灵活性，使之能更好地支持业务。</p>
</li>
<li><p>在ELT架构中，数据变换这个过程根据后续使用的情况，需要在 SQL中进行，而不是在加载阶段进行。这样做的好处是你可以从数据源中提取数据，经过少量预处理后进行加载。这样的架构更简单，使分析人员更好地了解原始数据的变换过程。</p>
</li>
</ol>
<h3 id="ETL工具"><a href="#ETL工具" class="headerlink" title="ETL工具"></a>ETL工具</h3><p>典型的ETL工具有：</p>
<p>商业软件：Informatica PowerCenter、IBM InfoSphere DataStage、Oracle Data Integrator、Microsoft SQL Server、Integration Services等</p>
<p>开源软件：Kettle、Talend、Apatar、Scriptella、DataX、Sqoop等</p>
<p>相对于传统的商业软件，<strong>Kettle</strong>是一个易于使用的，低成本的解决方案。国内很多公司都在使用Kettle用来做数据集成。</p>
<p>Kettle工具的使用</p>
<p>Kettle是一款国外开源的ETL工具，纯Java编写，可以在Window和Linux上运行，不需要安装就可以使用。Kettle 中文名称叫水壶，该项目的目标是将各种数据放到一个壶里，然后以一种指定的格式流出。</p>
<p>Kettle的控件比较多，一个Kettle的开源社区：<a href="http://www.ukettle.org" target="_blank" rel="noopener">http://www.ukettle.org</a>.</p>
<p>Kettle相比其他工具上手简单，而且是开源工具，有问题可以在社群里咨询。因此推荐使用Kettle作为你的第一个ETL工具。</p>
<p>当然除了Kettle工具，实际工作中，你可能也会接触到其他的ETL工具，比如阿里巴巴的开源工具DataX和Apache的Sqoop.</p>
<p>（具体这几个工具的使用待学习）</p>
<h2 id="13-数据变换"><a href="#13-数据变换" class="headerlink" title="13.数据变换"></a>13.数据变换</h2><p>考试成绩基本上都会满足正态分布的情况。为了让成绩符合正态分布，出题老师通常可以把考题分成三类：第一类：基础题，占总分70%，基本上属于送分题；第二类：灵活题，基础范围内+一定的灵活性，占20%；第三类：难题，涉及知识面较广的难题，占10%。如果一个出题老师没有按照上面的标准来出题，而是将第三类难题比重占到了70%，也就是“超纲”，结果会是大部分人成绩都“不及格” ，最后在大家激烈的讨论声中，老师会将考试成绩做规范化处理，从而让成绩满足正态分布的情况。</p>
<p>再举个例子，假设A考了80分，B也考了80分，但前者是百分制，后者500分是满分，如果我们把从这两个渠道收集上来的数据进行集成、挖掘，就算使用效率再高的算法，结果也不是正确的。因为这两个渠道的分数代表的含义完全不同。</p>
<p>所以说，有时候数据变换比算法选择更重要，数据错了，算法再正确也是错的。</p>
<br>

<p>如何让不同渠道的数据统一到一个目标数据库里呢？这样就用到了<strong>数据变换</strong>。</p>
<p>在数据变换前，我们需要先对字段进行筛选，然后对数据进行探索和相关性分析，接着是选择算法模型（这里暂时不需要进行模型计算），然后针对算法模型对数据的需求进行数据变换，从而完成数据挖掘前的准备工作。</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/31.png" alt="31"></p>
<p>所以你从整个流程中可以看出，数据变换是数据准备的重要环节，它通过数据平滑、数据聚集、数据概化和规范化等方式将数据转换成适用于数据挖掘的形式。</p>
<h3 id="常见的变换方法"><a href="#常见的变换方法" class="headerlink" title="常见的变换方法"></a>常见的变换方法</h3><p><strong>数据平滑</strong>：去除数据中的噪声，将离散数据连续化。这里可以采用<strong>分箱、聚类和回归</strong>的方式进行数据平滑。（后面会有聚类和回归这两个算法）</p>
<p><strong>数据聚集</strong>：对数据进行汇总，在SQL中有一些<strong>聚集</strong>函数可以供我们操作，比如Max()反馈某个字段的数值最大值，Sum()返回某个字段的数值总和；</p>
<p><strong>数据概化</strong>：将数据由较低的概念<strong>抽象</strong>成为较高的概念，减少数据复杂度，即用更高的概念替代更低的概念。比如说上海、杭州、深圳、北京可以概化为中国。</p>
<p><strong>数据规范化</strong>：使属性数据按比例<strong>缩放</strong>，这样就将原来的数值映射到一个新的特定区域中。常用的方法有最小一最大规范化、Z—score 规范化、按小数定标规范化等。（后面会有这些方法的使用）</p>
<p><strong>属性构造</strong>：构造出新的属性并添加到属性集中。这里会用到特征工程的知识，因为通过属性与属性的连接构造新的属性，其实就是特征工程。比如说，数据表中统计每个人的英语、语文和数学成绩，可以构造“总和”这个属性，来作为新属性，用到后续的数据挖掘计算中。</p>
<p>在这些变换方法中，最简单易用的就是对数据进行规范化处理。下面我来给你讲下如何对数据进行规范化处理。</p>
<h3 id="数据规范化的几种方法"><a href="#数据规范化的几种方法" class="headerlink" title="数据规范化的几种方法"></a>数据规范化的几种方法</h3><ol>
<li><strong>Min-max规范化</strong></li>
</ol>
<p>Min-max规范化方法是将原始数据变换到<strong>[0,1]</strong>的空间中。公式：</p>
<blockquote>
<p>新数值=（原数值-极小值）/（极大值-极小值）。</p>
</blockquote>
<ol start="2">
<li><strong>Z-Score 规范化</strong></li>
</ol>
<p>假设A与B的考试成绩都为80分，A的考卷满分是100分（及格60分），B的考卷满分是500分（及格300分）。虽然两个人都考了80分，但是A的80分与B的80分代表完全不同的含义。</p>
<p>Z-Score就是用来可以解决这一问题的。公式：</p>
<blockquote>
<p>新数值=（原数值-均值）/标准差。</p>
</blockquote>
<p>假设A所在的班级平均分为80，标准差为10。B所在的班级平均分为400，标准差为100。那么A的新数值=(80-80)/10=0，B的新数值=(80-400)/100=-3.2。那么在Z-Score标准下，A的成绩会比B的成绩好。</p>
<p>我们能看到Z-Score的优点是算法简单，不受数据量级影响，结果易于比较。不足在于，它需要数据整体的平均值和方差，而且结果没有实际意义，只是用于<strong>比较</strong>。</p>
<ol start="3">
<li><strong>小数定标规范化</strong></li>
</ol>
<p>小数定标规范化就是通过移动小数点的位置来进行规范化。小数点移动多少位，取决于属性A的取值中的<strong>最大绝对值</strong>。</p>
<p>举个例子，比如属性A的取值范围是-999到88，那么最大绝对值为999，小数点就会移动3位，即新数值=原数值/1000。那么A的取值范围就被规范化为-0.999到0.088。</p>
<br>

<h3 id="Python的SciKit-Learn库使用"><a href="#Python的SciKit-Learn库使用" class="headerlink" title="Python的SciKit-Learn库使用"></a>Python的SciKit-Learn库使用</h3><p>SciKit-Learn是Python的童要机器学习库，它帮我们<strong>封装了大量的机器学习算法</strong>，比如分类、聚类、回归、降维等。此外，它还包括了数据变换模块。我现在来讲下如何使用SciKit-Learn进行数据规范化。</p>
<ol>
<li><strong>Min-max 规范化</strong></li>
</ol>
<p>SciKit-Learn库中</p>
<p><strong>preprocessing.MinMaxScaler()</strong>：给定参数一个最大值与最小值，feature_range=（min,max），然后将原数据投射到[min, max]中。默认情况下[min,max]是[0,1]，也就是把原始数据投放到[0,1]范围内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据，每一行表示一个样本，每一列表示一个特征</span></span><br><span class="line">x = np.array([[ <span class="number">0.</span>, <span class="number">-3.</span>,  <span class="number">1.</span>],</span><br><span class="line">              [ <span class="number">3.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据进行[0,1]规范化</span></span><br><span class="line">minmax_x = preprocessing.MinMaxScaler().fit_transform(x)</span><br><span class="line"><span class="keyword">print</span> (minmax_x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [2,3]</span></span><br><span class="line">minmax_x = preprocessing.MinMaxScaler(feature_range=(<span class="number">2</span>, <span class="number">3</span>)).fit_transform(x)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0.         0.         0.66666667]</span><br><span class="line"> [1.         1.         1.        ]</span><br><span class="line"> [0.         1.         0.        ]]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>z-Score规范化</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据进行Z-Score规范化</span></span><br><span class="line">scaled_x = preprocessing.scale(x)</span><br><span class="line"><span class="keyword">print</span> (scaled_x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">ss = StandardScaler()</span><br><span class="line">scaled_x = ss.fit_transform(x)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[-0.70710678 -1.41421356  0.26726124]</span><br><span class="line"> [ 1.41421356  0.70710678  1.06904497]</span><br><span class="line"> [-0.70710678  0.70710678 -1.33630621]]</span><br></pre></td></tr></table></figure>

<p>这个结果实际上就是将每行每列的值减去了平均值，再除以方差的结果。</p>
<p>我们看到Z-Score规范化将数据集进行了规范化，数值都符合均值为0，方差为1的正态分布。</p>
<ol start="3">
<li><strong>小数定标规范化</strong></li>
</ol>
<p>需要用NumPy库来计算小数点的位数。</p>
<p>这里我们看下运行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小数定标规范化</span></span><br><span class="line"><span class="comment"># max(abs(x)）得最大绝对值，log10后 ceil 向上取整，得到位数，**为python取幂</span></span><br><span class="line">j = np.ceil(np.log10(np.max(abs(x))))</span><br><span class="line">scaled_x = x/(<span class="number">10</span>**j)</span><br><span class="line"><span class="keyword">print</span> (scaled_x)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 0.  -0.3  0.1]</span><br><span class="line"> [ 0.3  0.1  0.2]</span><br><span class="line"> [ 0.   0.1 -0.1]]</span><br></pre></td></tr></table></figure>

<h2 id="14-数据可视化"><a href="#14-数据可视化" class="headerlink" title="14.数据可视化"></a>14.数据可视化</h2><p>常用的可视化视图超过 20 种，分别包括：文本表、热力图、地图、符号地图、饼图、水平条、堆叠条、并排条、树状图、圆视图、并排圆、线、双线、面积图、双组合、散点图、直方图、盒须图、甘特图、靶心图、气泡图等。</p>
<p><strong>数据可视化的工具</strong>：</p>
<p>商业智能分析：Tableau 和、PowerBI、FineBI</p>
<p>可视化大屏类：DataV 和 FineReport</p>
<p>前端可视化组件：Canvas、SVG 和 WebGL，Echarts、D3、Three.js 和 AntV</p>
<p>编程语言：Python （<strong><em>Matplotlib</em></strong>、<strong>Seaborn</strong>、Bokeh、Plotly、Pyecharts、Mapbox 和 Geoplotlib）， R （自带的绘图包 Graphics 以及工具包ggplot2、ggmap、timevis 和 plotly ）</p>
<p><img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/51.png" alt="51"></p>
<h2 id="15-Python数据可视化的10种技能"><a href="#15-Python数据可视化的10种技能" class="headerlink" title="15.Python数据可视化的10种技能"></a>15.Python数据可视化的10种技能</h2><p>如果想要用Python进行数据分析，就需要在项目初期开始进行探索性的数据分析，这样方便对数据有一定的了解。其中最直观的就是采用数据可视化技术，这样，数据不仅一目了然，而且更容易被解读。同样在数据分析得到结果之后，我们还需要用到可视化技术，把最终的结果呈现出来。</p>
<h3 id="可视化视图有哪些"><a href="#可视化视图有哪些" class="headerlink" title="可视化视图有哪些"></a>可视化视图有哪些</h3><p>按照数据之间的关系，我们可以把可视化视图划分为4类，它们分别是比较、联系、构成和分布：</p>
<ul>
<li><p><strong>比较</strong>：比较数据间各类别的关系，或者是它们随着时间的变化趋势，比如折线图；</p>
</li>
<li><p><strong>联系</strong>：查看两个或两个以上变量之间的关系，比如散点图；</p>
</li>
<li><p><strong>构成</strong>：每个部分占整体的百分比，或者是随着时间的百分比变化，比如饼图；</p>
</li>
<li><p><strong>分布</strong>：关注单个变量，或者多个变量的分布情况，比如直方图。</p>
</li>
</ul>
<p>按照变量的个数，我们可以把可视化视图划分为单变量分析和多变量分析。</p>
<ul>
<li><p><strong>单变量分析</strong>：一次只关注一个变量</p>
</li>
<li><p><strong>多变量分析</strong>：一张图上可以查看两个以上变量的关系。从而分析出变量之间是否存在某种联系。</p>
</li>
</ul>
<p>可视化的视图可以说是分门别类，多种多样，介绍常用的10种视图，这些视图包括了散点图、折线图、直方图、条形图、箱线图、饼图、热力图、蜘蛛图、二元变量分布和成对关系。</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/32.png" alt="32" style="zoom: 50%;">

<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p>散点图的英文叫做scatter plot，它将两个变量的值显示在二维坐标中，非常适合展示两个变量之间的关系。当然，除了二维的散点图，我们还有三维的散点图。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Matplotlib工具</td>
<td></td>
</tr>
<tr>
<td><strong>pyplot</strong></td>
<td>它包括了很多绘图函数，类似Matlab的绘图框架</td>
</tr>
<tr>
<td></td>
<td>import matplotlib.pyplot as plt</td>
</tr>
<tr>
<td>plt.scatter()</td>
<td>(x, y, marker=None)<br>x、y 是坐标，marker代表了标记的符号。比如“x”、“&gt;”或者“o”。选择不同的marker，呈现出来的符号样式也会不同</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Seaborn</strong>工具</td>
<td></td>
</tr>
<tr>
<td></td>
<td>import seaborn as sns</td>
</tr>
<tr>
<td>sns.jointplot()</td>
<td>(x, y, data=None, kind=‘scatter’)<br>x、y是data中的下标。data就是我们要传入的数据，一般是DataFrame类型。kind这类我们取scatter，代表散点的意思。当然kind还可以取其他值</td>
</tr>
</tbody></table>
<p>好了，让我们来模拟下，假设我们的数据是随机的1000个点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line">x = np.random.randn(N)</span><br><span class="line">y = np.random.randn(N)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Matplotlib画散点图</span></span><br><span class="line">plt.scatter(x, y,marker=<span class="string">'x'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Seaborn画散点图</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y&#125;)</span><br><span class="line">sns.jointplot(x=<span class="string">"x"</span>, y=<span class="string">"y"</span>, data=df, kind=<span class="string">'scatter'</span>);</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>Matplotlib和Seaborn的视图呈现还是有差别的。Matplotlib默认情况下呈现出来的是个长方形。而Seaborn呈现的是个正方形，而且不仅显示出了散点图，还给了这两个变量的分布情况。</p>
<p>Matplotlib绘制：</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/33.png" alt="33" style="zoom:50%;">

<p>Seaborn绘制：</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/34.png" alt="34" style="zoom:50%;">

<h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><p>折线图可以用来表示数据随着时间变化的趋势。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Matplotlib</td>
<td></td>
</tr>
<tr>
<td>plt.plot()</td>
<td>需要提前把数据按照x轴的大小进行排序，要不画出来的折线图就无法按照x轴递增的顺序展示</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Seaborn</td>
<td></td>
</tr>
<tr>
<td>sns.lineplot()</td>
<td>(x, y, data=None)<br>x、y是data中的下标。data就是我们要传入的数据，一般是DataFrame类型。</td>
</tr>
</tbody></table>
<p>这里我们设置了x、y的数组。x数组代表时间（年），y数组随便设置几个取值。下面是详细的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">x = [<span class="number">2010</span>, <span class="number">2011</span>, <span class="number">2012</span>, <span class="number">2013</span>, <span class="number">2014</span>, <span class="number">2015</span>, <span class="number">2016</span>, <span class="number">2017</span>, <span class="number">2018</span>, <span class="number">2019</span>]</span><br><span class="line">y = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">35</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Matplotlib画折线图</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Seaborn画折线图</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'x'</span>: x, <span class="string">'y'</span>: y&#125;)</span><br><span class="line">sns.lineplot(x=<span class="string">"x"</span>, y=<span class="string">"y"</span>, data=df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>这两个图示的结果是完全一样的，只是在seaborn中标记了x和y轴的含义。</p>
<p>Matplotlib绘制：</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/35.png" alt="35" style="zoom:50%;">

<p>Seaborn绘制：</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/36.png" alt="36" style="zoom:50%;">

<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>直方图是比较常见的视图，它是把横坐标等分成了一定数量的小区间，这个小区间也叫作“箱子”，然后在每个“箱子”内用矩形条（bars）展示该箱子的箱子数（也就是y值），这样就完成了对数据集的直方图<strong>分布</strong>的可视化</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Matplotlib</td>
<td></td>
</tr>
<tr>
<td>plt.hist()</td>
<td>(x, bins=10)<br>x是一维数组，bins代表直方图中的箱子数量，默认是10<br>直方图纵坐标为区间内分布个数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Seaborn</td>
<td></td>
</tr>
<tr>
<td>sns.distplot()</td>
<td>(x, bins=10, kde=True)<br>x是一维数组<br>bins：直方图中的箱子数量<br>kde：显示核密度估计，默认是True，我们也可以把kde设置为False，不进行显示。显示kde时，直方图高度显示默认为密度（且不能更改），kde为False时，默认高度显示为计数（可更改）<br>hist：是否显示直方图，默认True<br>norm_hist：若为True, 则直方图高度显示密度而非计数<br>rag：控制是否生成观测数值的小细条<br>fit：控制拟合的参数分布图形，能够直观地评估它与观察数据的对应关系(黑色线条为确定的分布)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">a = np.random.randn(<span class="number">100</span>)</span><br><span class="line">s = pd.Series(a) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Matplotlib画直方图</span></span><br><span class="line">plt.hist(s)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Seaborn画直方图</span></span><br><span class="line">sns.distplot(s, bins=<span class="number">10</span>, kde=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>Matplotlib绘制：</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/37.png" alt="37" style="zoom:50%;">

<p>Seaborn绘制：</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/38.png" alt="38" style="zoom:50%;">

<h4 id="核密度估计图"><a href="#核密度估计图" class="headerlink" title="核密度估计图"></a>核密度估计图</h4><table>
<thead>
<tr>
<th>工具</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Seaborn</td>
<td></td>
</tr>
<tr>
<td>sns.kdeplot()</td>
<td>(x,cumulative=)</td>
</tr>
<tr>
<td></td>
<td>cumulative ：是否绘制累积分布，默认false<br>shade：若为True，则在kde曲线下面的区域中进行阴影处理，默认false<br>color：控制曲线及阴影的颜色<br>vertical：表示以X轴进行绘制还是以Y轴进行绘制，默认False，x轴</td>
</tr>
<tr>
<td></td>
<td>(x,y,  )</td>
</tr>
<tr>
<td></td>
<td>二元<br>cbar：参数若为True，则会添加一个颜色棒，默认False(颜色帮在二元kde图像中才有)</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=np.random.randn(<span class="number">100</span>)  <span class="comment">#随机生成100个符合正态分布的数</span></span><br><span class="line"></span><br><span class="line">sns.kdeplot(x)</span><br><span class="line"><span class="comment"># sns.kdeplot(x,cumulative=True)</span></span><br><span class="line">sns.kdeplot(x,shade=<span class="literal">True</span>,color=<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line">y=np.random.randn(<span class="number">100</span>)</span><br><span class="line">sns.kdeplot(x,y,shade=<span class="literal">True</span>,cbar=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/39.png" alt="39" style="zoom:50%;">

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/40.png" alt="40" style="zoom:50%;">

<h4 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h4><p>如果说通过直方图可以看到变量的数值分布，那么条形图可以帮我们查看类别的特征。</p>
<p>在条形图中，长条形的长度表示类别的频数，宽度表示类别。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Matplotlib</td>
<td></td>
</tr>
<tr>
<td>plt.bar()</td>
<td>(x, height)<br>函数，其中参数x代表x轴的位置序列，height是y轴的数值序列，也就是柱子的高度。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Seaborn</td>
<td></td>
</tr>
<tr>
<td>sns.barplot()</td>
<td>(x=None, y=None, data=None)<br>data为DataFrame类型，x、y是data中的变量。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">x = [<span class="string">'Cat1'</span>, <span class="string">'Cat2'</span>, <span class="string">'Cat3'</span>, <span class="string">'Cat4'</span>, <span class="string">'Cat5'</span>]</span><br><span class="line">y = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>]</span><br><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Matplotlib画条形图</span></span><br><span class="line">axes[<span class="number">0</span>].bar(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Seaborn画条形图</span></span><br><span class="line">sns.barplot(x, y, ax=axes[<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/42.png" alt="42" style="zoom:50%;">

<h4 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h4><p>箱线图，又称盒式图，它是在1977年提出的，由五个数值点组成：<strong>最大值(max)、最小值(min)、中位数(median)和上下四分位数(Q3, Q1)</strong>。它可以帮我们分析出数据的差异性、离散程度和异常值等。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Matplotlib</td>
<td></td>
</tr>
<tr>
<td>plt.boxplot()</td>
<td>(x, labels=None)<br>x：要绘制箱线图的数据<br>labels：缺省值，可以为箱线图添加标签。(标签类似于列名)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Seaborn</td>
<td></td>
</tr>
<tr>
<td>sns.boxplot()</td>
<td>(x=None, y=None, data=None)<br>data为DataFrame类型<br>x、y是data中的变量。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line"><span class="comment"># 生成0-1之间的10*4维度数据(每一维度10个数，四个维度)</span></span><br><span class="line">data=np.random.normal(size=(<span class="number">10</span>,<span class="number">4</span>)) </span><br><span class="line">lables = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>]</span><br><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Matplotlib画箱线图</span></span><br><span class="line">axes[<span class="number">0</span>].boxplot(data,labels=lables)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Seaborn画箱线图</span></span><br><span class="line">df = pd.DataFrame(data, columns=lables)</span><br><span class="line">sns.boxplot(data=df, ax=axes[<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/43.png" alt="43" style="zoom:50%;">

<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>饼图是常用的统计学模块，可以显示每个部分大小与总和之间的比例。在Python数据可视化中，它用的不算多。我们主要采用Matplotlib的pie函数实现它。</p>
<table>
<thead>
<tr>
<th>Matplotlib</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>plt.pie(x, labels=None)</td>
<td>x代表要绘制饼图的数据，labels是缺省值，可以为饼图添加标签</td>
</tr>
</tbody></table>
<p>这里设置了lables数组，分别代表高中、本科、硕士、博士和其他几种学历的分类标签。nums代表这些学历对应的人数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">nums = [<span class="number">25</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">37</span>, <span class="number">6</span>]</span><br><span class="line">labels = [<span class="string">'High-school'</span>,<span class="string">'Bachelor'</span>,<span class="string">'Master'</span>,<span class="string">'Ph.d'</span>, <span class="string">'Others'</span>]</span><br><span class="line"><span class="comment"># 用Matplotlib画饼图</span></span><br><span class="line">plt.pie(x = nums, labels=labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/196.png" alt="196" style="zoom:50%;">

<h4 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h4><p>热力图，英文叫heat map，是一种矩阵表示方法，其中矩阵中的元素值用颜色来代表，不同的颜色代表不同大小的值。通过颜色就能直观地知道某个位置上数值的大小。另外你也可以将这个位置上的颜色，与数据集中的其他位置颜色进行比较。</p>
<p>热力图是一种非常直观的多元变量分析方法。</p>
<p>一般使用Seaborn中的sns.heatmap(data)函数，其中data代表需要绘制的热力图数据。</p>
<p>这里使用Seaborn中自带的数据集flights，该数据集记录了1949年到1960年期间，每个月的航班乘客的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">flights = sns.load_dataset(<span class="string">"flights"</span>)</span><br><span class="line">data=flights.pivot(<span class="string">'year'</span>,<span class="string">'month'</span>,<span class="string">'passengers'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Seaborn画热力图</span></span><br><span class="line">sns.heatmap(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>（此处运行导入fights数据集失败，问题同成对关系）</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/49.png" alt="49" style="zoom: 40%;">

<p>通过seaborn的heatmap函数，可以观察到不同年份，不同月份的乘客数量变化情况，其中颜色越浅的代表乘客数量越多</p>
<h4 id="蜘蛛图"><a href="#蜘蛛图" class="headerlink" title="蜘蛛图"></a>蜘蛛图</h4><p>蜘蛛图是一种显示<strong>一对多</strong>关系的方法。在蜘蛛图中，一个变量相对于另一个变量的显著性是清晰可见的。</p>
<p>假设我们想要给王者荣耀的玩家做一个战力图，指标一共包括推进、KDA、生存、团战、发育和输出。那该如何做呢？</p>
<p>这里我们需要使用<strong>Matplotlib</strong>来进行画图：首先设置两个数组：<strong>labels</strong>和<strong>stats</strong>。他们分别保存了这些属性的名称和属性值。</p>
<p>因为蜘蛛图是一个圆形，需要计算每个坐标的角度，然后对这些数值进行设置。当画完最后一个点后，需要与第一个点进行连线。</p>
<p>因为需要计算角度，所以我们要准备<strong>angles</strong>数组；又因为需要设定统计结果的数值，所以我们要设定<strong>stats</strong>数组。并且需要在原有angles和stats数组上增加一位，也就是添加数组的第一个元素。<br>一些画图函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">labels=np.array([<span class="string">u"推进"</span>,<span class="string">"KDA"</span>,<span class="string">u"生存"</span>,<span class="string">u"团战"</span>,<span class="string">u"发育"</span>,<span class="string">u"输出"</span>])</span><br><span class="line">stats=[<span class="number">83</span>, <span class="number">61</span>, <span class="number">95</span>, <span class="number">67</span>, <span class="number">76</span>, <span class="number">88</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图数据准备，角度、状态值</span></span><br><span class="line">angles=np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, len(labels), endpoint=<span class="literal">False</span>)</span><br><span class="line">stats=np.concatenate((stats,[stats[<span class="number">0</span>]]))</span><br><span class="line">angles=np.concatenate((angles,[angles[<span class="number">0</span>]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Matplotlib画蜘蛛图</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, polar=<span class="literal">True</span>)   </span><br><span class="line">ax.plot(angles, stats, <span class="string">'o-'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">ax.fill(angles, stats, alpha=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">ax.set_thetagrids(angles * <span class="number">180</span>/np.pi, labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>plt.figure是创建一个空白的figure对象，这样做的目的相当于画画前先准备一个空白的画板。</p>
<p>add_subplot(111)可以把画板划分成1行1列。</p>
<p>ax.plot和ax.fill进行连线以及给图形上色。</p>
<p>最后set_thetagrids在相应的位置上显示出属性名。</p>
<p>这里需要用到中文，Matplotlib对中文的显示不是很友好，需要设置中文字体<a href="https://www.zhihu.com/question/25404709，u&quot;中文&quot;" target="_blank" rel="noopener">https://www.zhihu.com/question/25404709，u&quot;中文&quot;</a></p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/45.png" alt="45" style="zoom:50%;">

<h4 id="二元变量分布"><a href="#二元变量分布" class="headerlink" title="二元变量分布"></a>二元变量分布</h4><p>如果我们想要看<strong>两个变量</strong>之间的关系，就需要用到二元变量分布。当然二元变量分布有多种呈现方式，开头给你介绍的散点图就是一种二元变量分布。</p>
<table>
<thead>
<tr>
<th>Seaborn</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>sns.jointplot(x, y, data=None, kind)</td>
<td>kind表示不同的视图类型：<br>“kind=‘scatter’”代表散点图，“kind=‘kde’”代表核密度图，“kind=‘hex’ ”代表Hexbin图，它代表的是直方图的二维模拟。</td>
</tr>
</tbody></table>
<p>这里我们使用Seaborn中自带的数据集tips，这个数据集记录了不同顾客在餐厅的消费账单及小费情况。代码中total_bill保存了客户的账单金额，tip是该客户给出的小费金额。我们可以用Seaborn中的jointplot来探索这两个变量之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line"><span class="comment"># 此处调用Seaborn中自带的数据集tips，需要联网</span></span><br><span class="line"><span class="comment"># 会遇到 错误，是验证错误，下面两行解决</span></span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(<span class="string">"tips"</span>)</span><br><span class="line">print(tips.head(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用Seaborn画二元变量分布图（散点图，核密度图，Hexbin图）</span></span><br><span class="line">sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, kind=<span class="string">'scatter'</span>)</span><br><span class="line">sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, kind=<span class="string">'kde'</span>)</span><br><span class="line">sns.jointplot(x=<span class="string">"total_bill"</span>, y=<span class="string">"tip"</span>, data=tips, kind=<span class="string">'hex'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/46.png" alt="46" style="zoom:50%;">

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/47.png" alt="47" style="zoom:50%;">

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/48.png" alt="48" style="zoom:50%;">

<h4 id="成对关系"><a href="#成对关系" class="headerlink" title="成对关系"></a>成对关系</h4><p>如果想要探索数据集中的<strong>多个成对</strong>双变量的分布，可以直接采用<strong>sns.pairplot()</strong>函数。</p>
<p>它会同时展示出DataFrame中每对变量的关系，另外在对角线上，你能看到每个变量自身作为单变量的分布情况。它可以说是探索性分析中的常用函数，可以很快帮我们理解变量对之间的关系。</p>
<p>pairplot函数的使用，就像在DataFrame中使用describe()函数一样方便，是数据探索中的<strong>常用函数</strong>。</p>
<br>

<p>这里我们使用Seaborn中自带的iris数据集，这个数据集也叫鸢尾花数据集。鸢尾花可以分成Setosa、Versicolour和Virginica三个品种，在这个数据集中，针对每一个品种，都有50个数据，每个数据中包括了4个属性，分别是花萼长度、花萼宽度、花瓣长度和花瓣宽度。通过这些数据，需要你来预测鸢尾花卉属于三个品种中的哪一种。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">iris = sns.load_dataset(<span class="string">'iris'</span>)</span><br><span class="line"><span class="comment"># 用Seaborn画成对关系</span></span><br><span class="line">sns.pairplot(iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>这里我们用Seaborn中的pairplot函数来对数据集中的多个双变量的关系进行探索，如下图所示。从图上你能看出，一共有sepal_length、sepal_width、petal_length和petal_width4个变量，它们分别是花萼长度、花萼宽度、花瓣长度和花瓣宽度。</p>
<p>（此处导入数据集失败，<code>urllib.error.URLError: &lt;urlopen error [Errno 61] Connection refused&gt;</code>，还没解决。tips数据集导入没有问题，iris有问题）</p>
<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/50.png" alt="50" style="zoom:40%;">

<h4 id="一些画图函数"><a href="#一些画图函数" class="headerlink" title="一些画图函数"></a>一些画图函数</h4><h5 id="多画布"><a href="#多画布" class="headerlink" title="多画布"></a>多画布</h5><p>plt.subplots(nrows, ncols)</p>
<p>以直方图举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">#创建一个一行三列的画布</span></span><br><span class="line">sns.distplot(x,ax=axes[<span class="number">0</span>]) <span class="comment">#左图</span></span><br><span class="line">sns.distplot(x,hist=<span class="literal">False</span>,ax=axes[<span class="number">1</span>]) <span class="comment">#中图</span></span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>,ax=axes[<span class="number">2</span>]) <span class="comment">#右图</span></span><br></pre></td></tr></table></figure>

<img src="//mangosTeeN96.github.io/2019/12/28/python数据分析/41.png" alt="41" style="zoom:50%;">

<ul>
<li><p>matplotlib中：axes[0].bar()形式</p>
</li>
<li><p>seaborn中：sns.barplot( ,ax=axes[1])形式</p>
</li>
</ul>
<h5 id="title"><a href="#title" class="headerlink" title="title"></a>title</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>


      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/数据分析/" rel="tag"><i class="fa fa-tags"></i> 数据分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/20/Python基础/" rel="next" title="Python基础">
                <i class="fa fa-chevron-left"></i> Python基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/08/python数据分析算法/" rel="prev" title="python数据分析算法">
                python数据分析算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="MangosTeen">
            
              <p class="site-author-name" itemprop="name">MangosTeen</p>
              <div class="site-description motion-element" itemprop="description">想养一只猫</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/mangosTeeN96" title="Git &rarr; https://github.com/mangosTeeN96" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:mangosteen1996@gmail.com" title="Mail &rarr; mailto:mangosteen1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://www.weibo.com/u/5311979032?topnav=1&wvr=6&topsug=1" title="Weibo &rarr; https://www.weibo.com/u/5311979032?topnav=1&wvr=6&topsug=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python数据分析"><span class="nav-text">python数据分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数据分析全景图"><span class="nav-text">1. 数据分析全景图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-数据挖掘的最佳路径"><span class="nav-text">2.数据挖掘的最佳路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Python基础语法"><span class="nav-text">3.Python基础语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Numpy快速处理数据"><span class="nav-text">4.Numpy快速处理数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#numpy数组"><span class="nav-text">numpy数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#numpy结构化数组——structured-array"><span class="nav-text">numpy结构化数组——structured array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#numpy读取本地文件"><span class="nav-text">numpy读取本地文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#numpy索引和切片"><span class="nav-text">numpy索引和切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成随机数"><span class="nav-text">生成随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nan、inf"><span class="nav-text">nan、inf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#numpy常用函数大全"><span class="nav-text">numpy常用函数大全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本情况"><span class="nav-text">基本情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ndarray数组的创建"><span class="nav-text">ndarray数组的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的维度变换"><span class="nav-text">数组的维度变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的类型变换"><span class="nav-text">数组的类型变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的索引和切片"><span class="nav-text">数组的索引和切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的运算"><span class="nav-text">数组的运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据的CSV文件存取"><span class="nav-text">数据的CSV文件存取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numpy随机数函数"><span class="nav-text">numpy随机数函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numpy的统计函数"><span class="nav-text">numpy的统计函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numpy的梯度函数"><span class="nav-text">numpy的梯度函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图像的表示和变换"><span class="nav-text">图像的表示和变换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#※-numpy重点函数-※"><span class="nav-text">※ numpy重点函数 ※</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建数组"><span class="nav-text">1. 创建数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-结构数组"><span class="nav-text">2. 结构数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-连续数组的创建"><span class="nav-text">3. 连续数组的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-算数运算"><span class="nav-text">4. 算数运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-统计函数"><span class="nav-text">5. 统计函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Numpy排序"><span class="nav-text">6. Numpy排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Pandas"><span class="nav-text">5.Pandas</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pandas之字符串方法"><span class="nav-text">pandas之字符串方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#series"><span class="nav-text">series</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取数据"><span class="nav-text">读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DataFrame的一些操作"><span class="nav-text">DataFrame的一些操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#去重"><span class="nav-text">去重</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历"><span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#列操作"><span class="nav-text">列操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#行列操作"><span class="nav-text">行列操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#筛选操作"><span class="nav-text">筛选操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除操作"><span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增加操作"><span class="nav-text">增加操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序、缺失值处理"><span class="nav-text">排序、缺失值处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用统计函数"><span class="nav-text">常用统计函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据合并、分组"><span class="nav-text">数据合并、分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引"><span class="nav-text">索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间序列"><span class="nav-text">时间序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#※-pandas-重点-※"><span class="nav-text">※ pandas 重点 ※</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据结构"><span class="nav-text">1. 数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数据导入与输出"><span class="nav-text">2. 数据导入与输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-数据清洗"><span class="nav-text">3. 数据清洗</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-数据统计"><span class="nav-text">4. 数据统计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-数据表合并"><span class="nav-text">5. 数据表合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结-1"><span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-学数据分析要掌握的基本概念"><span class="nav-text">6.学数据分析要掌握的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#商业智能BI、数据仓库DW、数据挖掘DM"><span class="nav-text">商业智能BI、数据仓库DW、数据挖掘DM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元数据-VS-数据元"><span class="nav-text">元数据 VS 数据元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据挖掘的流程"><span class="nav-text">数据挖掘的流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-用户画像：标签化就是数据的抽象能力"><span class="nav-text">7. 用户画像：标签化就是数据的抽象能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户画像建模"><span class="nav-text">用户画像建模</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-数据采集"><span class="nav-text">8.数据采集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开放数据源"><span class="nav-text">开放数据源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#爬虫抓取"><span class="nav-text">爬虫抓取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志采集工具"><span class="nav-text">日志采集工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-数据采集：使用八爪鱼采集微博上的D-amp-G评论"><span class="nav-text">9.数据采集：使用八爪鱼采集微博上的D&amp;G评论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-Python爬虫"><span class="nav-text">10.Python爬虫</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-数据清洗"><span class="nav-text">11.数据清洗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据清洗规则"><span class="nav-text">数据清洗规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pandas举例"><span class="nav-text">Pandas举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-数据集成"><span class="nav-text">12.数据集成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据集成的两种架构：ELT和ETL"><span class="nav-text">数据集成的两种架构：ELT和ETL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ETL工具"><span class="nav-text">ETL工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-数据变换"><span class="nav-text">13.数据变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的变换方法"><span class="nav-text">常见的变换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据规范化的几种方法"><span class="nav-text">数据规范化的几种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python的SciKit-Learn库使用"><span class="nav-text">Python的SciKit-Learn库使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-数据可视化"><span class="nav-text">14.数据可视化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-Python数据可视化的10种技能"><span class="nav-text">15.Python数据可视化的10种技能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可视化视图有哪些"><span class="nav-text">可视化视图有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#散点图"><span class="nav-text">散点图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#折线图"><span class="nav-text">折线图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直方图"><span class="nav-text">直方图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核密度估计图"><span class="nav-text">核密度估计图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条形图"><span class="nav-text">条形图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#箱线图"><span class="nav-text">箱线图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#饼图"><span class="nav-text">饼图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热力图"><span class="nav-text">热力图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#蜘蛛图"><span class="nav-text">蜘蛛图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二元变量分布"><span class="nav-text">二元变量分布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成对关系"><span class="nav-text">成对关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些画图函数"><span class="nav-text">一些画图函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多画布"><span class="nav-text">多画布</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#title"><span class="nav-text">title</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MangosTeen</span>

  

  
</div>





        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  <script async src="/js/cursor/fireworks.js"></script>




</body>
</html>
